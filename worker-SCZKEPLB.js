var Tr=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var Tc;function fa(){return Tc}function vn(e){let t=Tc;return Tc=e,t}var wv=Symbol("NotFound");function mi(e){return e===wv||e?.name==="\u0275NotFound"}var ht=null,pa=!1,$c=1,pk=null,it=Symbol("SIGNAL");function ae(e){let t=ht;return ht=e,t}function ma(){return ht}var Co={version:0,lastCleanEpoch:0,dirty:!1,producers:void 0,producersTail:void 0,consumers:void 0,consumersTail:void 0,recomputing:!1,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function gi(e){if(pa)throw new Error("");if(ht===null)return;ht.consumerOnSignalRead(e);let t=ht.producersTail;if(t!==void 0&&t.producer===e)return;let n,r=ht.recomputing;if(r&&(n=t!==void 0?t.nextProducer:ht.producers,n!==void 0&&n.producer===e)){ht.producersTail=n,n.lastReadVersion=e.version;return}let i=e.consumersTail;if(i!==void 0&&i.consumer===ht&&(!r||mk(i,ht)))return;let o=yi(ht),s={producer:e,consumer:ht,nextProducer:n,prevConsumer:i,lastReadVersion:e.version,nextConsumer:void 0};ht.producersTail=s,t!==void 0?t.nextProducer=s:ht.producers=s,o&&Ev(e,s)}function bv(){$c++}function Mc(e){if(!(yi(e)&&!e.dirty)&&!(!e.dirty&&e.lastCleanEpoch===$c)){if(!e.producerMustRecompute(e)&&!ya(e)){Sc(e);return}e.producerRecomputeValue(e),Sc(e)}}function Nc(e){if(e.consumers===void 0)return;let t=pa;pa=!0;try{for(let n=e.consumers;n!==void 0;n=n.nextConsumer){let r=n.consumer;r.dirty||hk(r)}}finally{pa=t}}function kc(){return ht?.consumerAllowSignalWrites!==!1}function hk(e){e.dirty=!0,Nc(e),e.consumerMarkedDirty?.(e)}function Sc(e){e.dirty=!1,e.lastCleanEpoch=$c}function Do(e){return e&&Iv(e),ae(e)}function Iv(e){e.producersTail=void 0,e.recomputing=!0}function ga(e,t){ae(t),e&&xv(e)}function xv(e){e.recomputing=!1;let t=e.producersTail,n=t!==void 0?t.nextProducer:e.producers;if(n!==void 0){if(yi(e))do n=Ac(n);while(n!==void 0);t!==void 0?t.nextProducer=void 0:e.producers=void 0}}function ya(e){for(let t=e.producers;t!==void 0;t=t.nextProducer){let n=t.producer,r=t.lastReadVersion;if(r!==n.version||(Mc(n),r!==n.version))return!0}return!1}function So(e){if(yi(e)){let t=e.producers;for(;t!==void 0;)t=Ac(t)}e.producers=void 0,e.producersTail=void 0,e.consumers=void 0,e.consumersTail=void 0}function Ev(e,t){let n=e.consumersTail,r=yi(e);if(n!==void 0?(t.nextConsumer=n.nextConsumer,n.nextConsumer=t):(t.nextConsumer=void 0,e.consumers=t),t.prevConsumer=n,e.consumersTail=t,!r)for(let i=e.producers;i!==void 0;i=i.nextProducer)Ev(i.producer,i)}function Ac(e){let t=e.producer,n=e.nextProducer,r=e.nextConsumer,i=e.prevConsumer;if(e.nextConsumer=void 0,e.prevConsumer=void 0,r!==void 0?r.prevConsumer=i:t.consumersTail=i,i!==void 0)i.nextConsumer=r;else if(t.consumers=r,!yi(t)){let o=t.producers;for(;o!==void 0;)o=Ac(o)}return n}function yi(e){return e.consumerIsAlwaysLive||e.consumers!==void 0}function Rc(e){pk?.(e)}function mk(e,t){let n=t.producersTail;if(n!==void 0){let r=t.producers;do{if(r===e)return!0;if(r===n)break;r=r.nextProducer}while(r!==void 0)}return!1}function Oc(e,t){return Object.is(e,t)}function va(e,t){let n=Object.create(gk);n.computation=e,t!==void 0&&(n.equal=t);let r=()=>{if(Mc(n),gi(n),n.value===ha)throw n.error;return n.value};return r[it]=n,Rc(n),r}var Cc=Symbol("UNSET"),Dc=Symbol("COMPUTING"),ha=Symbol("ERRORED"),gk={...Co,value:Cc,dirty:!0,error:null,equal:Oc,kind:"computed",producerMustRecompute(e){return e.value===Cc||e.value===Dc},producerRecomputeValue(e){if(e.value===Dc)throw new Error("");let t=e.value;e.value=Dc;let n=Do(e),r,i=!1;try{r=e.computation(),ae(null),i=t!==Cc&&t!==ha&&r!==ha&&e.equal(t,r)}catch(o){r=ha,e.error=o}finally{ga(e,n)}if(i){e.value=t;return}e.value=r,e.version++}};function yk(){throw new Error}var Tv=yk;function Cv(e){Tv(e)}function Pc(e){Tv=e}var vk=null;function Lc(e,t){let n=Object.create(_a);n.value=e,t!==void 0&&(n.equal=t);let r=(()=>Dv(n));return r[it]=n,Rc(n),[r,s=>vi(n,s),s=>Sv(n,s)]}function Dv(e){return gi(e),e.value}function vi(e,t){kc()||Cv(e),e.equal(e.value,t)||(e.value=t,_k(e))}function Sv(e,t){kc()||Cv(e),vi(e,t(e.value))}var _a={...Co,equal:Oc,value:void 0,kind:"signal"};function _k(e){e.version++,bv(),Nc(e),vk?.(e)}function Ct(e){return typeof e=="function"}function wa(e){let n=e(r=>{Error.call(r),r.stack=new Error().stack});return n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n}var ba=wa(e=>function(n){e(this),this.message=n?`${n.length} errors occurred during unsubscription:
${n.map((r,i)=>`${i+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=n});function $o(e,t){if(e){let n=e.indexOf(t);0<=n&&e.splice(n,1)}}var _t=class e{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;let{_parentage:n}=this;if(n)if(this._parentage=null,Array.isArray(n))for(let o of n)o.remove(this);else n.remove(this);let{initialTeardown:r}=this;if(Ct(r))try{r()}catch(o){t=o instanceof ba?o.errors:[o]}let{_finalizers:i}=this;if(i){this._finalizers=null;for(let o of i)try{$v(o)}catch(s){t=t??[],s instanceof ba?t=[...t,...s.errors]:t.push(s)}}if(t)throw new ba(t)}}add(t){var n;if(t&&t!==this)if(this.closed)$v(t);else{if(t instanceof e){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=(n=this._finalizers)!==null&&n!==void 0?n:[]).push(t)}}_hasParent(t){let{_parentage:n}=this;return n===t||Array.isArray(n)&&n.includes(t)}_addParent(t){let{_parentage:n}=this;this._parentage=Array.isArray(n)?(n.push(t),n):n?[n,t]:t}_removeParent(t){let{_parentage:n}=this;n===t?this._parentage=null:Array.isArray(n)&&$o(n,t)}remove(t){let{_finalizers:n}=this;n&&$o(n,t),t instanceof e&&t._removeParent(this)}};_t.EMPTY=(()=>{let e=new _t;return e.closed=!0,e})();var Fc=_t.EMPTY;function Ia(e){return e instanceof _t||e&&"closed"in e&&Ct(e.remove)&&Ct(e.add)&&Ct(e.unsubscribe)}function $v(e){Ct(e)?e():e.unsubscribe()}var Zt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var _i={setTimeout(e,t,...n){let{delegate:r}=_i;return r?.setTimeout?r.setTimeout(e,t,...n):setTimeout(e,t,...n)},clearTimeout(e){let{delegate:t}=_i;return(t?.clearTimeout||clearTimeout)(e)},delegate:void 0};function Mv(e){_i.setTimeout(()=>{let{onUnhandledError:t}=Zt;if(t)t(e);else throw e})}function zc(){}var Nv=Bc("C",void 0,void 0);function kv(e){return Bc("E",void 0,e)}function Av(e){return Bc("N",e,void 0)}function Bc(e,t,n){return{kind:e,value:t,error:n}}var Cr=null;function wi(e){if(Zt.useDeprecatedSynchronousErrorHandling){let t=!Cr;if(t&&(Cr={errorThrown:!1,error:null}),e(),t){let{errorThrown:n,error:r}=Cr;if(Cr=null,n)throw r}}else e()}function Rv(e){Zt.useDeprecatedSynchronousErrorHandling&&Cr&&(Cr.errorThrown=!0,Cr.error=e)}var Dr=class extends _t{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Ia(t)&&t.add(this)):this.destination=Ik}static create(t,n,r){return new bi(t,n,r)}next(t){this.isStopped?Vc(Av(t),this):this._next(t)}error(t){this.isStopped?Vc(kv(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?Vc(Nv,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},wk=Function.prototype.bind;function jc(e,t){return wk.call(e,t)}var Hc=class{constructor(t){this.partialObserver=t}next(t){let{partialObserver:n}=this;if(n.next)try{n.next(t)}catch(r){xa(r)}}error(t){let{partialObserver:n}=this;if(n.error)try{n.error(t)}catch(r){xa(r)}else xa(t)}complete(){let{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(n){xa(n)}}},bi=class extends Dr{constructor(t,n,r){super();let i;if(Ct(t)||!t)i={next:t??void 0,error:n??void 0,complete:r??void 0};else{let o;this&&Zt.useDeprecatedNextContext?(o=Object.create(t),o.unsubscribe=()=>this.unsubscribe(),i={next:t.next&&jc(t.next,o),error:t.error&&jc(t.error,o),complete:t.complete&&jc(t.complete,o)}):i=t}this.destination=new Hc(i)}};function xa(e){Zt.useDeprecatedSynchronousErrorHandling?Rv(e):Mv(e)}function bk(e){throw e}function Vc(e,t){let{onStoppedNotification:n}=Zt;n&&_i.setTimeout(()=>n(e,t))}var Ik={closed:!0,next:zc,error:bk,complete:zc};var Ov=typeof Symbol=="function"&&Symbol.observable||"@@observable";function Pv(e){return e}function Lv(e){return e.length===0?Pv:e.length===1?e[0]:function(n){return e.reduce((r,i)=>i(r),n)}}var _n=class e{constructor(t){t&&(this._subscribe=t)}lift(t){let n=new e;return n.source=this,n.operator=t,n}subscribe(t,n,r){let i=Ek(t)?t:new bi(t,n,r);return wi(()=>{let{operator:o,source:s}=this;i.add(o?o.call(i,s):s?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(t){try{return this._subscribe(t)}catch(n){t.error(n)}}forEach(t,n){return n=Fv(n),new n((r,i)=>{let o=new bi({next:s=>{try{t(s)}catch(a){i(a),o.unsubscribe()}},error:i,complete:r});this.subscribe(o)})}_subscribe(t){var n;return(n=this.source)===null||n===void 0?void 0:n.subscribe(t)}[Ov](){return this}pipe(...t){return Lv(t)(this)}toPromise(t){return t=Fv(t),new t((n,r)=>{let i;this.subscribe(o=>i=o,o=>r(o),()=>n(i))})}};_n.create=e=>new _n(e);function Fv(e){var t;return(t=e??Zt.Promise)!==null&&t!==void 0?t:Promise}function xk(e){return e&&Ct(e.next)&&Ct(e.error)&&Ct(e.complete)}function Ek(e){return e&&e instanceof Dr||xk(e)&&Ia(e)}function Tk(e){return Ct(e?.lift)}function zv(e){return t=>{if(Tk(t))return t.lift(function(n){try{return e(n,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Bv(e,t,n,r,i){return new Uc(e,t,n,r,i)}var Uc=class extends Dr{constructor(t,n,r,i,o,s){super(t),this.onFinalize=o,this.shouldUnsubscribe=s,this._next=n?function(a){try{n(a)}catch(u){t.error(u)}}:super._next,this._error=i?function(a){try{i(a)}catch(u){t.error(u)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:n}=this;super.unsubscribe(),!n&&((t=this.onFinalize)===null||t===void 0||t.call(this))}}};var jv=wa(e=>function(){e(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var Yt=class extends _n{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(t){let n=new Ea(this,this);return n.operator=t,n}_throwIfClosed(){if(this.closed)throw new jv}next(t){wi(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let n of this.currentObservers)n.next(t)}})}error(t){wi(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=t;let{observers:n}=this;for(;n.length;)n.shift().error(t)}})}complete(){wi(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:t}=this;for(;t.length;)t.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var t;return((t=this.observers)===null||t===void 0?void 0:t.length)>0}_trySubscribe(t){return this._throwIfClosed(),super._trySubscribe(t)}_subscribe(t){return this._throwIfClosed(),this._checkFinalizedStatuses(t),this._innerSubscribe(t)}_innerSubscribe(t){let{hasError:n,isStopped:r,observers:i}=this;return n||r?Fc:(this.currentObservers=null,i.push(t),new _t(()=>{this.currentObservers=null,$o(i,t)}))}_checkFinalizedStatuses(t){let{hasError:n,thrownError:r,isStopped:i}=this;n?t.error(r):i&&t.complete()}asObservable(){let t=new _n;return t.source=this,t}};Yt.create=(e,t)=>new Ea(e,t);var Ea=class extends Yt{constructor(t,n){super(),this.destination=t,this.source=n}next(t){var n,r;(r=(n=this.destination)===null||n===void 0?void 0:n.next)===null||r===void 0||r.call(n,t)}error(t){var n,r;(r=(n=this.destination)===null||n===void 0?void 0:n.error)===null||r===void 0||r.call(n,t)}complete(){var t,n;(n=(t=this.destination)===null||t===void 0?void 0:t.complete)===null||n===void 0||n.call(t)}_subscribe(t){var n,r;return(r=(n=this.source)===null||n===void 0?void 0:n.subscribe(t))!==null&&r!==void 0?r:Fc}};var Mo=class extends Yt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){let n=super._subscribe(t);return!n.closed&&t.next(this._value),n}getValue(){let{hasError:t,thrownError:n,_value:r}=this;if(t)throw n;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}};function Wc(e,t){return zv((n,r)=>{let i=0;n.subscribe(Bv(r,o=>{r.next(e.call(t,o,i++))}))})}var Gc=class{full;major;minor;patch;constructor(t){this.full=t;let n=t.split(".");this.major=n[0],this.minor=n[1],this.patch=n.slice(2).join(".")}},Vv=new Gc("20.3.4"),v4=`https://${Vv.major!=="0"?`v${Vv.major}.`:""}angular.dev/errors`,id="https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss",ie=class extends Error{code;constructor(t,n){super(Nr(t,n)),this.code=t}};function Ck(e){return`NG0${Math.abs(e)}`}function Nr(e,t){return`${Ck(e)}${t?": "+t:""}`}var Ut=globalThis;function Me(e){for(let t in e)if(e[t]===Me)return t;throw Error("")}function qv(e,t){for(let n in t)t.hasOwnProperty(n)&&!e.hasOwnProperty(n)&&(e[n]=t[n])}function Jt(e){if(typeof e=="string")return e;if(Array.isArray(e))return`[${e.map(Jt).join(", ")}]`;if(e==null)return""+e;let t=e.overriddenName||e.name;if(t)return`${t}`;let n=e.toString();if(n==null)return""+n;let r=n.indexOf(`
`);return r>=0?n.slice(0,r):n}function $a(e,t){return e?t?`${e} ${t}`:e:t||""}var Dk=Me({__forward_ref__:Me});function Ma(e){return e.__forward_ref__=Ma,e.toString=function(){return Jt(this())},e}function Se(e){return Oo(e)?e():e}function Oo(e){return typeof e=="function"&&e.hasOwnProperty(Dk)&&e.__forward_ref__===Ma}function Gv(e,t,n){e!=t&&Kv(n,e,t,"==")}function Kv(e,t,n,r){throw new Error(`ASSERTION ERROR: ${e}`+(r==null?"":` [Expected=> ${n} ${r} ${t} <=Actual]`))}function Ae(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function Na(e){return{providers:e.providers||[],imports:e.imports||[]}}function od(e){return Sk(e,Po)}function Sk(e,t){return e.hasOwnProperty(t)&&e[t]||null}function $k(e){let t=e?.[Po]??null;return t||null}function Kc(e){return e&&e.hasOwnProperty(Ca)?e[Ca]:null}var Po=Me({\u0275prov:Me}),Ca=Me({\u0275inj:Me}),ne=class{_desc;ngMetadataName="InjectionToken";\u0275prov;constructor(t,n){this._desc=t,this.\u0275prov=void 0,typeof n=="number"?this.__NG_ELEMENT_ID__=n:n!==void 0&&(this.\u0275prov=Ae({token:this,providedIn:n.providedIn||"root",factory:n.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function Qv(e){return e&&!!e.\u0275providers}var Ti=Me({\u0275cmp:Me}),ka=Me({\u0275dir:Me}),Aa=Me({\u0275pipe:Me}),sd=Me({\u0275mod:Me}),wn=Me({\u0275fac:Me}),Ci=Me({__NG_ELEMENT_ID__:Me}),Hv=Me({__NG_ENV_ID__:Me});function ve(e){return typeof e=="string"?e:e==null?"":String(e)}function tn(e){return typeof e=="function"?e.name||e.toString():typeof e=="object"&&e!=null&&typeof e.type=="function"?e.type.name||e.type.toString():ve(e)}var Zv=Me({ngErrorCode:Me}),Mk=Me({ngErrorMessage:Me}),Nk=Me({ngTokenPath:Me});function ad(e,t){return Yv("",-200,t)}function Ra(e,t){throw new ie(-201,!1)}function Yv(e,t,n){let r=new ie(t,e);return r[Zv]=t,r[Mk]=e,n&&(r[Nk]=n),r}function kk(e){return e[Zv]}var Qc;function Jv(){return Qc}function wt(e){let t=Qc;return Qc=e,t}function ud(e,t,n){let r=od(e);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(n&8)return null;if(t!==void 0)return t;Ra(e,"Injector")}var Ak={},Sr=Ak,Zc="__NG_DI_FLAG__",Yc=class{injector;constructor(t){this.injector=t}retrieve(t,n){let r=xi(n)||0;try{return this.injector.get(t,r&8?null:Sr,r)}catch(i){if(mi(i))return i;throw i}}};function Rk(e,t=0){let n=fa();if(n===void 0)throw new ie(-203,!1);if(n===null)return ud(e,void 0,t);{let r=Ok(t),i=n.retrieve(e,r);if(mi(i)){if(r.optional)return null;throw i}return i}}function mt(e,t=0){return(Jv()||Rk)(Se(e),t)}function ld(e){throw new ie(202,!1)}function re(e,t){return mt(e,xi(t))}function xi(e){return typeof e>"u"||typeof e=="number"?e:0|(e.optional&&8)|(e.host&&1)|(e.self&&2)|(e.skipSelf&&4)}function Ok(e){return{optional:!!(e&8),host:!!(e&1),self:!!(e&2),skipSelf:!!(e&4)}}function Jc(e){let t=[];for(let n=0;n<e.length;n++){let r=Se(e[n]);if(Array.isArray(r)){if(r.length===0)throw new ie(900,!1);let i,o=0;for(let s=0;s<r.length;s++){let a=r[s],u=Pk(a);typeof u=="number"?u===-1?i=a.token:o|=u:i=a}t.push(mt(i,o))}else t.push(mt(r))}return t}function Di(e,t){return e[Zc]=t,e.prototype[Zc]=t,e}function Pk(e){return e[Zc]}function nr(e,t){let n=e.hasOwnProperty(wn);return n?e[wn]:null}function Xv(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){let i=e[r],o=t[r];if(n&&(i=n(i),o=n(o)),o!==i)return!1}return!0}function nn(e){return e.flat(Number.POSITIVE_INFINITY)}function Oa(e,t){e.forEach(n=>Array.isArray(n)?Oa(n,t):t(n))}function cd(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function Lo(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function Fo(e,t){let n=[];for(let r=0;r<e;r++)n.push(t);return n}function dd(e,t,n){let r=e.length-n;for(;t<r;)e[t]=e[t+n],t++;for(;n--;)e.pop()}function fd(e,t,n,r){let i=e.length;if(i==t)e.push(n,r);else if(i===1)e.push(r,e[0]),e[0]=n;else{for(i--,e.push(e[i-1],e[i]);i>t;){let o=i-2;e[i]=e[o],i--}e[t]=n,e[t+1]=r}}function zo(e,t,n){let r=Si(e,t);return r>=0?e[r|1]=n:(r=~r,fd(e,r,t,n)),r}function Pa(e,t){let n=Si(e,t);if(n>=0)return e[n|1]}function Si(e,t){return Lk(e,t,1)}function Lk(e,t,n){let r=0,i=e.length>>n;for(;i!==r;){let o=r+(i-r>>1),s=e[o<<n];if(t===s)return o<<n;s>t?i=o:r=o+1}return~(i<<n)}var Wt={},Ne=[],kr=new ne(""),e_=new ne("",-1),pd=new ne(""),ko=class{get(t,n=Sr){if(n===Sr){let i=Yv("",-201);throw i.name="\u0275NotFound",i}return n}};function Ar(e){return e[sd]||null}function La(e){let t=Ar(e);if(!t)throw new ie(915,!1);return t}function Ge(e){return e[Ti]||null}function Rt(e){return e[ka]||null}function rn(e){return e[Aa]||null}function Fa(e){let t=Ge(e)||Rt(e)||rn(e);return t!==null&&t.standalone}function Fk(...e){return{\u0275providers:za(!0,e),\u0275fromNgModule:!0}}function za(e,...t){let n=[],r=new Set,i,o=s=>{n.push(s)};return Oa(t,s=>{let a=s;Da(a,o,[],r)&&(i||=[],i.push(a))}),i!==void 0&&t_(i,o),n}function t_(e,t){for(let n=0;n<e.length;n++){let{ngModule:r,providers:i}=e[n];hd(i,o=>{t(o,r)})}}function Da(e,t,n,r){if(e=Se(e),!e)return!1;let i=null,o=Kc(e),s=!o&&Ge(e);if(!o&&!s){let u=e.ngModule;if(o=Kc(u),o)i=u;else return!1}else{if(s&&!s.standalone)return!1;i=e}let a=r.has(i);if(s){if(a)return!1;if(r.add(i),s.dependencies){let u=typeof s.dependencies=="function"?s.dependencies():s.dependencies;for(let c of u)Da(c,t,n,r)}}else if(o){if(o.imports!=null&&!a){r.add(i);let c;try{Oa(o.imports,d=>{Da(d,t,n,r)&&(c||=[],c.push(d))})}finally{}c!==void 0&&t_(c,t)}if(!a){let c=nr(i)||(()=>new i);t({provide:i,useFactory:c,deps:Ne},i),t({provide:pd,useValue:i,multi:!0},i),t({provide:kr,useValue:()=>mt(i),multi:!0},i)}let u=o.providers;if(u!=null&&!a){let c=e;hd(u,d=>{t(d,c)})}}else return!1;return i!==e&&e.providers!==void 0}function hd(e,t){for(let n of e)Qv(n)&&(n=n.\u0275providers),Array.isArray(n)?hd(n,t):t(n)}var zk=Me({provide:String,useValue:Me});function n_(e){return e!==null&&typeof e=="object"&&zk in e}function Bk(e){return!!(e&&e.useExisting)}function jk(e){return!!(e&&e.useFactory)}function $r(e){return typeof e=="function"}function r_(e){return!!e.useClass}var md=new ne(""),Ta={},Uv={},qc;function Bo(){return qc===void 0&&(qc=new ko),qc}var Vt=class{},Ei=class extends Vt{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(t,n,r,i){super(),this.parent=n,this.source=r,this.scopes=i,ed(t,s=>this.processProvider(s)),this.records.set(e_,Ii(void 0,this)),i.has("environment")&&this.records.set(Vt,Ii(void 0,this));let o=this.records.get(md);o!=null&&typeof o.value=="string"&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(pd,Ne,{self:!0}))}retrieve(t,n){let r=xi(n)||0;try{return this.get(t,Sr,r)}catch(i){if(mi(i))return i;throw i}}destroy(){No(this),this._destroyed=!0;let t=ae(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let n=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of n)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),ae(t)}}onDestroy(t){return No(this),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){No(this);let n=vn(this),r=wt(void 0),i;try{return t()}finally{vn(n),wt(r)}}get(t,n=Sr,r){if(No(this),t.hasOwnProperty(Hv))return t[Hv](this);let i=xi(r),o,s=vn(this),a=wt(void 0);try{if(!(i&4)){let c=this.records.get(t);if(c===void 0){let d=qk(t)&&od(t);d&&this.injectableDefInScope(d)?c=Ii(Xc(t),Ta):c=null,this.records.set(t,c)}if(c!=null)return this.hydrate(t,c,i)}let u=i&2?Bo():this.parent;return n=i&8&&n===Sr?null:n,u.get(t,n)}catch(u){let c=kk(u);throw c===-200||c===-201?new ie(c,null):u}finally{wt(a),vn(s)}}resolveInjectorInitializers(){let t=ae(null),n=vn(this),r=wt(void 0),i;try{let o=this.get(kr,Ne,{self:!0});for(let s of o)s()}finally{vn(n),wt(r),ae(t)}}toString(){let t=[],n=this.records;for(let r of n.keys())t.push(Jt(r));return`R3Injector[${t.join(", ")}]`}processProvider(t){t=Se(t);let n=$r(t)?t:Se(t&&t.provide),r=Hk(t);if(!$r(t)&&t.multi===!0){let i=this.records.get(n);i||(i=Ii(void 0,Ta,!0),i.factory=()=>Jc(i.multi),this.records.set(n,i)),n=t,i.multi.push(t)}this.records.set(n,r)}hydrate(t,n,r){let i=ae(null);try{if(n.value===Uv)throw ad(Jt(t));return n.value===Ta&&(n.value=Uv,n.value=n.factory(void 0,r)),typeof n.value=="object"&&n.value&&Wk(n.value)&&this._ngOnDestroyHooks.add(n.value),n.value}finally{ae(i)}}injectableDefInScope(t){if(!t.providedIn)return!1;let n=Se(t.providedIn);return typeof n=="string"?n==="any"||this.scopes.has(n):this.injectorDefTypes.has(n)}removeOnDestroy(t){let n=this._onDestroyHooks.indexOf(t);n!==-1&&this._onDestroyHooks.splice(n,1)}};function Xc(e){let t=od(e),n=t!==null?t.factory:nr(e);if(n!==null)return n;if(e instanceof ne)throw new ie(204,!1);if(e instanceof Function)return Vk(e);throw new ie(204,!1)}function Vk(e){if(e.length>0)throw new ie(204,!1);let n=$k(e);return n!==null?()=>n.factory(e):()=>new e}function Hk(e){if(n_(e))return Ii(void 0,e.useValue);{let t=gd(e);return Ii(t,Ta)}}function gd(e,t,n){let r;if($r(e)){let i=Se(e);return nr(i)||Xc(i)}else if(n_(e))r=()=>Se(e.useValue);else if(jk(e))r=()=>e.useFactory(...Jc(e.deps||[]));else if(Bk(e))r=(i,o)=>mt(Se(e.useExisting),o!==void 0&&o&8?8:void 0);else{let i=Se(e&&(e.useClass||e.provide));if(Uk(e))r=()=>new i(...Jc(e.deps));else return nr(i)||Xc(i)}return r}function No(e){if(e.destroyed)throw new ie(205,!1)}function Ii(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function Uk(e){return!!e.deps}function Wk(e){return e!==null&&typeof e=="object"&&typeof e.ngOnDestroy=="function"}function qk(e){return typeof e=="function"||typeof e=="object"&&e.ngMetadataName==="InjectionToken"}function ed(e,t){for(let n of e)Array.isArray(n)?ed(n,t):n&&Qv(n)?ed(n.\u0275providers,t):t(n)}function Ba(e,t){let n;e instanceof Ei?(No(e),n=e):n=new Yc(e);let r,i=vn(n),o=wt(void 0);try{return t()}finally{vn(i),wt(o)}}function yd(){return Jv()!==void 0||fa()!=null}var ut=0,U=1,le=2,qe=3,lt=4,ct=5,ir=6,$i=7,Be=8,Re=9,on=10,be=11,or=12,jo=13,Rr=14,gt=15,jn=16,Or=17,xn=18,Vo=19,vd=20,Bn=21,ja=22,Mi=23,Ot=24,Pr=25,En=26,me=27,_d=1,Vn=6,sr=7,Ho=8,Lr=9,Ke=10;function bt(e){return Array.isArray(e)&&typeof e[_d]=="object"}function Dt(e){return Array.isArray(e)&&e[_d]===!0}function wd(e){return(e.flags&4)!==0}function ar(e){return e.componentOffset>-1}function Ni(e){return(e.flags&1)===1}function St(e){return!!e.template}function ur(e){return(e[le]&512)!==0}function Tn(e){return(e[le]&256)===256}var bd="svg",Id="math";function $t(e){for(;Array.isArray(e);)e=e[ut];return e}function xd(e){for(;Array.isArray(e);){if(typeof e[_d]=="object")return e;e=e[ut]}return null}function Fr(e,t){return $t(t[e])}function dt(e,t){return $t(t[e.index])}function lr(e,t){return e.data[t]}function cr(e,t){return e[t]}function Va(e,t,n,r){n>=e.data.length&&(e.data[n]=null,e.blueprint[n]=null),t[n]=r}function Cn(e,t){let n=t[e];return bt(n)?n:n[ut]}function i_(e){return(e[le]&4)===4}function Ha(e){return(e[le]&128)===128}function o_(e){return Dt(e[qe])}function ft(e,t){return t==null?null:e[t]}function Ed(e){e[Or]=0}function Td(e){e[le]&1024||(e[le]|=1024,Ha(e)&&zr(e))}function Cd(e,t){for(;e>0;)t=t[Rr],e--;return t}function Uo(e){return!!(e[le]&9216||e[Ot]?.dirty)}function Ua(e){e[on].changeDetectionScheduler?.notify(8),e[le]&64&&(e[le]|=1024),Uo(e)&&zr(e)}function zr(e){e[on].changeDetectionScheduler?.notify(0);let t=rr(e);for(;t!==null&&!(t[le]&8192||(t[le]|=8192,!Ha(t)));)t=rr(t)}function Wo(e,t){if(Tn(e))throw new ie(911,!1);e[Bn]===null&&(e[Bn]=[]),e[Bn].push(t)}function Wa(e,t){if(e[Bn]===null)return;let n=e[Bn].indexOf(t);n!==-1&&e[Bn].splice(n,1)}function rr(e){let t=e[qe];return Dt(t)?t[qe]:t}function Dd(e){return e[$i]??=[]}function Sd(e){return e.cleanup??=[]}function s_(e,t,n,r){let i=Dd(t);i.push(n),e.firstCreatePass&&Sd(e).push(r,i.length-1)}var he={lFrame:y_(null),bindingsEnabled:!0,skipHydrationRootTNode:null},td;(function(e){e[e.Off=0]="Off",e[e.Exhaustive=1]="Exhaustive",e[e.OnlyDirtyViews=2]="OnlyDirtyViews"})(td||(td={}));var nd=!1;function a_(){return he.lFrame.elementDepthCount}function u_(){he.lFrame.elementDepthCount++}function $d(){he.lFrame.elementDepthCount--}function qa(){return he.bindingsEnabled}function Md(){return he.skipHydrationRootTNode!==null}function Nd(e){return he.skipHydrationRootTNode===e}function l_(){he.bindingsEnabled=!0}function c_(){he.bindingsEnabled=!1}function kd(){he.skipHydrationRootTNode=null}function P(){return he.lFrame.lView}function Ie(){return he.lFrame.tView}function d_(e){return he.lFrame.contextLView=e,e[Be]}function f_(e){return he.lFrame.contextLView=null,e}function ge(){let e=Ad();for(;e!==null&&e.type===64;)e=e.parent;return e}function Ad(){return he.lFrame.currentTNode}function ki(){let e=he.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}function Dn(e,t){let n=he.lFrame;n.currentTNode=e,n.isParent=t}function Rd(){return he.lFrame.isParent}function Od(){he.lFrame.isParent=!1}function Pd(){return he.lFrame.contextLView}function Ld(){return nd}function Ga(e){let t=nd;return nd=e,t}function yt(){let e=he.lFrame,t=e.bindingRootIndex;return t===-1&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}function Sn(){return he.lFrame.bindingIndex}function Fd(e){return he.lFrame.bindingIndex=e}function It(){return he.lFrame.bindingIndex++}function $n(e){let t=he.lFrame,n=t.bindingIndex;return t.bindingIndex=t.bindingIndex+e,n}function p_(){return he.lFrame.inI18n}function zd(e){he.lFrame.inI18n=e}function h_(e,t){let n=he.lFrame;n.bindingIndex=n.bindingRootIndex=e,Ka(t)}function m_(){return he.lFrame.currentDirectiveIndex}function Ka(e){he.lFrame.currentDirectiveIndex=e}function Qa(e){let t=he.lFrame.currentDirectiveIndex;return t===-1?null:e[t]}function Za(){return he.lFrame.currentQueryIndex}function qo(e){he.lFrame.currentQueryIndex=e}function Gk(e){let t=e[U];return t.type===2?t.declTNode:t.type===1?e[ct]:null}function Bd(e,t,n){if(n&4){let i=t,o=e;for(;i=i.parent,i===null&&!(n&1);)if(i=Gk(o),i===null||(o=o[Rr],i.type&10))break;if(i===null)return!1;t=i,e=o}let r=he.lFrame=g_();return r.currentTNode=t,r.lView=e,!0}function Ya(e){let t=g_(),n=e[U];he.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function g_(){let e=he.lFrame,t=e===null?null:e.child;return t===null?y_(e):t}function y_(e){let t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return e!==null&&(e.child=t),t}function v_(){let e=he.lFrame;return he.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}var jd=v_;function Ja(){let e=v_();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function __(e){return(he.lFrame.contextLView=Cd(e,he.lFrame.contextLView))[Be]}function ot(){return he.lFrame.selectedIndex}function dr(e){he.lFrame.selectedIndex=e}function sn(){let e=he.lFrame;return lr(e.tView,e.selectedIndex)}function w_(){he.lFrame.currentNamespace=bd}function b_(){he.lFrame.currentNamespace=Id}function I_(){Kk()}function Kk(){he.lFrame.currentNamespace=null}function x_(){return he.lFrame.currentNamespace}var E_=!0;function Go(){return E_}function Ai(e){E_=e}function Wv(e,t=null,n=null,r){let i=Vd(e,t,n,r);return i.resolveInjectorInitializers(),i}function Vd(e,t=null,n=null,r,i=new Set){let o=[n||Ne,Fk(e)];return r=r||(typeof e=="object"?void 0:Jt(e)),new Ei(o,t||Bo(),r||null,i)}var Ht=class e{static THROW_IF_NOT_FOUND=Sr;static NULL=new ko;static create(t,n){if(Array.isArray(t))return Wv({name:""},n,t,"");{let r=t.name??"";return Wv({name:r},t.parent,t.providers,r)}}static \u0275prov=Ae({token:e,providedIn:"any",factory:()=>mt(e_)});static __NG_ELEMENT_ID__=-1},Qk=new ne(""),Xt=class{static __NG_ELEMENT_ID__=Zk;static __NG_ENV_ID__=t=>t},Sa=class extends Xt{_lView;constructor(t){super(),this._lView=t}get destroyed(){return Tn(this._lView)}onDestroy(t){let n=this._lView;return Wo(n,t),()=>Wa(n,t)}};function Zk(){return new Sa(P())}var bn=class{_console=console;handleError(t){this._console.error("ERROR",t)}},Mn=new ne("",{providedIn:"root",factory:()=>{let e=re(Vt),t;return n=>{e.destroyed&&!t?setTimeout(()=>{throw n}):(t??=e.get(bn),t.handleError(n))}}}),T_={provide:kr,useValue:()=>void re(bn),multi:!0},_4=new ne("",{providedIn:"root",factory:()=>{let e=re(Qk).defaultView;if(!e)return;let t=re(Mn),n=o=>{t(o.reason),o.preventDefault()},r=o=>{o.error?t(o.error):t(new Error(o.message,{cause:o})),o.preventDefault()},i=()=>{e.addEventListener("unhandledrejection",n),e.addEventListener("error",r)};typeof Zone<"u"?Zone.root.run(i):i(),re(Xt).onDestroy(()=>{e.removeEventListener("error",r),e.removeEventListener("unhandledrejection",n)})}});function C_(e){return typeof e=="function"&&e[it]!==void 0}function Hd(e,t){let[n,r,i]=Lc(e,t?.equal),o=n,s=o[it];return o.set=r,o.update=i,o.asReadonly=Xa.bind(o),o}function Xa(){let e=this[it];if(e.readonlyFn===void 0){let t=()=>this();t[it]=e,e.readonlyFn=t}return e.readonlyFn}function Ud(e){return C_(e)&&typeof e.set=="function"}var In=class{},Wd=new ne("",{providedIn:"root",factory:()=>!1}),w4=new ne("",{providedIn:"root",factory:()=>!1}),qd=new ne(""),Gd=new ne("");var Mr=class{view;node;constructor(t,n){this.view=t,this.node=n}static __NG_ELEMENT_ID__=Yk};function Yk(){return new Mr(P(),ge())}var en=class e{taskId=0;pendingTasks=new Set;destroyed=!1;pendingTask=new Mo(!1);get hasPendingTasks(){return this.destroyed?!1:this.pendingTask.value}get hasPendingTasksObservable(){return this.destroyed?new _n(t=>{t.next(!1),t.complete()}):this.pendingTask}add(){!this.hasPendingTasks&&!this.destroyed&&this.pendingTask.next(!0);let t=this.taskId++;return this.pendingTasks.add(t),t}has(t){return this.pendingTasks.has(t)}remove(t){this.pendingTasks.delete(t),this.pendingTasks.size===0&&this.hasPendingTasks&&this.pendingTask.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks&&this.pendingTask.next(!1),this.destroyed=!0,this.pendingTask.unsubscribe()}static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new e})},Ao=class e{internalPendingTasks=re(en);scheduler=re(In);errorHandler=re(Mn);add(){let t=this.internalPendingTasks.add();return()=>{this.internalPendingTasks.has(t)&&(this.scheduler.notify(11),this.internalPendingTasks.remove(t))}}run(t){let n=this.add();t().catch(this.errorHandler).finally(n)}static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new e})};function Ri(...e){}var Ro=class e{static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new rd})},rd=class{dirtyEffectCount=0;queues=new Map;add(t){this.enqueue(t),this.schedule(t)}schedule(t){t.dirty&&this.dirtyEffectCount++}remove(t){let n=t.zone,r=this.queues.get(n);r.has(t)&&(r.delete(t),t.dirty&&this.dirtyEffectCount--)}enqueue(t){let n=t.zone;this.queues.has(n)||this.queues.set(n,new Set);let r=this.queues.get(n);r.has(t)||r.add(t)}flush(){for(;this.dirtyEffectCount>0;){let t=!1;for(let[n,r]of this.queues)n===null?t||=this.flushQueue(r):t||=n.run(()=>this.flushQueue(r));t||(this.dirtyEffectCount=0)}}flushQueue(t){let n=!1;for(let r of t)r.dirty&&(this.dirtyEffectCount--,n=!0,r.run());return n}};function gr(e){return{toString:e}.toString()}var Li="__annotations__",Fi="__parameters__",zi="__prop__metadata__";function _s(e,t,n,r,i){return gr(()=>{let o=_p(t);function s(...a){if(this instanceof s)return o.call(this,...a),this;let u=new s(...a);return function(d){return i&&i(d,...a),(d.hasOwnProperty(Li)?d[Li]:Object.defineProperty(d,Li,{value:[]})[Li]).push(u),d}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=e,s.annotationCls=s,s})}function _p(e){return function(...n){if(e){let r=e(...n);for(let i in r)this[i]=r[i]}}}function io(e,t,n){return gr(()=>{let r=_p(t);function i(...o){if(this instanceof i)return r.apply(this,o),this;let s=new i(...o);return a.annotation=s,a;function a(u,c,d){let p=u.hasOwnProperty(Fi)?u[Fi]:Object.defineProperty(u,Fi,{value:[]})[Fi];for(;p.length<=d;)p.push(null);return(p[d]=p[d]||[]).push(s),u}}return i.prototype.ngMetadataName=e,i.annotationCls=i,i})}function qn(e,t,n,r){return gr(()=>{let i=_p(t);function o(...s){if(this instanceof o)return i.apply(this,s),this;let a=new o(...s);function u(c,d){if(c===void 0)throw new Error("Standard Angular field decorators are not supported in JIT mode.");let p=c.constructor,h=p.hasOwnProperty(zi)?p[zi]:Object.defineProperty(p,zi,{value:{}})[zi];h[d]=h.hasOwnProperty(d)&&h[d]||[],h[d].unshift(a)}return u}return n&&(o.prototype=Object.create(n.prototype)),o.prototype.ngMetadataName=e,o.annotationCls=o,o})}var Xk=Di(io("Inject",e=>({token:e})),-1),eA=Di(io("Optional"),8),tA=Di(io("Self"),2),nA=Di(io("SkipSelf"),4),rA=Di(io("Host"),1);function Pt(e){let t=Ut.ng;if(t&&t.\u0275compilerFacade)return t.\u0275compilerFacade;throw new Error("JIT compiler unavailable")}var D_={\u0275\u0275defineInjectable:Ae,\u0275\u0275defineInjector:Na,\u0275\u0275inject:mt,\u0275\u0275invalidFactoryDep:ld,resolveForwardRef:Se},iA=Function;function Ko(e){return typeof e=="function"}var oA=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/,sA=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,aA=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,uA=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;function lA(e){return oA.test(e)||uA.test(e)||sA.test(e)&&!aA.test(e)}var mf=class{_reflect;constructor(t){this._reflect=t||Ut.Reflect}factory(t){return(...n)=>new t(...n)}_zipTypesAndAnnotations(t,n){let r;typeof t>"u"?r=Fo(n.length):r=Fo(t.length);for(let i=0;i<r.length;i++)typeof t>"u"?r[i]=[]:t[i]&&t[i]!=Object?r[i]=[t[i]]:r[i]=[],n&&n[i]!=null&&(r[i]=r[i].concat(n[i]));return r}_ownParameters(t,n){let r=t.toString();if(lA(r))return null;if(t.parameters&&t.parameters!==n.parameters)return t.parameters;let i=t.ctorParameters;if(i&&i!==n.ctorParameters){let a=typeof i=="function"?i():i,u=a.map(d=>d&&d.type),c=a.map(d=>d&&Kd(d.decorators));return this._zipTypesAndAnnotations(u,c)}let o=t.hasOwnProperty(Fi)&&t[Fi],s=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata("design:paramtypes",t);return s||o?this._zipTypesAndAnnotations(s,o):Fo(t.length)}parameters(t){if(!Ko(t))return[];let n=eu(t),r=this._ownParameters(t,n);return!r&&n!==Object&&(r=this.parameters(n)),r||[]}_ownAnnotations(t,n){if(t.annotations&&t.annotations!==n.annotations){let r=t.annotations;return typeof r=="function"&&r.annotations&&(r=r.annotations),r}return t.decorators&&t.decorators!==n.decorators?Kd(t.decorators):t.hasOwnProperty(Li)?t[Li]:null}annotations(t){if(!Ko(t))return[];let n=eu(t),r=this._ownAnnotations(t,n)||[];return(n!==Object?this.annotations(n):[]).concat(r)}_ownPropMetadata(t,n){if(t.propMetadata&&t.propMetadata!==n.propMetadata){let r=t.propMetadata;return typeof r=="function"&&r.propMetadata&&(r=r.propMetadata),r}if(t.propDecorators&&t.propDecorators!==n.propDecorators){let r=t.propDecorators,i={};return Object.keys(r).forEach(o=>{i[o]=Kd(r[o])}),i}return t.hasOwnProperty(zi)?t[zi]:null}propMetadata(t){if(!Ko(t))return{};let n=eu(t),r={};if(n!==Object){let o=this.propMetadata(n);Object.keys(o).forEach(s=>{r[s]=o[s]})}let i=this._ownPropMetadata(t,n);return i&&Object.keys(i).forEach(o=>{let s=[];r.hasOwnProperty(o)&&s.push(...r[o]),s.push(...i[o]),r[o]=s}),r}ownPropMetadata(t){return Ko(t)?this._ownPropMetadata(t,eu(t))||{}:{}}hasLifecycleHook(t,n){return t instanceof iA&&n in t.prototype}};function Kd(e){return e?e.map(t=>{let r=t.type.annotationCls,i=t.args?t.args:[];return new r(...i)}):[]}function eu(e){let t=e.prototype?Object.getPrototypeOf(e.prototype):null;return(t?t.constructor:null)||Object}var gf=class{previousValue;currentValue;firstChange;constructor(t,n,r){this.previousValue=t,this.currentValue=n,this.firstChange=r}isFirstChange(){return this.firstChange}};function Hw(e,t,n,r){t!==null?t.applyValueToInputSignal(t,r):e[n]=r}var cA=(()=>{let e=()=>Uw;return e.ngInherit=!0,e})();function Uw(e){return e.type.prototype.ngOnChanges&&(e.setInput=fA),dA}function dA(){let e=qw(this),t=e?.current;if(t){let n=e.previous;if(n===Wt)e.previous=t;else for(let r in t)n[r]=t[r];e.current=null,this.ngOnChanges(t)}}function fA(e,t,n,r,i){let o=this.declaredInputs[r],s=qw(e)||pA(e,{previous:Wt,current:null}),a=s.current||(s.current={}),u=s.previous,c=u[o];a[o]=new gf(c&&c.currentValue,n,u===Wt),Hw(e,t,i,n)}var Ww="__ngSimpleChanges__";function qw(e){return e[Ww]||null}function pA(e,t){return e[Ww]=t}var S_=[];var Oe=function(e,t=null,n){for(let r=0;r<S_.length;r++){let i=S_[r];i(e,t,n)}};function hA(e,t,n){let{ngOnChanges:r,ngOnInit:i,ngDoCheck:o}=t.type.prototype;if(r){let s=Uw(t);(n.preOrderHooks??=[]).push(e,s),(n.preOrderCheckHooks??=[]).push(e,s)}i&&(n.preOrderHooks??=[]).push(0-e,i),o&&((n.preOrderHooks??=[]).push(e,o),(n.preOrderCheckHooks??=[]).push(e,o))}function Gw(e,t){for(let n=t.directiveStart,r=t.directiveEnd;n<r;n++){let o=e.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:a,ngAfterViewInit:u,ngAfterViewChecked:c,ngOnDestroy:d}=o;s&&(e.contentHooks??=[]).push(-n,s),a&&((e.contentHooks??=[]).push(n,a),(e.contentCheckHooks??=[]).push(n,a)),u&&(e.viewHooks??=[]).push(-n,u),c&&((e.viewHooks??=[]).push(n,c),(e.viewCheckHooks??=[]).push(n,c)),d!=null&&(e.destroyHooks??=[]).push(n,d)}}function lu(e,t,n){Kw(e,t,3,n)}function cu(e,t,n,r){(e[le]&3)===n&&Kw(e,t,n,r)}function Qd(e,t){let n=e[le];(n&3)===t&&(n&=16383,n+=1,e[le]=n)}function Kw(e,t,n,r){let i=r!==void 0?e[Or]&65535:0,o=r??-1,s=t.length-1,a=0;for(let u=i;u<s;u++)if(typeof t[u+1]=="number"){if(a=t[u],r!=null&&a>=r)break}else t[u]<0&&(e[Or]+=65536),(a<o||o==-1)&&(mA(e,n,t,u),e[Or]=(e[Or]&4294901760)+u+2),u++}function $_(e,t){Oe(4,e,t);let n=ae(null);try{t.call(e)}finally{ae(n),Oe(5,e,t)}}function mA(e,t,n,r){let i=n[r]<0,o=n[r+1],s=i?-n[r]:n[r],a=e[s];i?e[le]>>14<e[Or]>>16&&(e[le]&3)===t&&(e[le]+=16384,$_(a,o)):$_(a,o)}var Hi=-1,Vr=class{factory;name;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(t,n,r,i){this.factory=t,this.name=i,this.canSeeViewProviders=n,this.injectImpl=r}};function Qw(e){return e!=null&&typeof e=="object"&&(e.insertBeforeIndex===null||typeof e.insertBeforeIndex=="number"||Array.isArray(e.insertBeforeIndex))}function gA(e){return(e.flags&8)!==0}function yA(e){return(e.flags&16)!==0}function vA(e,t,n){let r=0;for(;r<n.length;){let i=n[r];if(typeof i=="number"){if(i!==0)break;r++;let o=n[r++],s=n[r++],a=n[r++];e.setAttribute(t,s,a,o)}else{let o=i,s=n[++r];_A(o)?e.setProperty(t,o,s):e.setAttribute(t,o,s),r++}}return r}function Zw(e){return e===3||e===4||e===6}function _A(e){return e.charCodeAt(0)===64}function Qi(e,t){if(!(t===null||t.length===0))if(e===null||e.length===0)e=t.slice();else{let n=-1;for(let r=0;r<t.length;r++){let i=t[r];typeof i=="number"?n=i:n===0||(n===-1||n===2?M_(e,n,i,null,t[++r]):M_(e,n,i,null,null))}}return e}function M_(e,t,n,r,i){let o=0,s=e.length;if(t===-1)s=-1;else for(;o<e.length;){let a=e[o++];if(typeof a=="number"){if(a===t){s=-1;break}else if(a>t){s=o-1;break}}}for(;o<e.length;){let a=e[o];if(typeof a=="number")break;if(a===n){i!==null&&(e[o+1]=i);return}o++,i!==null&&o++}s!==-1&&(e.splice(s,0,t),o=s+1),e.splice(o++,0,n),i!==null&&e.splice(o++,0,i)}function Yw(e){return e!==Hi}function wu(e){return e&32767}function wA(e){return e>>16}function bu(e,t){let n=wA(e),r=t;for(;n>0;)r=r[Rr],n--;return r}var yf=!0;function Iu(e){let t=yf;return yf=e,t}var bA=256,Jw=bA-1,Xw=5,IA=0,kn={};function xA(e,t,n){let r;typeof n=="string"?r=n.charCodeAt(0)||0:n.hasOwnProperty(Ci)&&(r=n[Ci]),r==null&&(r=n[Ci]=IA++);let i=r&Jw,o=1<<i;t.data[e+(i>>Xw)]|=o}function xu(e,t){let n=eb(e,t);if(n!==-1)return n;let r=t[U];r.firstCreatePass&&(e.injectorIndex=t.length,Zd(r.data,e),Zd(t,null),Zd(r.blueprint,null));let i=wp(e,t),o=e.injectorIndex;if(Yw(i)){let s=wu(i),a=bu(i,t),u=a[U].data;for(let c=0;c<8;c++)t[o+c]=a[s+c]|u[s+c]}return t[o+8]=i,o}function Zd(e,t){e.push(0,0,0,0,0,0,0,0,t)}function eb(e,t){return e.injectorIndex===-1||e.parent&&e.parent.injectorIndex===e.injectorIndex||t[e.injectorIndex+8]===null?-1:e.injectorIndex}function wp(e,t){if(e.parent&&e.parent.injectorIndex!==-1)return e.parent.injectorIndex;let n=0,r=null,i=t;for(;i!==null;){if(r=ob(i),r===null)return Hi;if(n++,i=i[Rr],r.injectorIndex!==-1)return r.injectorIndex|n<<16}return Hi}function vf(e,t,n){xA(e,t,n)}function EA(e,t){if(t==="class")return e.classes;if(t==="style")return e.styles;let n=e.attrs;if(n){let r=n.length,i=0;for(;i<r;){let o=n[i];if(Zw(o))break;if(o===0)i=i+2;else if(typeof o=="number")for(i++;i<r&&typeof n[i]=="string";)i++;else{if(o===t)return n[i+1];i=i+2}}}return null}function tb(e,t,n){if(n&8||e!==void 0)return e;Ra(t,"NodeInjector")}function nb(e,t,n,r){if(n&8&&r===void 0&&(r=null),(n&3)===0){let i=e[Re],o=wt(void 0);try{return i?i.get(t,r,n&8):ud(t,r,n&8)}finally{wt(o)}}return tb(r,t,n)}function rb(e,t,n,r=0,i){if(e!==null){if(t[le]&2048&&!(r&2)){let s=$A(e,t,n,r,kn);if(s!==kn)return s}let o=ib(e,t,n,r,kn);if(o!==kn)return o}return nb(t,n,r,i)}function ib(e,t,n,r,i){let o=CA(n);if(typeof o=="function"){if(!Bd(t,e,r))return r&1?tb(i,n,r):nb(t,n,r,i);try{let s;if(s=o(r),s==null&&!(r&8))Ra(n);else return s}finally{jd()}}else if(typeof o=="number"){let s=null,a=eb(e,t),u=Hi,c=r&1?t[gt][ct]:null;for((a===-1||r&4)&&(u=a===-1?wp(e,t):t[a+8],u===Hi||!k_(r,!1)?a=-1:(s=t[U],a=wu(u),t=bu(u,t)));a!==-1;){let d=t[U];if(N_(o,a,d.data)){let p=TA(a,t,n,s,r,c);if(p!==kn)return p}u=t[a+8],u!==Hi&&k_(r,t[U].data[a+8]===c)&&N_(o,a,t)?(s=d,a=wu(u),t=bu(u,t)):a=-1}}return i}function TA(e,t,n,r,i,o){let s=t[U],a=s.data[e+8],u=r==null?ar(a)&&yf:r!=s&&(a.type&3)!==0,c=i&1&&o===a,d=du(a,s,n,u,c);return d!==null?is(t,s,d,a,i):kn}function du(e,t,n,r,i){let o=e.providerIndexes,s=t.data,a=o&1048575,u=e.directiveStart,c=e.directiveEnd,d=o>>20,p=r?a:a+d,h=i?a+d:c;for(let g=p;g<h;g++){let y=s[g];if(g<u&&n===y||g>=u&&y.type===n)return g}if(i){let g=s[u];if(g&&St(g)&&g.type===n)return u}return null}function is(e,t,n,r,i){let o=e[n],s=t.data;if(o instanceof Vr){let a=o;if(a.resolving){let g=tn(s[n]);throw ad(g)}let u=Iu(a.canSeeViewProviders);a.resolving=!0;let c=s[n].type||s[n],d,p=a.injectImpl?wt(a.injectImpl):null,h=Bd(e,r,0);try{o=e[n]=a.factory(void 0,i,s,e,r),t.firstCreatePass&&n>=r.directiveStart&&hA(n,s[n],t)}finally{p!==null&&wt(p),Iu(u),a.resolving=!1,jd()}}return o}function CA(e){if(typeof e=="string")return e.charCodeAt(0)||0;let t=e.hasOwnProperty(Ci)?e[Ci]:void 0;return typeof t=="number"?t>=0?t&Jw:DA:t}function N_(e,t,n){let r=1<<e;return!!(n[t+(e>>Xw)]&r)}function k_(e,t){return!(e&2)&&!(e&1&&t)}var Br=class{_tNode;_lView;constructor(t,n){this._tNode=t,this._lView=n}get(t,n,r){return rb(this._tNode,this._lView,t,xi(r),n)}};function DA(){return new Br(ge(),P())}function SA(e){return gr(()=>{let t=e.prototype.constructor,n=t[wn]||_f(t),r=Object.prototype,i=Object.getPrototypeOf(e.prototype).constructor;for(;i&&i!==r;){let o=i[wn]||_f(i);if(o&&o!==n)return o;i=Object.getPrototypeOf(i)}return o=>new o})}function _f(e){return Oo(e)?()=>{let t=_f(Se(e));return t&&t()}:nr(e)}function $A(e,t,n,r,i){let o=e,s=t;for(;o!==null&&s!==null&&s[le]&2048&&!ur(s);){let a=ib(o,s,n,r|2,kn);if(a!==kn)return a;let u=o.parent;if(!u){let c=s[vd];if(c){let d=c.get(n,kn,r);if(d!==kn)return d}u=ob(s),s=s[Rr]}o=u}return i}function ob(e){let t=e[U],n=t.type;return n===2?t.declTNode:n===1?e[ct]:null}function bp(e){return EA(ge(),e)}var MA=io("Attribute",e=>({attributeName:e,__NG_ELEMENT_ID__:()=>bp(e)})),A_=null;function Ip(){return A_=A_||new mf}function Zu(e){return sb(Ip().parameters(e))}function sb(e){return e.map(t=>NA(t))}function NA(e){let t={token:null,attribute:null,host:!1,optional:!1,self:!1,skipSelf:!1};if(Array.isArray(e)&&e.length>0)for(let n=0;n<e.length;n++){let r=e[n];if(r===void 0)continue;let i=Object.getPrototypeOf(r);if(r instanceof eA||i.ngMetadataName==="Optional")t.optional=!0;else if(r instanceof nA||i.ngMetadataName==="SkipSelf")t.skipSelf=!0;else if(r instanceof tA||i.ngMetadataName==="Self")t.self=!0;else if(r instanceof rA||i.ngMetadataName==="Host")t.host=!0;else if(r instanceof Xk)t.token=r.token;else if(r instanceof MA){if(r.attributeName===void 0)throw new ie(204,!1);t.attribute=r.attributeName}else t.token=r}else e===void 0||Array.isArray(e)&&e.length===0?t.token=null:t.token=e;return t}function kA(e,t){let n=null,r=null;e.hasOwnProperty(Po)||Object.defineProperty(e,Po,{get:()=>(n===null&&(n=Pt({usage:0,kind:"injectable",type:e}).compileInjectable(D_,`ng:///${e.name}/\u0275prov.js`,PA(e,t))),n)}),e.hasOwnProperty(wn)||Object.defineProperty(e,wn,{get:()=>{if(r===null){let i=Pt({usage:0,kind:"injectable",type:e});r=i.compileFactory(D_,`ng:///${e.name}/\u0275fac.js`,{name:e.name,type:e,typeArgumentCount:0,deps:Zu(e),target:i.FactoryTarget.Injectable})}return r},configurable:!0})}var AA=Me({provide:String,useValue:Me});function R_(e){return e.useClass!==void 0}function RA(e){return AA in e}function O_(e){return e.useFactory!==void 0}function OA(e){return e.useExisting!==void 0}function PA(e,t){let n=t||{providedIn:null},r={name:e.name,type:e,typeArgumentCount:0,providedIn:n.providedIn};return(R_(n)||O_(n))&&n.deps!==void 0&&(r.deps=sb(n.deps)),R_(n)?r.useClass=n.useClass:RA(n)?r.useValue=n.useValue:O_(n)?r.useFactory=n.useFactory:OA(n)&&(r.useExisting=n.useExisting),r}var LA=_s("Injectable",void 0,void 0,void 0,(e,t)=>kA(e,t));function FA(){return oo(ge(),P())}function oo(e,t){return new Zi(dt(e,t))}var Zi=class{nativeElement;constructor(t){this.nativeElement=t}static __NG_ELEMENT_ID__=FA};function ab(e){return e instanceof Zi?e.nativeElement:e}function zA(){return this._results[Symbol.iterator]()}var wf=class{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new Yt}constructor(t=!1){this._emitDistinctChangesOnly=t}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,n){return this._results.reduce(t,n)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,n){this.dirty=!1;let r=nn(t);(this._changesDetected=!Xv(this._results,r,n))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.next(this)}onDirty(t){this._onDirty=t}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=zA};function ub(e){return(e.flags&128)===128}var Eu;(function(e){e[e.OnPush=0]="OnPush",e[e.Default=1]="Default"})(Eu||(Eu={}));var xp=new Map,BA=0;function jA(){return BA++}function VA(e){xp.set(e[Vo],e)}function bf(e){xp.delete(e[Vo])}function HA(){return xp}var P_="__ngContext__";function mr(e,t){bt(t)?(e[P_]=t[Vo],VA(t)):e[P_]=t}function lb(e){return db(e[or])}function cb(e){return db(e[lt])}function db(e){for(;e!==null&&!Dt(e);)e=e[lt];return e}var L_;(function(e){e.Angular="angular",e.ACX="acx",e.Wiz="wiz"})(L_||(L_={}));var F_;(function(e){e[e.Default=0]="Default",e[e.OnPush=1]="OnPush"})(F_||(F_={}));var z_;(function(e){e[e.Emulated=0]="Emulated",e[e.None=1]="None"})(z_||(z_={}));var B_;function Qr(){if(B_!==void 0)return B_;if(typeof document<"u")return document;throw new ie(210,!1)}var fb=new ne("",{providedIn:"root",factory:()=>UA}),UA="ng",pb=new ne(""),$U=new ne("",{providedIn:"platform",factory:()=>"unknown"}),MU=new ne(""),NU=new ne(""),kU=new ne("",{providedIn:"root",factory:()=>Qr().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null}),WA={breakpoints:[16,32,48,64,96,128,256,384,640,750,828,1080,1200,1920,2048,3840],placeholderResolution:30,disableImageSizeWarning:!1,disableImageLazyLoadWarning:!1},hb=new ne("",{providedIn:"root",factory:()=>WA});function qA(){let e=new os;return e.store=GA(Qr(),re(fb)),e}var os=class e{static \u0275prov=Ae({token:e,providedIn:"root",factory:qA});store={};onSerializeCallbacks={};get(t,n){return this.store[t]!==void 0?this.store[t]:n}set(t,n){this.store[t]=n}remove(t){delete this.store[t]}hasKey(t){return this.store.hasOwnProperty(t)}get isEmpty(){return Object.keys(this.store).length===0}onSerialize(t,n){this.onSerializeCallbacks[t]=n}toJson(){for(let t in this.onSerializeCallbacks)if(this.onSerializeCallbacks.hasOwnProperty(t))try{this.store[t]=this.onSerializeCallbacks[t]()}catch(n){console.warn("Exception in onSerialize callback: ",n)}return JSON.stringify(this.store).replace(/</g,"\\u003C")}};function GA(e,t){let n=e.getElementById(t+"-state");if(n?.textContent)try{return JSON.parse(n.textContent)}catch(r){console.warn("Exception while restoring TransferState for app "+t,r)}return{}}var KA="h",QA="b";var mb="r";var Ep="di",Tp="s",gb="p";var ZA=new ne(""),yb=!1,vb=new ne("",{providedIn:"root",factory:()=>yb}),YA=new ne(""),JA=new ne("");var _b=new ne(""),XA=new ne("",{providedIn:"root",factory:()=>new Map}),AU=new ne("");var Tu={passive:!0,capture:!0},Yd=new WeakMap,Jd=new WeakMap,Bi=new WeakMap,j_=["click","keydown"],V_=["mouseenter","mouseover","focusin"],Oi=null,Xd=0,ss=class{callbacks=new Set;listener=()=>{for(let t of this.callbacks)t()}};function wb(e,t){let n=Jd.get(e);if(!n){n=new ss,Jd.set(e,n);for(let r of j_)e.addEventListener(r,n.listener,Tu)}return n.callbacks.add(t),()=>{let{callbacks:r,listener:i}=n;if(r.delete(t),r.size===0){Jd.delete(e);for(let o of j_)e.removeEventListener(o,i,Tu)}}}function bb(e,t){let n=Yd.get(e);if(!n){n=new ss,Yd.set(e,n);for(let r of V_)e.addEventListener(r,n.listener,Tu)}return n.callbacks.add(t),()=>{let{callbacks:r,listener:i}=n;if(r.delete(t),r.size===0){for(let o of V_)e.removeEventListener(o,i,Tu);Yd.delete(e)}}}function eR(){return new IntersectionObserver(e=>{for(let t of e)t.isIntersecting&&Bi.has(t.target)&&Bi.get(t.target).listener()})}function tR(e,t,n){let r=Bi.get(e);return Oi=Oi||n(),r||(r=new ss,Oi.observe(e),Bi.set(e,r),Xd++),r.callbacks.add(t),()=>{Bi.has(e)&&(r.callbacks.delete(t),r.callbacks.size===0&&(Oi?.unobserve(e),Bi.delete(e),Xd--),Xd===0&&(Oi?.disconnect(),Oi=null))}}var nR=new ne("",{providedIn:"root",factory:()=>({})});var rR=(e,t,n,r)=>{};function iR(e,t,n,r){rR(e,t,n,r)}var ws=new ne("");function Yu(e){return(e.flags&32)===32}var oR="__nghData__",sR=oR,aR="__nghDeferData__",Ib=aR;var uR=()=>null;function xb(e,t,n=!1){return uR(e,t,n)}function Eb(e){let t=e._lView;return t[U].type===2?null:(ur(t)&&(t=t[me]),t)}var H_;(function(e){e.Hydrated="hydrated",e.Skipped="skipped",e.Mismatched="mismatched"})(H_||(H_={}));function Tb(e){return e.get(_b,!1,{optional:!0})}function lR(e,t){let n=t.get(ws),i=t.get(os).get(Ib,{}),o=!1,s=e,a=null,u=[];for(;!o&&s;){o=n.has(s);let c=n.hydrating.get(s);if(a===null&&c!=null){a=c.promise;break}u.unshift(s),s=i[s][gb]}return{parentBlockPromise:a,hydrationQueue:u}}function Cb(e,t){let n=e.contentQueries;if(n!==null){let r=ae(null);try{for(let i=0;i<n.length;i+=2){let o=n[i],s=n[i+1];if(s!==-1){let a=e.data[s];qo(o),a.contentQueries(2,t[s],s)}}}finally{ae(r)}}}function If(e,t,n){qo(0);let r=ae(null);try{t(e,n)}finally{ae(r)}}function Cp(e,t,n){if(wd(t)){let r=ae(null);try{let i=t.directiveStart,o=t.directiveEnd;for(let s=i;s<o;s++){let a=e.data[s];if(a.contentQueries){let u=n[s];a.contentQueries(1,u,s)}}}finally{ae(r)}}}var Un;(function(e){e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom"})(Un||(Un={}));var tu;function Db(){if(tu===void 0&&(tu=null,Ut.trustedTypes))try{tu=Ut.trustedTypes.createPolicy("angular",{createHTML:e=>e,createScript:e=>e,createScriptURL:e=>e})}catch{}return tu}function so(e){return Db()?.createHTML(e)||e}function cR(e){return Db()?.createScriptURL(e)||e}var nu;function Dp(){if(nu===void 0&&(nu=null,Ut.trustedTypes))try{nu=Ut.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:e=>e,createScript:e=>e,createScriptURL:e=>e})}catch{}return nu}function U_(e){return Dp()?.createHTML(e)||e}function W_(e){return Dp()?.createScript(e)||e}function q_(e){return Dp()?.createScriptURL(e)||e}var Cu=class{changingThisBreaksApplicationSecurity;constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${id})`}};function yr(e){return e instanceof Cu?e.changingThisBreaksApplicationSecurity:e}function bs(e,t){let n=dR(e);if(n!=null&&n!==t){if(n==="ResourceURL"&&t==="URL")return!0;throw new Error(`Required a safe ${t}, got a ${n} (see ${id})`)}return n===t}function dR(e){return e instanceof Cu&&e.getTypeName()||null}function Sb(e){let t=new Ef(e);return fR()?new xf(t):t}var xf=class{inertDocumentHelper;constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{let n=new window.DOMParser().parseFromString(so(t),"text/html").body;return n===null?this.inertDocumentHelper.getInertBodyElement(t):(n.firstChild?.remove(),n)}catch{return null}}},Ef=class{defaultDoc;inertDocument;constructor(t){this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert")}getInertBodyElement(t){let n=this.inertDocument.createElement("template");return n.innerHTML=so(t),n}};function fR(){try{return!!new window.DOMParser().parseFromString(so(""),"text/html")}catch{return!1}}var pR=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function Sp(e){return e=String(e),e.match(pR)?e:"unsafe:"+e}function Gn(e){let t={};for(let n of e.split(","))t[n]=!0;return t}function Is(...e){let t={};for(let n of e)for(let r in n)n.hasOwnProperty(r)&&(t[r]=!0);return t}var $b=Gn("area,br,col,hr,img,wbr"),Mb=Gn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),Nb=Gn("rp,rt"),hR=Is(Nb,Mb),mR=Is(Mb,Gn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),gR=Is(Nb,Gn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Tf=Is($b,mR,gR,hR),$p=Gn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),yR=Gn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),vR=Gn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"),kb=Is($p,yR,vR),_R=Gn("script,style,template"),Cf=class{sanitizedSomething=!1;buf=[];sanitizeChildren(t){let n=t.firstChild,r=!0,i=[];for(;n;){if(n.nodeType===Node.ELEMENT_NODE?r=this.startElement(n):n.nodeType===Node.TEXT_NODE?this.chars(n.nodeValue):this.sanitizedSomething=!0,r&&n.firstChild){i.push(n),n=IR(n);continue}for(;n;){n.nodeType===Node.ELEMENT_NODE&&this.endElement(n);let o=bR(n);if(o){n=o;break}n=i.pop()}}return this.buf.join("")}startElement(t){let n=G_(t).toLowerCase();if(!Tf.hasOwnProperty(n))return this.sanitizedSomething=!0,!_R.hasOwnProperty(n);this.buf.push("<"),this.buf.push(n);let r=t.attributes;for(let i=0;i<r.length;i++){let o=r.item(i),s=o.name,a=s.toLowerCase();if(!kb.hasOwnProperty(a)){this.sanitizedSomething=!0;continue}let u=o.value;$p[a]&&(u=Sp(u)),this.buf.push(" ",s,'="',K_(u),'"')}return this.buf.push(">"),!0}endElement(t){let n=G_(t).toLowerCase();Tf.hasOwnProperty(n)&&!$b.hasOwnProperty(n)&&(this.buf.push("</"),this.buf.push(n),this.buf.push(">"))}chars(t){this.buf.push(K_(t))}};function wR(e,t){return(e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_CONTAINED_BY)!==Node.DOCUMENT_POSITION_CONTAINED_BY}function bR(e){let t=e.nextSibling;if(t&&e!==t.previousSibling)throw Ab(t);return t}function IR(e){let t=e.firstChild;if(t&&wR(e,t))throw Ab(t);return t}function G_(e){let t=e.nodeName;return typeof t=="string"?t:"FORM"}function Ab(e){return new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`)}var xR=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,ER=/([^\#-~ |!])/g;function K_(e){return e.replace(/&/g,"&amp;").replace(xR,function(t){let n=t.charCodeAt(0),r=t.charCodeAt(1);return"&#"+((n-55296)*1024+(r-56320)+65536)+";"}).replace(ER,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}var ru;function TR(e,t){let n=null;try{ru=ru||Sb(e);let r=t?String(t):"";n=ru.getInertBodyElement(r);let i=5,o=r;do{if(i===0)throw new Error("Failed to sanitize html because the input is unstable");i--,r=o,o=n.innerHTML,n=ru.getInertBodyElement(r)}while(r!==o);let a=new Cf().sanitizeChildren(Df(n)||n);return so(a)}finally{if(n){let r=Df(n)||n;for(;r.firstChild;)r.firstChild.remove()}}}function Df(e){return"content"in e&&CR(e)?e.content:null}function CR(e){return e.nodeType===Node.ELEMENT_NODE&&e.nodeName==="TEMPLATE"}var Hr;(function(e){e[e.NONE=0]="NONE",e[e.HTML=1]="HTML",e[e.STYLE=2]="STYLE",e[e.SCRIPT=3]="SCRIPT",e[e.URL=4]="URL",e[e.RESOURCE_URL=5]="RESOURCE_URL"})(Hr||(Hr={}));function DR(e){let t=xs();return t?U_(t.sanitize(Hr.HTML,e)||""):bs(e,"HTML")?U_(yr(e)):TR(Qr(),ve(e))}function SR(e){let t=xs();return t?t.sanitize(Hr.STYLE,e)||"":bs(e,"Style")?yr(e):ve(e)}function Rb(e){let t=xs();return t?t.sanitize(Hr.URL,e)||"":bs(e,"URL")?yr(e):Sp(ve(e))}function Ob(e){let t=xs();if(t)return q_(t.sanitize(Hr.RESOURCE_URL,e)||"");if(bs(e,"ResourceURL"))return q_(yr(e));throw new ie(904,!1)}function $R(e){let t=xs();if(t)return W_(t.sanitize(Hr.SCRIPT,e)||"");if(bs(e,"Script"))return W_(yr(e));throw new ie(905,!1)}function MR(e){return so(e[0])}function NR(e){return cR(e[0])}function kR(e,t){return t==="src"&&(e==="embed"||e==="frame"||e==="iframe"||e==="media"||e==="script")||t==="href"&&(e==="base"||e==="link")?Ob:Rb}function AR(e,t,n){return kR(t,n)(e)}function xs(){let e=P();return e&&e[on].sanitizer}var RR=/^>|^->|<!--|-->|--!>|<!-$/g,OR=/(<|>)/g,PR="\u200B$1\u200B";function LR(e){return e.replace(RR,t=>t.replace(OR,PR))}var FR=!1,RU=new ne("",{providedIn:"root",factory:()=>FR});function zR(e){return e.ownerDocument.defaultView}function BR(e){return e.ownerDocument}function jR(e){return e.ownerDocument.body}function ji(e){return e instanceof Function?e():e}function VR(e,t,n){let r=e.length;for(;;){let i=e.indexOf(t,n);if(i===-1)return i;if(i===0||e.charCodeAt(i-1)<=32){let o=t.length;if(i+o===r||e.charCodeAt(i+o)<=32)return i}n=i+1}}var Pb="ng-template";function HR(e,t,n,r){let i=0;if(r){for(;i<t.length&&typeof t[i]=="string";i+=2)if(t[i]==="class"&&VR(t[i+1].toLowerCase(),n,0)!==-1)return!0}else if(Mp(e))return!1;if(i=t.indexOf(1,i),i>-1){let o;for(;++i<t.length&&typeof(o=t[i])=="string";)if(o.toLowerCase()===n)return!0}return!1}function Mp(e){return e.type===4&&e.value!==Pb}function UR(e,t,n){let r=e.type===4&&!n?Pb:e.value;return t===r}function WR(e,t,n){let r=4,i=e.attrs,o=i!==null?KR(i):0,s=!1;for(let a=0;a<t.length;a++){let u=t[a];if(typeof u=="number"){if(!s&&!an(r)&&!an(u))return!1;if(s&&an(u))continue;s=!1,r=u|r&1;continue}if(!s)if(r&4){if(r=2|r&1,u!==""&&!UR(e,u,n)||u===""&&t.length===1){if(an(r))return!1;s=!0}}else if(r&8){if(i===null||!HR(e,i,u,n)){if(an(r))return!1;s=!0}}else{let c=t[++a],d=qR(u,i,Mp(e),n);if(d===-1){if(an(r))return!1;s=!0;continue}if(c!==""){let p;if(d>o?p="":p=i[d+1].toLowerCase(),r&2&&c!==p){if(an(r))return!1;s=!0}}}}return an(r)||s}function an(e){return(e&1)===0}function qR(e,t,n,r){if(t===null)return-1;let i=0;if(r||!n){let o=!1;for(;i<t.length;){let s=t[i];if(s===e)return i;if(s===3||s===6)o=!0;else if(s===1||s===2){let a=t[++i];for(;typeof a=="string";)a=t[++i];continue}else{if(s===4)break;if(s===0){i+=4;continue}}i+=o?1:2}return-1}else return QR(t,e)}function Lb(e,t,n=!1){for(let r=0;r<t.length;r++)if(WR(e,t[r],n))return!0;return!1}function GR(e){let t=e.attrs;if(t!=null){let n=t.indexOf(5);if((n&1)===0)return t[n+1]}return null}function KR(e){for(let t=0;t<e.length;t++){let n=e[t];if(Zw(n))return t}return e.length}function QR(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){let r=e[n];if(typeof r=="number")return-1;if(r===t)return n;n++}return-1}function ZR(e,t){e:for(let n=0;n<t.length;n++){let r=t[n];if(e.length===r.length){for(let i=0;i<e.length;i++)if(e[i]!==r[i])continue e;return!0}}return!1}function Q_(e,t){return e?":not("+t.trim()+")":t}function YR(e){let t=e[0],n=1,r=2,i="",o=!1;for(;n<e.length;){let s=e[n];if(typeof s=="string")if(r&2){let a=e[++n];i+="["+s+(a.length>0?'="'+a+'"':"")+"]"}else r&8?i+="."+s:r&4&&(i+=" "+s);else i!==""&&!an(s)&&(t+=Q_(o,i),i=""),r=s,o=o||!an(r);n++}return i!==""&&(t+=Q_(o,i)),t}function JR(e){return e.map(YR).join(",")}function XR(e){let t=[],n=[],r=1,i=2;for(;r<e.length;){let o=e[r];if(typeof o=="string")i===2?o!==""&&t.push(o,e[++r]):i===8&&n.push(o);else{if(!an(i))break;i=o}r++}return n.length&&t.push(1,...n),t}var Pe={};function Fb(e,t){return e.createText(t)}function zb(e,t,n){e.setValue(t,n)}function Bb(e,t){return e.createComment(LR(t))}function Np(e,t,n){return e.createElement(t,n)}function Ur(e,t,n,r,i){e.insertBefore(t,n,r,i)}function jb(e,t,n){e.appendChild(t,n)}function Z_(e,t,n,r,i){r!==null?Ur(e,t,n,r,i):jb(e,t,n)}function Es(e,t,n,r){e.removeChild(null,t,n,r)}function eO(e,t,n){e.setAttribute(t,"style",n)}function tO(e,t,n){n===""?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n)}function Vb(e,t,n){let{mergedAttrs:r,classes:i,styles:o}=n;r!==null&&vA(e,t,r),i!==null&&tO(e,t,i),o!==null&&eO(e,t,o)}function kp(e,t,n,r,i,o,s,a,u,c,d){let p=me+r,h=p+i,g=nO(p,h),y=typeof c=="function"?c():c;return g[U]={type:e,blueprint:g,template:n,queries:null,viewQuery:a,declTNode:t,data:g.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof o=="function"?o():o,pipeRegistry:typeof s=="function"?s():s,firstChild:null,schemas:u,consts:y,incompleteFirstPass:!1,ssrId:d}}function nO(e,t){let n=[];for(let r=0;r<t;r++)n.push(r<e?null:Pe);return n}function Hb(e){let t=e.tView;return t===null||t.incompleteFirstPass?e.tView=kp(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts,e.id):t}function Ju(e,t,n,r,i,o,s,a,u,c,d){let p=t.blueprint.slice();return p[ut]=i,p[le]=r|4|128|8|64|1024,(c!==null||e&&e[le]&2048)&&(p[le]|=2048),Ed(p),p[qe]=p[Rr]=e,p[Be]=n,p[on]=s||e&&e[on],p[be]=a||e&&e[be],p[Re]=u||e&&e[Re]||null,p[ct]=o,p[Vo]=jA(),p[ir]=d,p[vd]=c,p[gt]=t.type==2?e[gt]:p,p}function rO(e,t,n){let r=dt(t,e),i=Hb(n),o=e[on].rendererFactory,s=Rp(e,Ju(e,i,null,Ap(n),r,t,null,o.createRenderer(r,n),null,null,null));return e[t.index]=s}function Ap(e){let t=16;return e.signals?t=4096:e.onPush&&(t=64),t}function Ts(e,t,n,r){if(n===0)return-1;let i=t.length;for(let o=0;o<n;o++)t.push(r),e.blueprint.push(r),e.data.push(null);return i}function Rp(e,t){return e[or]?e[jo][lt]=t:e[or]=t,e[jo]=t,t}function iO(e=1){Ub(Ie(),P(),ot()+e,!1)}function Ub(e,t,n,r){if(!r)if((t[le]&3)===3){let o=e.preOrderCheckHooks;o!==null&&lu(t,o,n)}else{let o=e.preOrderHooks;o!==null&&cu(t,o,0,n)}dr(n)}var as;(function(e){e[e.None=0]="None",e[e.SignalBased=1]="SignalBased",e[e.HasDecoratorInputTransform=2]="HasDecoratorInputTransform"})(as||(as={}));function Sf(e,t,n,r){let i=ae(null);try{let[o,s,a]=e.inputs[n],u=null;(s&as.SignalBased)!==0&&(u=t[o][it]),u!==null&&u.transformFn!==void 0?r=u.transformFn(r):a!==null&&(r=a.call(t,r)),e.setInput!==null?e.setInput(t,u,r,n,o):Hw(t,u,o,r)}finally{ae(i)}}var Du;(function(e){e[e.Important=1]="Important",e[e.DashCase=2]="DashCase"})(Du||(Du={}));var $f;function Op(e,t){return $f(e,t)}function oO(e){$f===void 0&&($f=e())}function Su(e){if(!e)return 0;let t=e.toLowerCase().indexOf("ms")>-1?1:1e3;return parseFloat(e)*t}function Ui(e,t){return e.getPropertyValue(t).split(",").map(r=>r.trim())}function sO(e){let t=Ui(e,"transition-property"),n=Ui(e,"transition-duration"),r=Ui(e,"transition-delay"),i={propertyName:"",duration:0,animationName:void 0};for(let o=0;o<t.length;o++){let s=Su(r[o])+Su(n[o]);s>i.duration&&(i.propertyName=t[o],i.duration=s)}return i}function aO(e){let t=Ui(e,"animation-name"),n=Ui(e,"animation-delay"),r=Ui(e,"animation-duration"),i={animationName:"",propertyName:void 0,duration:0};for(let o=0;o<t.length;o++){let s=Su(n[o])+Su(r[o]);s>i.duration&&(i.animationName=t[o],i.duration=s)}return i}function Wb(e,t){return e!==void 0&&e.duration>t.duration}function qb(e){return(e.animationName!=null||e.propertyName!=null)&&e.duration>0}function uO(e,t){let n=getComputedStyle(e),r=aO(n),i=sO(n),o=r.duration>i.duration?r:i;Wb(t.get(e),o)||qb(o)&&t.set(e,o)}function Gb(e,t,n){if(!n)return;let r=e.getAnimations();return r.length===0?uO(e,t):lO(e,t,r)}function lO(e,t,n){let r={animationName:void 0,propertyName:void 0,duration:0};for(let i of n){let o=i.effect?.getTiming(),s=typeof o?.duration=="number"?o.duration:0,a=(o?.delay??0)+s,u,c;i.animationName?c=i.animationName:u=i.transitionProperty,a>=r.duration&&(r={animationName:c,propertyName:u,duration:a})}Wb(t.get(e),r)||qb(r)&&t.set(e,r)}var Xu=new Set,cO=new ne("",{providedIn:"root",factory:()=>!1}),Cs=new ne("",{providedIn:"root",factory:()=>({queue:new Set,isScheduled:!1})}),dO=new ne("",{providedIn:"root",factory:()=>fO}),fO=4e3;function Y_(e,t,n,r){let i=e?.[En]?.enter;if(t!==null&&i&&i.has(n.index)){let o=r.get(Cs);for(let s of i.get(n.index).animateFns)o.queue.add(s)}}function Vi(e,t,n,r,i,o,s,a){if(i!=null){let u,c=!1;Dt(i)?u=i:bt(i)&&(c=!0,i=i[ut]);let d=$t(i);e===0&&r!==null?(Y_(a,r,o,n),s==null?jb(t,r,d):Ur(t,r,d,s||null,!0)):e===1&&r!==null?(Y_(a,r,o,n),Ur(t,r,d,s||null,!0)):e===2?J_(a,o,n,p=>{Es(t,d,c,p)}):e===3&&J_(a,o,n,()=>{t.destroyNode(d)}),u!=null&&wO(t,e,n,u,o,r,s)}}function pO(e,t){let n=e.get(Cs);if(Array.isArray(t))for(let r of t)n.queue.add(r);else n.queue.add(t)}function Kb(e,t){Qb(e,t),t[ut]=null,t[ct]=null}function hO(e,t,n,r,i,o){r[ut]=i,r[ct]=t,el(e,r,n,1,i,o)}function Qb(e,t){t[on].changeDetectionScheduler?.notify(9),el(e,t,t[be],2,null,null)}function mO(e){let t=e[or];if(!t)return ef(e[U],e);for(;t;){let n=null;if(bt(t))n=t[or];else{let r=t[Ke];r&&(n=r)}if(!n){for(;t&&!t[lt]&&t!==e;)bt(t)&&ef(t[U],t),t=t[qe];t===null&&(t=e),bt(t)&&ef(t[U],t),n=t&&t[lt]}t=n}}function Pp(e,t){let n=e[Lr],r=n.indexOf(t);n.splice(r,1)}function Ds(e,t){if(Tn(t))return;let n=t[be];n.destroyNode&&el(e,t,n,3,null,null),mO(t)}function ef(e,t){if(Tn(t))return;let n=ae(null);try{t[le]&=-129,t[le]|=256,t[Ot]&&So(t[Ot]),vO(e,t),yO(e,t),t[U].type===1&&t[be].destroy();let r=t[jn];if(r!==null&&Dt(t[qe])){r!==t[qe]&&Pp(r,t);let i=t[xn];i!==null&&i.detachView(e)}bf(t)}finally{ae(n)}}function J_(e,t,n,r){let i=e?.[En];if(i==null||i.leave==null||!i.leave.has(t.index))return r(!1);if(i.skipLeaveAnimations)return i.skipLeaveAnimations=!1,r(!1);pO(n,()=>{if(i.leave&&i.leave.has(t.index)){let s=i.leave.get(t.index),a=[];if(s)for(let u=0;u<s.animateFns.length;u++){let c=s.animateFns[u],{promise:d}=c();a.push(d)}i.running=Promise.allSettled(a),gO(e,r)}else e&&Xu.delete(e),r(!1)})}function gO(e,t){let n=e[En]?.running;if(n){n.then(()=>{e[En].running=void 0,Xu.delete(e),t(!0)});return}t(!1)}function yO(e,t){let n=e.cleanup,r=t[$i];if(n!==null)for(let s=0;s<n.length-1;s+=2)if(typeof n[s]=="string"){let a=n[s+3];a>=0?r[a]():r[-a].unsubscribe(),s+=2}else{let a=r[n[s+1]];n[s].call(a)}r!==null&&(t[$i]=null);let i=t[Bn];if(i!==null){t[Bn]=null;for(let s=0;s<i.length;s++){let a=i[s];a()}}let o=t[Mi];if(o!==null){t[Mi]=null;for(let s of o)s.destroy()}}function vO(e,t){let n;if(e!=null&&(n=e.destroyHooks)!=null)for(let r=0;r<n.length;r+=2){let i=t[n[r]];if(!(i instanceof Vr)){let o=n[r+1];if(Array.isArray(o))for(let s=0;s<o.length;s+=2){let a=i[o[s]],u=o[s+1];Oe(4,a,u);try{u.call(a)}finally{Oe(5,a,u)}}else{Oe(4,i,o);try{o.call(i)}finally{Oe(5,i,o)}}}}}function Zb(e,t,n){return Yb(e,t.parent,n)}function Yb(e,t,n){let r=t;for(;r!==null&&r.type&168;)t=r,r=t.parent;if(r===null)return n[ut];if(ar(r)){let{encapsulation:i}=e.data[r.directiveStart+r.componentOffset];if(i===Un.None||i===Un.Emulated)return null}return dt(r,n)}function Jb(e,t,n){return e0(e,t,n)}function Xb(e,t,n){return e.type&40?dt(e,n):null}var e0=Xb,Mf;function t0(e,t){e0=e,Mf=t}function Lp(e,t,n,r){let i=Zb(e,r,t),o=t[be],s=r.parent||t[ct],a=Jb(s,r,t);if(i!=null)if(Array.isArray(n))for(let u=0;u<n.length;u++)Z_(o,i,n[u],a,!1);else Z_(o,i,n,a,!1);Mf!==void 0&&Mf(o,r,t,n,i)}function Qo(e,t){if(t!==null){let n=t.type;if(n&3)return dt(t,e);if(n&4)return $u(-1,e[t.index]);if(n&8){let r=t.child;if(r!==null)return Qo(e,r);{let i=e[t.index];return Dt(i)?$u(-1,i):$t(i)}}else{if(n&128)return Qo(e,t.next);if(n&32)return Op(t,e)()||$t(e[t.index]);{let r=n0(e,t);if(r!==null){if(Array.isArray(r))return r[0];let i=rr(e[gt]);return Qo(i,r)}else return Qo(e,t.next)}}}return null}function n0(e,t){if(t!==null){let r=e[gt][ct],i=t.projection;return r.projection[i]}return null}function $u(e,t){let n=Ke+e+1;if(n<t.length){let r=t[n],i=r[U].firstChild;if(i!==null)return Qo(r,i)}return t[sr]}function Fp(e,t,n,r,i,o,s){for(;n!=null;){let a=r[Re];if(n.type===128){n=n.next;continue}let u=r[n.index],c=n.type;if(s&&t===0&&(u&&mr($t(u),r),n.flags|=2),!Yu(n))if(c&8)Fp(e,t,n.child,r,i,o,!1),Vi(t,e,a,i,u,n,o,r);else if(c&32){let d=Op(n,r),p;for(;p=d();)Vi(t,e,a,i,p,n,o,r);Vi(t,e,a,i,u,n,o,r)}else c&16?r0(e,t,r,n,i,o):Vi(t,e,a,i,u,n,o,r);n=s?n.projectionNext:n.next}}function el(e,t,n,r,i,o){Fp(n,r,e.firstChild,t,i,o,!1)}function _O(e,t,n){let r=t[be],i=Zb(e,n,t),o=n.parent||t[ct],s=Jb(o,n,t);r0(r,0,t,n,i,s)}function r0(e,t,n,r,i,o){let s=n[gt],u=s[ct].projection[r.projection];if(Array.isArray(u))for(let c=0;c<u.length;c++){let d=u[c];Vi(t,e,n[Re],i,d,r,o,n)}else{let c=u,d=s[qe];ub(r)&&(c.flags|=128),Fp(e,t,c,d,i,o,!0)}}function wO(e,t,n,r,i,o,s){let a=r[sr],u=$t(r);a!==u&&Vi(t,e,n,o,a,i,s);for(let c=Ke;c<r.length;c++){let d=r[c];el(d[U],d,e,t,o,a)}}function bO(e,t,n,r,i){if(t)i?e.addClass(n,r):e.removeClass(n,r);else{let o=r.indexOf("-")===-1?void 0:Du.DashCase;i==null?e.removeStyle(n,r,o):(typeof i=="string"&&i.endsWith("!important")&&(i=i.slice(0,-10),o|=Du.Important),e.setStyle(n,r,i,o))}}function i0(e,t,n,r,i){let o=ot(),s=r&2;try{dr(-1),s&&t.length>me&&Ub(e,t,me,!1),Oe(s?2:0,i,n),n(r,i)}finally{dr(o),Oe(s?3:1,i,n)}}function tl(e,t,n){CO(e,t,n),(n.flags&64)===64&&DO(e,t,n)}function ao(e,t,n=dt){let r=t.localNames;if(r!==null){let i=t.index+1;for(let o=0;o<r.length;o+=2){let s=r[o+1],a=s===-1?n(t,e):e[s];e[i++]=a}}}function IO(e,t,n,r){let o=r.get(vb,yb)||n===Un.ShadowDom,s=e.selectRootElement(t,o);return xO(s),s}function xO(e){EO(e)}var EO=()=>null;function TO(e){return e==="class"?"className":e==="for"?"htmlFor":e==="formaction"?"formAction":e==="innerHtml"?"innerHTML":e==="readonly"?"readOnly":e==="tabindex"?"tabIndex":e}function zp(e,t,n,r,i,o){let s=t[U];if(ol(e,s,t,n,r)){ar(e)&&o0(t,e.index);return}e.type&3&&(n=TO(n)),Bp(e,t,n,r,i,o)}function Bp(e,t,n,r,i,o){if(e.type&3){let s=dt(e,t);r=o!=null?o(r,e.value||"",n):r,i.setProperty(s,n,r)}else e.type&12}function o0(e,t){let n=Cn(t,e);n[le]&16||(n[le]|=64)}function CO(e,t,n){let r=n.directiveStart,i=n.directiveEnd;ar(n)&&rO(t,n,e.data[r+n.componentOffset]),e.firstCreatePass||xu(n,t);let o=n.initialInputs;for(let s=r;s<i;s++){let a=e.data[s],u=is(t,e,s,n);if(mr(u,t),o!==null&&MO(t,s-r,u,a,n,o),St(a)){let c=Cn(n.index,t);c[Be]=is(t,e,s,n)}}}function DO(e,t,n){let r=n.directiveStart,i=n.directiveEnd,o=n.index,s=m_();try{dr(o);for(let a=r;a<i;a++){let u=e.data[a],c=t[a];Ka(a),(u.hostBindings!==null||u.hostVars!==0||u.hostAttrs!==null)&&SO(u,c)}}finally{dr(-1),Ka(s)}}function SO(e,t){e.hostBindings!==null&&e.hostBindings(1,t)}function jp(e,t){let n=e.directiveRegistry,r=null;if(n)for(let i=0;i<n.length;i++){let o=n[i];Lb(t,o.selectors,!1)&&(r??=[],St(o)?r.unshift(o):r.push(o))}return r}function $O(e,t,n,r,i,o){let s=dt(e,t);nl(t[be],s,o,e.value,n,r,i)}function nl(e,t,n,r,i,o,s){if(o==null)e.removeAttribute(t,i,n);else{let a=s==null?ve(o):s(o,r||"",i);e.setAttribute(t,i,a,n)}}function MO(e,t,n,r,i,o){let s=o[t];if(s!==null)for(let a=0;a<s.length;a+=2){let u=s[a],c=s[a+1];Sf(r,n,u,c)}}function rl(e,t,n,r,i){let o=me+n,s=t[U],a=i(s,t,e,r,n);t[o]=a,Dn(e,!0);let u=e.type===2;return u?(Vb(t[be],a,e),(a_()===0||Ni(e))&&mr(a,t),u_()):mr(a,t),Go()&&(!u||!Yu(e))&&Lp(s,t,a,e),e}function il(e){let t=e;return Rd()?Od():(t=t.parent,Dn(t,!1)),t}function s0(e,t,n){return(e===null||St(e))&&(n=xd(n[t.index])),n[be]}function Vp(e,t){let n=e[Re];if(!n)return;let r;try{r=n.get(Mn,null)}catch{r=null}r?.(t)}function ol(e,t,n,r,i){let o=e.inputs?.[r],s=e.hostDirectiveInputs?.[r],a=!1;if(s)for(let u=0;u<s.length;u+=2){let c=s[u],d=s[u+1],p=t.data[c];Sf(p,n[c],d,i),a=!0}if(o)for(let u of o){let c=n[u],d=t.data[u];Sf(d,c,r,i),a=!0}return a}function NO(e,t){let n=Cn(t,e),r=n[U];kO(r,n);let i=n[ut];i!==null&&n[ir]===null&&(n[ir]=xb(i,n[Re])),Oe(18),sl(r,n,n[Be]),Oe(19,n[Be])}function kO(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}function sl(e,t,n){Ya(t);try{let r=e.viewQuery;r!==null&&If(1,r,n);let i=e.template;i!==null&&i0(e,t,i,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),t[xn]?.finishViewCreation(e),e.staticContentQueries&&Cb(e,t),e.staticViewQueries&&If(2,e.viewQuery,n);let o=e.components;o!==null&&AO(t,o)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0,e.firstCreatePass=!1),r}finally{t[le]&=-5,Ja()}}function AO(e,t){for(let n=0;n<t.length;n++)NO(e,t[n])}function uo(e,t,n,r){let i=ae(null);try{let o=t.tView,a=e[le]&4096?4096:16,u=Ju(e,o,n,a,null,t,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),c=e[t.index];u[jn]=c;let d=e[xn];return d!==null&&(u[xn]=d.createEmbeddedView(o)),sl(o,u,n),u}finally{ae(i)}}function Wr(e,t){return!t||t.firstChild===null||ub(e)}var OU=new ne("");function us(e,t,n,r,i=!1){for(;n!==null;){if(n.type===128){n=i?n.projectionNext:n.next;continue}let o=t[n.index];o!==null&&r.push($t(o)),Dt(o)&&a0(o,r);let s=n.type;if(s&8)us(e,t,n.child,r);else if(s&32){let a=Op(n,t),u;for(;u=a();)r.push(u)}else if(s&16){let a=n0(t,n);if(Array.isArray(a))r.push(...a);else{let u=rr(t[gt]);us(u[U],u,a,r,!0)}}n=i?n.projectionNext:n.next}return r}function a0(e,t){for(let n=Ke;n<e.length;n++){let r=e[n],i=r[U].firstChild;i!==null&&us(r[U],r,i,t)}e[sr]!==e[ut]&&t.push(e[sr])}function u0(e){if(e[Pr]!==null){for(let t of e[Pr])t.impl.addSequence(t);e[Pr].length=0}}var l0=[];function RO(e){return e[Ot]??OO(e)}function OO(e){let t=l0.pop()??Object.create(LO);return t.lView=e,t}function PO(e){e.lView[Ot]!==e&&(e.lView=null,l0.push(e))}var LO={...Co,consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:e=>{zr(e.lView)},consumerOnSignalRead(){this.lView[Ot]=this}};function FO(e){let t=e[Ot]??Object.create(zO);return t.lView=e,t}var zO={...Co,consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:e=>{let t=rr(e.lView);for(;t&&!c0(t[U]);)t=rr(t);t&&Td(t)},consumerOnSignalRead(){this.lView[Ot]=this}};function c0(e){return e.type!==2}function d0(e){if(e[Mi]===null)return;let t=!0;for(;t;){let n=!1;for(let r of e[Mi])r.dirty&&(n=!0,r.zone===null||Zone.current===r.zone?r.run():r.zone.run(()=>r.run()));t=n&&!!(e[le]&8192)}}var BO=100;function f0(e,t=0){let r=e[on].rendererFactory,i=!1;i||r.begin?.();try{jO(e,t)}finally{i||r.end?.()}}function jO(e,t){let n=Ld();try{Ga(!0),Nf(e,t);let r=0;for(;Uo(e);){if(r===BO)throw new ie(103,!1);r++,Nf(e,1)}}finally{Ga(n)}}function p0(e,t,n,r){if(Tn(t))return;let i=t[le],o=!1,s=!1;Ya(t);let a=!0,u=null,c=null;o||(c0(e)?(c=RO(t),u=Do(c)):ma()===null?(a=!1,c=FO(t),u=Do(c)):t[Ot]&&(So(t[Ot]),t[Ot]=null));try{Ed(t),Fd(e.bindingStartIndex),n!==null&&i0(e,t,n,2,r);let d=(i&3)===3;if(!o)if(d){let g=e.preOrderCheckHooks;g!==null&&lu(t,g,null)}else{let g=e.preOrderHooks;g!==null&&cu(t,g,0,null),Qd(t,0)}if(s||VO(t),d0(t),h0(t,0),e.contentQueries!==null&&Cb(e,t),!o)if(d){let g=e.contentCheckHooks;g!==null&&lu(t,g)}else{let g=e.contentHooks;g!==null&&cu(t,g,1),Qd(t,1)}UO(e,t);let p=e.components;p!==null&&g0(t,p,0);let h=e.viewQuery;if(h!==null&&If(2,h,r),!o)if(d){let g=e.viewCheckHooks;g!==null&&lu(t,g)}else{let g=e.viewHooks;g!==null&&cu(t,g,2),Qd(t,2)}if(e.firstUpdatePass===!0&&(e.firstUpdatePass=!1),t[ja]){for(let g of t[ja])g();t[ja]=null}o||(u0(t),t[le]&=-73)}catch(d){throw o||zr(t),d}finally{c!==null&&(ga(c,u),a&&PO(c)),Ja()}}function h0(e,t){for(let n=lb(e);n!==null;n=cb(n))for(let r=Ke;r<n.length;r++){let i=n[r];m0(i,t)}}function VO(e){for(let t=lb(e);t!==null;t=cb(t)){if(!(t[le]&2))continue;let n=t[Lr];for(let r=0;r<n.length;r++){let i=n[r];Td(i)}}}function HO(e,t,n){Oe(18);let r=Cn(t,e);m0(r,n),Oe(19,r[Be])}function m0(e,t){Ha(e)&&Nf(e,t)}function Nf(e,t){let r=e[U],i=e[le],o=e[Ot],s=!!(t===0&&i&16);if(s||=!!(i&64&&t===0),s||=!!(i&1024),s||=!!(o?.dirty&&ya(o)),s||=!1,o&&(o.dirty=!1),e[le]&=-9217,s)p0(r,e,r.template,e[Be]);else if(i&8192){let a=ae(null);try{d0(e),h0(e,1);let u=r.components;u!==null&&g0(e,u,1),u0(e)}finally{ae(a)}}}function g0(e,t,n){for(let r=0;r<t.length;r++)HO(e,t[r],n)}function UO(e,t){let n=e.hostBindingOpCodes;if(n!==null)try{for(let r=0;r<n.length;r++){let i=n[r];if(i<0)dr(~i);else{let o=i,s=n[++r],a=n[++r];h_(s,o);let u=t[o];Oe(24,u),a(2,u),Oe(25,u)}}}finally{dr(-1)}}function al(e,t){let n=Ld()?64:1088;for(e[on].changeDetectionScheduler?.notify(t);e;){e[le]|=n;let r=rr(e);if(ur(e)&&!r)return e;e=r}return null}function y0(e,t,n,r){return[e,!0,0,t,null,r,null,n,null,null]}function v0(e,t){let n=Ke+t;if(n<e.length)return e[n]}function lo(e,t,n,r=!0){let i=t[U];if(WO(i,t,e,n),r){let s=$u(n,e),a=t[be],u=a.parentNode(e[sr]);u!==null&&hO(i,e[ct],a,t,u,s)}let o=t[ir];o!==null&&o.firstChild!==null&&(o.firstChild=null)}function Hp(e,t){let n=ls(e,t);return n!==void 0&&Ds(n[U],n),n}function ls(e,t){if(e.length<=Ke)return;let n=Ke+t,r=e[n];if(r){let i=r[jn];i!==null&&i!==e&&Pp(i,r),t>0&&(e[n-1][lt]=r[lt]);let o=Lo(e,Ke+t);Kb(r[U],r);let s=o[xn];s!==null&&s.detachView(o[U]),r[qe]=null,r[lt]=null,r[le]&=-129}return r}function WO(e,t,n,r){let i=Ke+r,o=n.length;r>0&&(n[i-1][lt]=t),r<o-Ke?(t[lt]=n[i],cd(n,Ke+r,t)):(n.push(t),t[lt]=null),t[qe]=n;let s=t[jn];s!==null&&n!==s&&_0(s,t);let a=t[xn];a!==null&&a.insertView(e),Ua(t),t[le]|=128}function _0(e,t){let n=e[Lr],r=t[qe];if(bt(r))e[le]|=2;else{let i=r[qe][gt];t[gt]!==i&&(e[le]|=2)}n===null?e[Lr]=[t]:n.push(t)}var Yi=class{_lView;_cdRefInjectingView;_appRef=null;_attachedToViewContainer=!1;exhaustive;get rootNodes(){let t=this._lView,n=t[U];return us(n,t,n.firstChild,[])}constructor(t,n){this._lView=t,this._cdRefInjectingView=n}get context(){return this._lView[Be]}set context(t){this._lView[Be]=t}get destroyed(){return Tn(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let t=this._lView[qe];if(Dt(t)){let n=t[Ho],r=n?n.indexOf(this):-1;r>-1&&(ls(t,r),Lo(n,r))}this._attachedToViewContainer=!1}Ds(this._lView[U],this._lView)}onDestroy(t){Wo(this._lView,t)}markForCheck(){al(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[le]&=-129}reattach(){Ua(this._lView),this._lView[le]|=128}detectChanges(){this._lView[le]|=1024,f0(this._lView)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new ie(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let t=ur(this._lView),n=this._lView[jn];n!==null&&!t&&Pp(n,this._lView),Qb(this._lView[U],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new ie(902,!1);this._appRef=t;let n=ur(this._lView),r=this._lView[jn];r!==null&&!n&&_0(r,this._lView),Ua(this._lView)}};var Ji=class{_declarationLView;_declarationTContainer;elementRef;static __NG_ELEMENT_ID__=qO;constructor(t,n,r){this._declarationLView=t,this._declarationTContainer=n,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,n){return this.createEmbeddedViewImpl(t,n)}createEmbeddedViewImpl(t,n,r){let i=uo(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:n,dehydratedView:r});return new Yi(i)}};function qO(){return ul(ge(),P())}function ul(e,t){return e.type&4?new Ji(t,e,oo(e,t)):null}function w0(e,t,n){let r=t.insertBeforeIndex,i=Array.isArray(r)?r[0]:r;return i===null?Xb(e,t,n):$t(n[i])}function b0(e,t,n,r,i){let o=t.insertBeforeIndex;if(Array.isArray(o)){let s=r,a=null;if(t.type&3||(a=s,s=i),s!==null&&t.componentOffset===-1)for(let u=1;u<o.length;u++){let c=n[o[u]];Ur(e,s,c,a,!1)}}}function Zr(e,t,n,r,i){let o=e.data[t];if(o===null)o=Up(e,t,n,r,i),p_()&&(o.flags|=32);else if(o.type&64){o.type=n,o.value=r,o.attrs=i;let s=ki();o.injectorIndex=s===null?-1:s.injectorIndex}return Dn(o,!0),o}function Up(e,t,n,r,i){let o=Ad(),s=Rd(),a=s?o:o&&o.parent,u=e.data[t]=KO(e,a,n,t,r,i);return GO(e,u,o,s),u}function GO(e,t,n,r){e.firstChild===null&&(e.firstChild=t),n!==null&&(r?n.child==null&&t.parent!==null&&(n.child=t):n.next===null&&(n.next=t,t.prev=n))}function KO(e,t,n,r,i,o){let s=t?t.injectorIndex:-1,a=0;return Md()&&(a|=128),{type:n,index:r,insertBeforeIndex:null,injectorIndex:s,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:i,attrs:o,mergedAttrs:null,localNames:null,initialInputs:null,inputs:null,hostDirectiveInputs:null,outputs:null,hostDirectiveOutputs:null,directiveToIndex:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function I0(e,t){if(e.push(t),e.length>1)for(let n=e.length-2;n>=0;n--){let r=e[n];x0(r)||QO(r,t)&&ZO(r)===null&&YO(r,t.index)}}function x0(e){return!(e.type&64)}function QO(e,t){return x0(t)||e.index>t.index}function ZO(e){let t=e.insertBeforeIndex;return Array.isArray(t)?t[0]:t}function YO(e,t){let n=e.insertBeforeIndex;Array.isArray(n)?n[0]=t:(t0(w0,b0),e.insertBeforeIndex=t)}function Jo(e,t){let n=e.data[t];return n===null||typeof n=="string"?null:n.hasOwnProperty("currentCaseLViewIndex")?n:n.value}function JO(e,t,n){let r=e.data[t];r===null?e.data[t]=n:r.value=n}function XO(e,t){let n=e.insertBeforeIndex;n===null?(t0(w0,b0),n=e.insertBeforeIndex=[null,t]):(Gv(Array.isArray(n),!0,"Expecting array here"),n.push(t))}function e3(e,t,n){let r=Up(e,n,64,null,null);return I0(t,r),r}function ll(e,t){let n=t[e.currentCaseLViewIndex];return n===null?n:n<0?~n:n}function t3(e){return e>>>17}function n3(e){return(e&131070)>>>1}function r3(e,t,n){return e|t<<17|n<<1}function i3(e){return e===-1}function E0(e,t,n){e.index=0;let r=ll(t,n);r!==null?e.removes=t.remove[r]:e.removes=Ne}function kf(e){if(e.index<e.removes.length){let t=e.removes[e.index++];if(t>0)return e.lView[t];{e.stack.push(e.index,e.removes);let n=~t,r=e.lView[U].data[n];return E0(e,r,e.lView),kf(e)}}else return e.stack.length===0?null:(e.removes=e.stack.pop(),e.index=e.stack.pop(),kf(e))}function o3(){let e={stack:[],index:-1};function t(n,r){for(e.lView=r;e.stack.length;)e.stack.pop();return E0(e,n.value,r),kf.bind(null,e)}return t}var PU=new RegExp(`^(\\d+)*(${QA}|${KA})*(.*)`);var s3=()=>{};function a3(e,t,n,r){s3(e,t,n,r)}var u3=()=>{};function l3(e,t,n){u3(e,t,n)}function c3(e){let t=e[ir];if(t){let{i18nNodes:n,dehydratedIcuData:r}=t;if(n&&r){let i=e[be];for(let o of r.values())d3(i,n,o)}t.i18nNodes=void 0,t.dehydratedIcuData=void 0}}function d3(e,t,n){for(let r of n.node.cases[n.case]){let i=t.get(r.index-me);i&&Es(e,i,!1)}}function T0(e){let t=e[Vn]??[],r=e[qe][be],i=[];for(let o of t)o.data[Ep]!==void 0?i.push(o):C0(o,r);e[Vn]=i}function f3(e){let{lContainer:t}=e,n=t[Vn];if(n===null)return;let i=t[qe][be];for(let o of n)C0(o,i)}function C0(e,t){let n=0,r=e.firstChild;if(r){let i=e.data[mb];for(;n<i;){let o=r.nextSibling;Es(t,r,!1),r=o,n++}}}function cl(e){T0(e);let t=e[ut];bt(t)&&Mu(t);for(let n=Ke;n<e.length;n++)Mu(e[n])}function Mu(e){c3(e);let t=e[U];for(let n=me;n<t.bindingStartIndex;n++)if(Dt(e[n])){let r=e[n];cl(r)}else bt(e[n])&&Mu(e[n])}function D0(e){let t=e._views;for(let n of t){let r=Eb(n);r!==null&&r[ut]!==null&&(bt(r)?Mu(r):cl(r))}}function p3(e,t,n,r){e!==null&&(n.cleanup(t),cl(e.lContainer),D0(r))}var h3=()=>null,m3=()=>null;function Nu(e,t){return h3(e,t)}function S0(e,t,n){return m3(e,t,n)}var g3=class{},$0=class{},Af=class{resolveComponentFactory(t){throw new ie(917,!1)}},dl=class{static NULL=new Af},ku=class{};var Rf=class e{static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>null})};function Wp(e){return e.ngModule!==void 0}function Pi(e){return!!Ar(e)}function iu(e){return!!rn(e)}function X_(e){return!!Rt(e)}function Xo(e){return!!Ge(e)}function y3(e){return Ge(e)?"component":Rt(e)?"directive":rn(e)?"pipe":"type"}function v3(e,t){if(Oo(e)&&(e=Se(e),!e))throw new Error(`Expected forwardRef function, imported from "${tn(t)}", to return a standalone entity or NgModule but got "${tn(e)||e}".`);if(Ar(e)==null){let n=Ge(e)||Rt(e)||rn(e);if(n!=null){if(!n.standalone)throw new Error(`The "${tn(e)}" ${y3(e)}, imported from "${tn(t)}", is not standalone. Did you forget to add the standalone: true flag?`)}else throw Wp(e)?new Error(`A module with providers was imported from "${tn(t)}". Modules with providers are not supported in standalone components imports.`):new Error(`The "${tn(e)}" type, imported from "${tn(t)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`)}}var Of=class{ownerNgModule=new Map;ngModulesWithSomeUnresolvedDecls=new Set;ngModulesScopeCache=new Map;standaloneComponentsScopeCache=new Map;resolveNgModulesDecls(){if(this.ngModulesWithSomeUnresolvedDecls.size!==0){for(let t of this.ngModulesWithSomeUnresolvedDecls){let n=Ar(t);if(n?.declarations)for(let r of ji(n.declarations))Xo(r)&&this.ownerNgModule.set(r,t)}this.ngModulesWithSomeUnresolvedDecls.clear()}}getComponentDependencies(t,n){this.resolveNgModulesDecls();let r=Ge(t);if(r===null)throw new Error(`Attempting to get component dependencies for a type that is not a component: ${t}`);if(r.standalone){let i=this.getStandaloneComponentScope(t,n);return i.compilation.isPoisoned?{dependencies:[]}:{dependencies:[...i.compilation.directives,...i.compilation.pipes,...i.compilation.ngModules]}}else{if(!this.ownerNgModule.has(t))return{dependencies:[]};let i=this.getNgModuleScope(this.ownerNgModule.get(t));return i.compilation.isPoisoned?{dependencies:[]}:{dependencies:[...i.compilation.directives,...i.compilation.pipes]}}}registerNgModule(t,n){if(!Pi(t))throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${t}`);this.ngModulesWithSomeUnresolvedDecls.add(t)}clearScopeCacheFor(t){this.ngModulesScopeCache.delete(t),this.standaloneComponentsScopeCache.delete(t)}getNgModuleScope(t){if(this.ngModulesScopeCache.has(t))return this.ngModulesScopeCache.get(t);let n=this.computeNgModuleScope(t);return this.ngModulesScopeCache.set(t,n),n}computeNgModuleScope(t){let n=La(t),r={exported:{directives:new Set,pipes:new Set},compilation:{directives:new Set,pipes:new Set}};for(let i of ji(n.imports))if(Pi(i)){let o=this.getNgModuleScope(i);fr(o.exported.directives,r.compilation.directives),fr(o.exported.pipes,r.compilation.pipes)}else if(Fa(i))if(X_(i)||Xo(i))r.compilation.directives.add(i);else if(iu(i))r.compilation.pipes.add(i);else throw new ie(980,"The standalone imported type is neither a component nor a directive nor a pipe");else{r.compilation.isPoisoned=!0;break}if(!r.compilation.isPoisoned)for(let i of ji(n.declarations)){if(Pi(i)||Fa(i)){r.compilation.isPoisoned=!0;break}iu(i)?r.compilation.pipes.add(i):r.compilation.directives.add(i)}for(let i of ji(n.exports))if(Pi(i)){let o=this.getNgModuleScope(i);fr(o.exported.directives,r.exported.directives),fr(o.exported.pipes,r.exported.pipes),fr(o.exported.directives,r.compilation.directives),fr(o.exported.pipes,r.compilation.pipes)}else iu(i)?r.exported.pipes.add(i):r.exported.directives.add(i);return r}getStandaloneComponentScope(t,n){if(this.standaloneComponentsScopeCache.has(t))return this.standaloneComponentsScopeCache.get(t);let r=this.computeStandaloneComponentScope(t,n);return this.standaloneComponentsScopeCache.set(t,r),r}computeStandaloneComponentScope(t,n){let r={compilation:{directives:new Set([t]),pipes:new Set,ngModules:new Set}};for(let i of nn(n??[])){let o=Se(i);try{v3(o,t)}catch{return r.compilation.isPoisoned=!0,r}if(Pi(o)){r.compilation.ngModules.add(o);let s=this.getNgModuleScope(o);if(s.exported.isPoisoned)return r.compilation.isPoisoned=!0,r;fr(s.exported.directives,r.compilation.directives),fr(s.exported.pipes,r.compilation.pipes)}else if(iu(o))r.compilation.pipes.add(o);else if(X_(o)||Xo(o))r.compilation.directives.add(o);else return r.compilation.isPoisoned=!0,r}return r}isOrphanComponent(t){let n=Ge(t);return!n||n.standalone?!1:(this.resolveNgModulesDecls(),!this.ownerNgModule.has(t))}};function fr(e,t){for(let n of e)t.add(n)}var cs=new Of,tf={},Wi=class{injector;parentInjector;constructor(t,n){this.injector=t,this.parentInjector=n}get(t,n,r){let i=this.injector.get(t,tf,r);return i!==tf||n===tf?i:this.parentInjector.get(t,n,r)}};function Au(e,t,n){let r=n?e.styles:null,i=n?e.classes:null,o=0;if(t!==null)for(let s=0;s<t.length;s++){let a=t[s];if(typeof a=="number")o=a;else if(o==1)i=$a(i,a);else if(o==2){let u=a,c=t[++s];r=$a(r,u+": "+c+";")}}n?e.styles=r:e.stylesWithoutHost=r,n?e.classes=i:e.classesWithoutHost=i}function Ss(e,t=0){let n=P();if(n===null)return mt(e,t);let r=ge();return rb(r,n,Se(e),t)}function _3(){let e="invalid";throw new Error(e)}function M0(e,t,n,r,i){let o=r===null?null:{"":-1},s=i(e,n);if(s!==null){let a=s,u=null,c=null;for(let d of s)if(d.resolveHostDirectives!==null){[a,u,c]=d.resolveHostDirectives(s);break}I3(e,t,n,a,o,u,c)}o!==null&&r!==null&&w3(n,r,o)}function w3(e,t,n){let r=e.localNames=[];for(let i=0;i<t.length;i+=2){let o=n[t[i+1]];if(o==null)throw new ie(-301,!1);r.push(t[i],o)}}function b3(e,t,n){t.componentOffset=n,(e.components??=[]).push(t.index)}function I3(e,t,n,r,i,o,s){let a=r.length,u=!1;for(let h=0;h<a;h++){let g=r[h];!u&&St(g)&&(u=!0,b3(e,n,h)),vf(xu(n,t),e,g.type)}S3(n,e.data.length,a);for(let h=0;h<a;h++){let g=r[h];g.providersResolver&&g.providersResolver(g)}let c=!1,d=!1,p=Ts(e,t,a,null);a>0&&(n.directiveToIndex=new Map);for(let h=0;h<a;h++){let g=r[h];if(n.mergedAttrs=Qi(n.mergedAttrs,g.hostAttrs),E3(e,n,t,p,g),D3(p,g,i),s!==null&&s.has(g)){let[w,x]=s.get(g);n.directiveToIndex.set(g.type,[p,w+n.directiveStart,x+n.directiveStart])}else(o===null||!o.has(g))&&n.directiveToIndex.set(g.type,p);g.contentQueries!==null&&(n.flags|=4),(g.hostBindings!==null||g.hostAttrs!==null||g.hostVars!==0)&&(n.flags|=64);let y=g.type.prototype;!c&&(y.ngOnChanges||y.ngOnInit||y.ngDoCheck)&&((e.preOrderHooks??=[]).push(n.index),c=!0),!d&&(y.ngOnChanges||y.ngDoCheck)&&((e.preOrderCheckHooks??=[]).push(n.index),d=!0),p++}x3(e,n,o)}function x3(e,t,n){for(let r=t.directiveStart;r<t.directiveEnd;r++){let i=e.data[r];if(n===null||!n.has(i))ew(0,t,i,r),ew(1,t,i,r),nw(t,r,!1);else{let o=n.get(i);tw(0,t,o,r),tw(1,t,o,r),nw(t,r,!0)}}}function ew(e,t,n,r){let i=e===0?n.inputs:n.outputs;for(let o in i)if(i.hasOwnProperty(o)){let s;e===0?s=t.inputs??={}:s=t.outputs??={},s[o]??=[],s[o].push(r),N0(t,o)}}function tw(e,t,n,r){let i=e===0?n.inputs:n.outputs;for(let o in i)if(i.hasOwnProperty(o)){let s=i[o],a;e===0?a=t.hostDirectiveInputs??={}:a=t.hostDirectiveOutputs??={},a[s]??=[],a[s].push(r,o),N0(t,s)}}function N0(e,t){t==="class"?e.flags|=8:t==="style"&&(e.flags|=16)}function nw(e,t,n){let{attrs:r,inputs:i,hostDirectiveInputs:o}=e;if(r===null||!n&&i===null||n&&o===null||Mp(e)){e.initialInputs??=[],e.initialInputs.push(null);return}let s=null,a=0;for(;a<r.length;){let u=r[a];if(u===0){a+=4;continue}else if(u===5){a+=2;continue}else if(typeof u=="number")break;if(!n&&i.hasOwnProperty(u)){let c=i[u];for(let d of c)if(d===t){s??=[],s.push(u,r[a+1]);break}}else if(n&&o.hasOwnProperty(u)){let c=o[u];for(let d=0;d<c.length;d+=2)if(c[d]===t){s??=[],s.push(c[d+1],r[a+1]);break}}a+=2}e.initialInputs??=[],e.initialInputs.push(s)}function E3(e,t,n,r,i){e.data[r]=i;let o=i.factory||(i.factory=nr(i.type,!0)),s=new Vr(o,St(i),Ss,null);e.blueprint[r]=s,n[r]=s,T3(e,t,r,Ts(e,n,i.hostVars,Pe),i)}function T3(e,t,n,r,i){let o=i.hostBindings;if(o){let s=e.hostBindingOpCodes;s===null&&(s=e.hostBindingOpCodes=[]);let a=~t.index;C3(s)!=a&&s.push(a),s.push(n,r,o)}}function C3(e){let t=e.length;for(;t>0;){let n=e[--t];if(typeof n=="number"&&n<0)return n}return 0}function D3(e,t,n){if(n){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)n[t.exportAs[r]]=e;St(t)&&(n[""]=e)}}function S3(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function qp(e,t,n,r,i,o,s,a){let u=t[U],c=u.consts,d=ft(c,s),p=Zr(u,e,n,r,d);return o&&M0(u,t,p,ft(c,a),i),p.mergedAttrs=Qi(p.mergedAttrs,p.attrs),p.attrs!==null&&Au(p,p.attrs,!1),p.mergedAttrs!==null&&Au(p,p.mergedAttrs,!0),u.queries!==null&&u.queries.elementStart(u,p),p}function Gp(e,t){Gw(e,t),wd(t)&&e.queries.elementEnd(t)}function k0(e,t,n,r,i,o){let s=t.consts,a=ft(s,i),u=Zr(t,e,n,r,a);if(u.mergedAttrs=Qi(u.mergedAttrs,u.attrs),o!=null){let c=ft(s,o);u.localNames=[];for(let d=0;d<c.length;d+=2)u.localNames.push(c[d],-1)}return u.attrs!==null&&Au(u,u.attrs,!1),u.mergedAttrs!==null&&Au(u,u.mergedAttrs,!0),t.queries!==null&&t.queries.elementStart(t,u),u}function Kp(e){return fl(e)?Array.isArray(e)||!(e instanceof Map)&&Symbol.iterator in e:!1}function A0(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{let n=e[Symbol.iterator](),r;for(;!(r=n.next()).done;)t(r.value)}}function fl(e){return e!==null&&(typeof e=="function"||typeof e=="object")}function An(e,t,n){return e[t]=n}function $s(e,t){return e[t]}function Ue(e,t,n){if(n===Pe)return!1;let r=e[t];return Object.is(r,n)?!1:(e[t]=n,!0)}function qr(e,t,n,r){let i=Ue(e,t,n);return Ue(e,t+1,r)||i}function pl(e,t,n,r,i){let o=qr(e,t,n,r);return Ue(e,t+2,i)||o}function qt(e,t,n,r,i,o){let s=qr(e,t,n,r);return qr(e,t+2,i,o)||s}function fu(e,t,n){return function r(i){let o=ar(e)?Cn(e.index,t):t;al(o,5);let s=t[Be],a=rw(t,s,n,i),u=r.__ngNextListenerFn__;for(;u;)a=rw(t,s,u,i)&&a,u=u.__ngNextListenerFn__;return a}}function rw(e,t,n,r){let i=ae(null);try{return Oe(6,t,n),n(r)!==!1}catch(o){return Vp(e,o),!1}finally{Oe(7,t,n),ae(i)}}function R0(e,t,n,r,i,o,s,a){let u=Ni(e),c=!1,d=null;if(!r&&u&&(d=M3(t,n,o,e.index)),d!==null){let p=d.__ngLastListenerFn__||d;p.__ngNextListenerFn__=s,d.__ngLastListenerFn__=s,c=!0}else{let p=dt(e,n),h=r?r(p):p;iR(n,h,o,a);let g=i.listen(h,o,a);if(!$3(o)){let y=r?w=>r($t(w[e.index])):e.index;O0(y,t,n,o,a,g,!1)}}return c}function $3(e){return e.startsWith("animation")||e.startsWith("transition")}function M3(e,t,n,r){let i=e.cleanup;if(i!=null)for(let o=0;o<i.length-1;o+=2){let s=i[o];if(s===n&&i[o+1]===r){let a=t[$i],u=i[o+2];return a&&a.length>u?a[u]:null}typeof s=="string"&&(o+=2)}return null}function O0(e,t,n,r,i,o,s){let a=t.firstCreatePass?Sd(t):null,u=Dd(n),c=u.length;u.push(i,o),a&&a.push(r,e,c,(c+1)*(s?-1:1))}function iw(e,t,n,r,i,o){let s=t[n],a=t[U],c=a.data[n].outputs[r],p=s[c].subscribe(o);O0(e.index,a,t,i,o,p,!0)}var Pf=Symbol("BINDING");var Ru=class extends dl{ngModule;constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){let n=Ge(t);return new Xi(n,this.ngModule)}};function N3(e){return Object.keys(e).map(t=>{let[n,r,i]=e[t],o={propName:n,templateName:t,isSignal:(r&as.SignalBased)!==0};return i&&(o.transform=i),o})}function k3(e){return Object.keys(e).map(t=>({propName:e[t],templateName:t}))}function A3(e,t,n){let r=t instanceof Vt?t:t?.injector;return r&&e.getStandaloneInjector!==null&&(r=e.getStandaloneInjector(r)||r),r?new Wi(n,r):n}function R3(e){let t=e.get(ku,null);if(t===null)throw new ie(407,!1);let n=e.get(Rf,null),r=e.get(In,null);return{rendererFactory:t,sanitizer:n,changeDetectionScheduler:r,ngReflect:!1}}function O3(e,t){let n=P3(e);return Np(t,n,n==="svg"?bd:n==="math"?Id:null)}function P3(e){return(e.selectors[0][0]||"div").toLowerCase()}var Xi=class extends $0{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;cachedInputs=null;cachedOutputs=null;get inputs(){return this.cachedInputs??=N3(this.componentDef.inputs),this.cachedInputs}get outputs(){return this.cachedOutputs??=k3(this.componentDef.outputs),this.cachedOutputs}constructor(t,n){super(),this.componentDef=t,this.ngModule=n,this.componentType=t.type,this.selector=JR(t.selectors),this.ngContentSelectors=t.ngContentSelectors??[],this.isBoundToModule=!!n}create(t,n,r,i,o,s){Oe(22);let a=ae(null);try{let u=this.componentDef,c=L3(r,u,s,o),d=A3(u,i||this.ngModule,t),p=R3(d),h=p.rendererFactory.createRenderer(null,u),g=r?IO(h,r,u.encapsulation,d):O3(u,h),y=s?.some(ow)||o?.some(I=>typeof I!="function"&&I.bindings.some(ow)),w=Ju(null,c,null,512|Ap(u),null,null,p,h,d,null,xb(g,d,!0));w[me]=g,Ya(w);let x=null;try{let I=qp(me,w,2,"#host",()=>c.directiveRegistry,!0,0);Vb(h,g,I),mr(g,w),tl(c,w,I),Cp(c,I,w),Gp(c,I),n!==void 0&&z3(I,this.ngContentSelectors,n),x=Cn(I.index,w),w[Be]=x[Be],sl(c,w,null)}catch(I){throw x!==null&&bf(x),bf(w),I}finally{Oe(23),Ja()}return new Lf(this.componentType,w,!!y)}finally{ae(a)}}};function L3(e,t,n,r){let i=e?["ng-version","20.3.4"]:XR(t.selectors[0]),o=null,s=null,a=0;if(n)for(let d of n)a+=d[Pf].requiredVars,d.create&&(d.targetIdx=0,(o??=[]).push(d)),d.update&&(d.targetIdx=0,(s??=[]).push(d));if(r)for(let d=0;d<r.length;d++){let p=r[d];if(typeof p!="function")for(let h of p.bindings){a+=h[Pf].requiredVars;let g=d+1;h.create&&(h.targetIdx=g,(o??=[]).push(h)),h.update&&(h.targetIdx=g,(s??=[]).push(h))}}let u=[t];if(r)for(let d of r){let p=typeof d=="function"?d:d.type,h=Rt(p);u.push(h)}return kp(0,null,F3(o,s),1,a,u,null,null,null,[i],null)}function F3(e,t){return!e&&!t?null:n=>{if(n&1&&e)for(let r of e)r.create();if(n&2&&t)for(let r of t)r.update()}}function ow(e){let t=e[Pf].kind;return t==="input"||t==="twoWay"}var Lf=class extends g3{_rootLView;_hasInputBindings;instance;hostView;changeDetectorRef;componentType;location;previousInputValues=null;_tNode;constructor(t,n,r){super(),this._rootLView=n,this._hasInputBindings=r,this._tNode=lr(n[U],me),this.location=oo(this._tNode,n),this.instance=Cn(this._tNode.index,n)[Be],this.hostView=this.changeDetectorRef=new Yi(n,void 0),this.componentType=t}setInput(t,n){this._hasInputBindings;let r=this._tNode;if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),n))return;let i=this._rootLView,o=ol(r,i[U],i,t,n);this.previousInputValues.set(t,n);let s=Cn(r.index,i);al(s,1)}get injector(){return new Br(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}};function z3(e,t,n){let r=e.projection=[];for(let i=0;i<t.length;i++){let o=n[i];r.push(o!=null&&o.length?Array.from(o):null)}}var ds=class{static __NG_ELEMENT_ID__=B3};function B3(){let e=ge();return L0(e,P())}var j3=ds,P0=class extends j3{_lContainer;_hostTNode;_hostLView;constructor(t,n,r){super(),this._lContainer=t,this._hostTNode=n,this._hostLView=r}get element(){return oo(this._hostTNode,this._hostLView)}get injector(){return new Br(this._hostTNode,this._hostLView)}get parentInjector(){let t=wp(this._hostTNode,this._hostLView);if(Yw(t)){let n=bu(t,this._hostLView),r=wu(t),i=n[U].data[r+8];return new Br(i,n)}else return new Br(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){let n=sw(this._lContainer);return n!==null&&n[t]||null}get length(){return this._lContainer.length-Ke}createEmbeddedView(t,n,r){let i,o;typeof r=="number"?i=r:r!=null&&(i=r.index,o=r.injector);let s=Nu(this._lContainer,t.ssrId),a=t.createEmbeddedViewImpl(n||{},o,s);return this.insertImpl(a,i,Wr(this._hostTNode,s)),a}createComponent(t,n,r,i,o,s,a){let u=t&&!Ko(t),c;if(u)c=n;else{let x=n||{};c=x.index,r=x.injector,i=x.projectableNodes,o=x.environmentInjector||x.ngModuleRef,s=x.directives,a=x.bindings}let d=u?t:new Xi(Ge(t)),p=r||this.parentInjector;if(!o&&d.ngModule==null){let I=(u?p:this.parentInjector).get(Vt,null);I&&(o=I)}let h=Ge(d.componentType??{}),g=Nu(this._lContainer,h?.id??null),y=g?.firstChild??null,w=d.create(p,i,y,o,s,a);return this.insertImpl(w.hostView,c,Wr(this._hostTNode,g)),w}insert(t,n){return this.insertImpl(t,n,!0)}insertImpl(t,n,r){let i=t._lView;if(o_(i)){let a=this.indexOf(t);if(a!==-1)this.detach(a);else{let u=i[qe],c=new P0(u,u[ct],u[qe]);c.detach(c.indexOf(t))}}let o=this._adjustIndex(n),s=this._lContainer;return lo(s,i,o,r),t.attachToViewContainerRef(),cd(nf(s),o,t),t}move(t,n){return this.insert(t,n)}indexOf(t){let n=sw(this._lContainer);return n!==null?n.indexOf(t):-1}remove(t){let n=this._adjustIndex(t,-1),r=ls(this._lContainer,n);r&&(Lo(nf(this._lContainer),n),Ds(r[U],r))}detach(t){let n=this._adjustIndex(t,-1),r=ls(this._lContainer,n);return r&&Lo(nf(this._lContainer),n)!=null?new Yi(r):null}_adjustIndex(t,n=0){return t??this.length+n}};function sw(e){return e[Ho]}function nf(e){return e[Ho]||(e[Ho]=[])}function L0(e,t){let n,r=t[e.index];return Dt(r)?n=r:(n=y0(r,t,null,e),t[e.index]=n,Rp(t,n)),H3(n,t,e,r),new P0(n,e,t)}function V3(e,t){let n=e[be],r=n.createComment(""),i=dt(t,e),o=n.parentNode(i);return Ur(n,o,r,n.nextSibling(i),!1),r}var H3=W3,U3=()=>!1;function F0(e,t,n){return U3(e,t,n)}function W3(e,t,n,r){if(e[sr])return;let i;n.type&8?i=$t(r):i=V3(t,n),e[sr]=i}var Ff=class e{queryList;matches=null;constructor(t){this.queryList=t}clone(){return new e(this.queryList)}setDirty(){this.queryList.setDirty()}},zf=class e{queries;constructor(t=[]){this.queries=t}createEmbeddedView(t){let n=t.queries;if(n!==null){let r=t.contentQueries!==null?t.contentQueries[0]:n.length,i=[];for(let o=0;o<r;o++){let s=n.getByIndex(o),a=this.queries[s.indexInDeclarationView];i.push(a.clone())}return new e(i)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}finishViewCreation(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let n=0;n<this.queries.length;n++)Zp(t,n).matches!==null&&this.queries[n].setDirty()}},Ou=class{flags;read;predicate;constructor(t,n,r=null){this.flags=n,this.read=r,typeof t=="string"?this.predicate=Z3(t):this.predicate=t}},Bf=class e{queries;constructor(t=[]){this.queries=t}elementStart(t,n){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,n)}elementEnd(t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementEnd(t)}embeddedTView(t){let n=null;for(let r=0;r<this.length;r++){let i=n!==null?n.length:0,o=this.getByIndex(r).embeddedTView(t,i);o&&(o.indexInDeclarationView=r,n!==null?n.push(o):n=[o])}return n!==null?new e(n):null}template(t,n){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,n)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}},jf=class e{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(t,n=-1){this.metadata=t,this._declarationNodeIndex=n}elementStart(t,n){this.isApplyingToNode(n)&&this.matchTNode(t,n)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,n){this.elementStart(t,n)}embeddedTView(t,n){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,n),new e(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let n=this._declarationNodeIndex,r=t.parent;for(;r!==null&&r.type&8&&r.index!==n;)r=r.parent;return n===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(t,n){let r=this.metadata.predicate;if(Array.isArray(r))for(let i=0;i<r.length;i++){let o=r[i];this.matchTNodeWithReadOption(t,n,q3(n,o)),this.matchTNodeWithReadOption(t,n,du(n,t,o,!1,!1))}else r===Ji?n.type&4&&this.matchTNodeWithReadOption(t,n,-1):this.matchTNodeWithReadOption(t,n,du(n,t,r,!1,!1))}matchTNodeWithReadOption(t,n,r){if(r!==null){let i=this.metadata.read;if(i!==null)if(i===Zi||i===ds||i===Ji&&n.type&4)this.addMatch(n.index,-2);else{let o=du(n,t,i,!1,!1);o!==null&&this.addMatch(n.index,o)}else this.addMatch(n.index,r)}}addMatch(t,n){this.matches===null?this.matches=[t,n]:this.matches.push(t,n)}};function q3(e,t){let n=e.localNames;if(n!==null){for(let r=0;r<n.length;r+=2)if(n[r]===t)return n[r+1]}return null}function G3(e,t){return e.type&11?oo(e,t):e.type&4?ul(e,t):null}function K3(e,t,n,r){return n===-1?G3(t,e):n===-2?Q3(e,t,r):is(e,e[U],n,t)}function Q3(e,t,n){if(n===Zi)return oo(t,e);if(n===Ji)return ul(t,e);if(n===ds)return L0(t,e)}function z0(e,t,n,r){let i=t[xn].queries[r];if(i.matches===null){let o=e.data,s=n.matches,a=[];for(let u=0;s!==null&&u<s.length;u+=2){let c=s[u];if(c<0)a.push(null);else{let d=o[c];a.push(K3(t,d,s[u+1],n.metadata.read))}}i.matches=a}return i.matches}function Vf(e,t,n,r){let i=e.queries.getByIndex(n),o=i.matches;if(o!==null){let s=z0(e,t,i,n);for(let a=0;a<o.length;a+=2){let u=o[a];if(u>0)r.push(s[a/2]);else{let c=o[a+1],d=t[-u];for(let p=Ke;p<d.length;p++){let h=d[p];h[jn]===h[qe]&&Vf(h[U],h,c,r)}if(d[Lr]!==null){let p=d[Lr];for(let h=0;h<p.length;h++){let g=p[h];Vf(g[U],g,c,r)}}}}}return r}function Qp(e,t){return e[xn].queries[t].queryList}function B0(e,t,n){let r=new wf((n&4)===4);return s_(e,t,r,r.destroy),(t[xn]??=new zf).queries.push(new Ff(r))-1}function j0(e,t,n){let r=Ie();return r.firstCreatePass&&(H0(r,new Ou(e,t,n),-1),(t&2)===2&&(r.staticViewQueries=!0)),B0(r,P(),t)}function V0(e,t,n,r){let i=Ie();if(i.firstCreatePass){let o=ge();H0(i,new Ou(t,n,r),o.index),Y3(i,e),(n&2)===2&&(i.staticContentQueries=!0)}return B0(i,P(),n)}function Z3(e){return e.split(",").map(t=>t.trim())}function H0(e,t,n){e.queries===null&&(e.queries=new Bf),e.queries.track(new jf(t,n))}function Y3(e,t){let n=e.contentQueries||(e.contentQueries=[]),r=n.length?n[n.length-1]:-1;t!==r&&n.push(e.queries.length-1,t)}function Zp(e,t){return e.queries.getByIndex(t)}function U0(e,t){let n=e[U],r=Zp(n,t);return r.crossesNgTemplate?Vf(n,e,t,[]):z0(n,e,r,t)}function W0(e,t,n){let r,i=va(()=>{r._dirtyCounter();let o=J3(r,e);if(t&&o===void 0)throw new ie(-951,!1);return o});return r=i[it],r._dirtyCounter=Hd(0),r._flatValue=void 0,i}function Yp(e){return W0(!0,!1,e)}function Jp(e){return W0(!0,!0,e)}function q0(e,t){let n=e[it];n._lView=P(),n._queryIndex=t,n._queryList=Qp(n._lView,t),n._queryList.onDirty(()=>n._dirtyCounter.update(r=>r+1))}function J3(e,t){let n=e._lView,r=e._queryIndex;if(n===void 0||r===void 0||n[le]&4)return t?void 0:Ne;let i=Qp(n,r),o=U0(n,r);return i.reset(o,ab),t?i.first:i._changesDetected||e._flatValue===void 0?e._flatValue=i.toArray():e._flatValue}function G0(e){let t=[],n=new Map;function r(i){let o=n.get(i);if(!o){let s=e(i);n.set(i,o=s.then(a=>tP(i,a)))}return o}return fs.forEach((i,o)=>{let s=[];i.templateUrl&&s.push(r(i.templateUrl).then(c=>{i.template=c}));let a=typeof i.styles=="string"?[i.styles]:i.styles||[];if(i.styles=a,i.styleUrl&&i.styleUrls?.length)throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");if(i.styleUrls?.length){let c=i.styles.length,d=i.styleUrls;i.styleUrls.forEach((p,h)=>{a.push(""),s.push(r(p).then(g=>{a[c+h]=g,d.splice(d.indexOf(p),1),d.length==0&&(i.styleUrls=void 0)}))})}else i.styleUrl&&s.push(r(i.styleUrl).then(c=>{a.push(c),i.styleUrl=void 0}));let u=Promise.all(s).then(()=>nP(o));t.push(u)}),eP(),Promise.all(t).then(()=>{})}var fs=new Map,K0=new Set;function X3(e,t){Q0(t)&&(fs.set(e,t),K0.add(e))}function Q0(e){return!!(e.templateUrl&&!e.hasOwnProperty("template")||e.styleUrls&&e.styleUrls.length||e.styleUrl)}function eP(){let e=fs;return fs=new Map,e}function Z0(){return fs.size===0}function tP(e,t){return typeof t=="string"?t:t.status!==void 0&&t.status!==200?Promise.reject(new ie(918,!1)):t.text()}function nP(e){K0.delete(e)}var aw=new Map,rP=!0;function iP(e,t,n){if(t&&t!==n&&rP)throw new Error(`Duplicate module registered for ${e} - ${Jt(t)} vs ${Jt(t.name)}`)}function Y0(e,t){let n=aw.get(t)||null;iP(t,n,e),aw.set(t,e)}function oP(e,t,n){let r=P(),i=sn(),o=dt(i,r);if(i.type===2&&t.toLowerCase()==="iframe"){let s=o;s.src="",s.srcdoc=so(""),Es(r[be],s);let a=!1;throw new ie(-910,a)}return e}var uw=new Set;function Mt(e){uw.has(e)||(uw.add(e),performance?.mark?.("mark_feature_usage",{detail:{feature:e}}))}var ps=class{},sP=class{};var Pu=class extends ps{ngModuleType;_parent;_bootstrapComponents=[];_r3Injector;instance;destroyCbs=[];componentFactoryResolver=new Ru(this);constructor(t,n,r,i=!0){super(),this.ngModuleType=t,this._parent=n;let o=Ar(t);this._bootstrapComponents=ji(o.bootstrap),this._r3Injector=Vd(t,n,[{provide:ps,useValue:this},{provide:dl,useValue:this.componentFactoryResolver},...r],Jt(t),new Set(["environment"])),i&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){let t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(n=>n()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}},hs=class extends sP{moduleType;constructor(t){super(),this.moduleType=t}create(t){return new Pu(this.moduleType,t,[])}};function J0(e,t,n){return new Pu(e,t,n,!1)}var Lu=class extends ps{injector;componentFactoryResolver=new Ru(this);instance=null;constructor(t){super();let n=new Ei([...t.providers,{provide:ps,useValue:this},{provide:dl,useValue:this.componentFactoryResolver}],t.parent||Bo(),t.debugName,new Set(["environment"]));this.injector=n,t.runEnvironmentInitializers&&n.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}};function X0(e,t,n=null){return new Lu({providers:e,parent:t,debugName:n,runEnvironmentInitializers:!0}).injector}var Hf=class e{_injector;cachedInjectors=new Map;constructor(t){this._injector=t}getOrCreateStandaloneInjector(t){if(!t.standalone)return null;if(!this.cachedInjectors.has(t)){let n=za(!1,t.type),r=n.length>0?X0([n],this._injector,`Standalone[${t.type.name}]`):null;this.cachedInjectors.set(t,r)}return this.cachedInjectors.get(t)}ngOnDestroy(){try{for(let t of this.cachedInjectors.values())t!==null&&t.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=Ae({token:e,providedIn:"environment",factory:()=>new e(mt(Vt))})};function aP(e){return gr(()=>{let t=nI(e),n={...t,decls:e.decls,vars:e.vars,template:e.template,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,onPush:e.changeDetection===Eu.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&e.dependencies||null,getStandaloneInjector:t.standalone?i=>i.get(Hf).getOrCreateStandaloneInjector(n):null,getExternalStyles:null,signals:e.signals??!1,data:e.data||{},encapsulation:e.encapsulation||Un.Emulated,styles:e.styles||Ne,_:null,schemas:e.schemas||null,tView:null,id:""};t.standalone&&Mt("NgStandalone"),rI(n);let r=e.dependencies;return n.directiveDefs=Fu(r,eI),n.pipeDefs=Fu(r,rn),n.id=fP(n),n})}function eI(e){return Ge(e)||Rt(e)}function tI(e){return gr(()=>({type:e.type,bootstrap:e.bootstrap||Ne,declarations:e.declarations||Ne,imports:e.imports||Ne,exports:e.exports||Ne,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null}))}function uP(e,t){if(e==null)return Wt;let n={};for(let r in e)if(e.hasOwnProperty(r)){let i=e[r],o,s,a,u;Array.isArray(i)?(a=i[0],o=i[1],s=i[2]??o,u=i[3]||null):(o=i,s=i,a=as.None,u=null),n[o]=[r,a,u],t[o]=s}return n}function lP(e){if(e==null)return Wt;let t={};for(let n in e)e.hasOwnProperty(n)&&(t[e[n]]=n);return t}function cP(e){return gr(()=>{let t=nI(e);return rI(t),t})}function dP(e){return{type:e.type,name:e.name,factory:null,pure:e.pure!==!1,standalone:e.standalone??!0,onDestroy:e.type.prototype.ngOnDestroy||null}}function nI(e){let t={};return{type:e.type,providersResolver:null,factory:null,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputConfig:e.inputs||Wt,exportAs:e.exportAs||null,standalone:e.standalone??!0,signals:e.signals===!0,selectors:e.selectors||Ne,viewQuery:e.viewQuery||null,features:e.features||null,setInput:null,resolveHostDirectives:null,hostDirectives:null,inputs:uP(e.inputs,t),outputs:lP(e.outputs),debugInfo:null}}function rI(e){e.features?.forEach(t=>t(e))}function Fu(e,t){return e?()=>{let n=typeof e=="function"?e():e,r=[];for(let i of n){let o=t(i);o!==null&&r.push(o)}return r}:null}function fP(e){let t=0,n=typeof e.consts=="function"?"":e.consts,r=[e.selectors,e.ngContentSelectors,e.hostVars,e.hostAttrs,n,e.vars,e.decls,e.encapsulation,e.standalone,e.signals,e.exportAs,JSON.stringify(e.inputs),JSON.stringify(e.outputs),Object.getOwnPropertyNames(e.type.prototype),!!e.contentQueries,!!e.viewQuery];for(let o of r.join("|"))t=Math.imul(31,t)+o.charCodeAt(0)<<0;return t+=2147483648,"c"+t}function iI(e){return Object.getPrototypeOf(e.prototype).constructor}function oI(e){let t=iI(e.type),n=!0,r=[e];for(;t;){let i;if(St(e))i=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new ie(903,!1);i=t.\u0275dir}if(i){if(n){r.push(i);let s=e;s.inputs=rf(e.inputs),s.declaredInputs=rf(e.declaredInputs),s.outputs=rf(e.outputs);let a=i.hostBindings;a&&yP(e,a);let u=i.viewQuery,c=i.contentQueries;if(u&&mP(e,u),c&&gP(e,c),pP(e,i),qv(e.outputs,i.outputs),St(i)&&i.data.animation){let d=e.data;d.animation=(d.animation||[]).concat(i.data.animation)}}let o=i.features;if(o)for(let s=0;s<o.length;s++){let a=o[s];a&&a.ngInherit&&a(e),a===oI&&(n=!1)}}t=Object.getPrototypeOf(t)}hP(r)}function pP(e,t){for(let n in t.inputs){if(!t.inputs.hasOwnProperty(n)||e.inputs.hasOwnProperty(n))continue;let r=t.inputs[n];r!==void 0&&(e.inputs[n]=r,e.declaredInputs[n]=t.declaredInputs[n])}}function hP(e){let t=0,n=null;for(let r=e.length-1;r>=0;r--){let i=e[r];i.hostVars=t+=i.hostVars,i.hostAttrs=Qi(i.hostAttrs,n=Qi(n,i.hostAttrs))}}function rf(e){return e===Wt?{}:e===Ne?[]:e}function mP(e,t){let n=e.viewQuery;n?e.viewQuery=(r,i)=>{t(r,i),n(r,i)}:e.viewQuery=t}function gP(e,t){let n=e.contentQueries;n?e.contentQueries=(r,i,o)=>{t(r,i,o),n(r,i,o)}:e.contentQueries=t}function yP(e,t){let n=e.hostBindings;n?e.hostBindings=(r,i)=>{t(r,i),n(r,i)}:e.hostBindings=t}var vP=["providersResolver"],_P=["template","decls","consts","vars","onPush","ngContentSelectors","styles","encapsulation","schemas"];function wP(e){let t=iI(e.type),n;St(e)?n=t.\u0275cmp:n=t.\u0275dir;let r=e;for(let i of vP)r[i]=n[i];if(St(n))for(let i of _P)r[i]=n[i]}function bP(e){let t=n=>{let r=Array.isArray(e);n.hostDirectives===null?(n.resolveHostDirectives=IP,n.hostDirectives=r?e.map(Uf):[e]):r?n.hostDirectives.unshift(...e.map(Uf)):n.hostDirectives.unshift(e)};return t.ngInherit=!0,t}function IP(e){let t=[],n=!1,r=null,i=null;for(let o=0;o<e.length;o++){let s=e[o];if(s.hostDirectives!==null){let a=t.length;r??=new Map,i??=new Map,sI(s,t,r),i.set(s,[a,t.length-1])}o===0&&St(s)&&(n=!0,t.push(s))}for(let o=n?1:0;o<e.length;o++)t.push(e[o]);return[t,r,i]}function sI(e,t,n){if(e.hostDirectives!==null)for(let r of e.hostDirectives)if(typeof r=="function"){let i=r();for(let o of i)lw(Uf(o),t,n)}else lw(r,t,n)}function lw(e,t,n){let r=Rt(e.directive);xP(r.declaredInputs,e.inputs),sI(r,t,n),n.set(r,e),t.push(r)}function Uf(e){return typeof e=="function"?{directive:Se(e),inputs:Wt,outputs:Wt}:{directive:Se(e.directive),inputs:cw(e.inputs),outputs:cw(e.outputs)}}function cw(e){if(e===void 0||e.length===0)return Wt;let t={};for(let n=0;n<e.length;n+=2)t[e[n]]=e[n+1];return t}function xP(e,t){for(let n in t)if(t.hasOwnProperty(n)){let r=t[n],i=e[n];e[r]=i}}function aI(e,t,n,r,i,o,s,a){if(n.firstCreatePass){e.mergedAttrs=Qi(e.mergedAttrs,e.attrs);let d=e.tView=kp(2,e,i,o,s,n.directiveRegistry,n.pipeRegistry,null,n.schemas,n.consts,null);n.queries!==null&&(n.queries.template(n,e),d.queries=n.queries.embeddedTView(e))}a&&(e.flags|=a),Dn(e,!1);let u=TP(n,t,e,r);Go()&&Lp(n,t,u,e),mr(u,t);let c=y0(u,t,u,e);t[r+me]=c,Rp(t,c),F0(c,e,t)}function EP(e,t,n,r,i,o,s,a,u,c,d){let p=n+me,h;return t.firstCreatePass?(h=Zr(t,p,4,s||null,a||null),qa()&&M0(t,e,h,ft(t.consts,c),jp),Gw(t,h)):h=t.data[p],aI(h,e,t,n,r,i,o,u),Ni(h)&&tl(t,e,h),c!=null&&ao(e,h,d),h}function Gr(e,t,n,r,i,o,s,a,u,c,d){let p=n+me,h;if(t.firstCreatePass){if(h=Zr(t,p,4,s||null,a||null),c!=null){let g=ft(t.consts,c);h.localNames=[];for(let y=0;y<g.length;y+=2)h.localNames.push(g[y],-1)}}else h=t.data[p];return aI(h,e,t,n,r,i,o,u),c!=null&&ao(e,h,d),h}function uI(e,t,n,r,i,o,s,a){let u=P(),c=Ie(),d=ft(c.consts,o);return EP(u,c,e,t,n,r,i,d,void 0,s,a),uI}function lI(e,t,n,r,i,o,s,a){let u=P(),c=Ie(),d=ft(c.consts,o);return Gr(u,c,e,t,n,r,i,d,void 0,s,a),lI}var TP=CP;function CP(e,t,n,r){return Ai(!0),t[be].createComment("")}var et;(function(e){e[e.NOT_STARTED=0]="NOT_STARTED",e[e.IN_PROGRESS=1]="IN_PROGRESS",e[e.COMPLETE=2]="COMPLETE",e[e.FAILED=3]="FAILED"})(et||(et={}));var dw=0,DP=1,je;(function(e){e[e.Placeholder=0]="Placeholder",e[e.Loading=1]="Loading",e[e.Complete=2]="Complete",e[e.Error=3]="Error"})(je||(je={}));var eo;(function(e){e[e.Initial=-1]="Initial"})(eo||(eo={}));var qi=0,Yr=1,Zo=2,ou=3,SP=4,$P=5,hl=6,MP=7,Gi=8,NP=9,Wf;(function(e){e[e.Manual=0]="Manual",e[e.Playthrough=1]="Playthrough"})(Wf||(Wf={}));function Ms(e,t,n){let r=dI(e);t[r]===null&&(t[r]=[]),t[r].push(n)}function pu(e,t){let n=dI(e),r=t[n];if(r!==null){for(let i of r)i();t[n]=null}}function cI(e){pu(1,e),pu(0,e),pu(2,e)}function dI(e){let t=SP;return e===1?t=$P:e===2&&(t=NP),t}var zu;(function(e){e[e.CHANGE_DETECTION=0]="CHANGE_DETECTION",e[e.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER"})(zu||(zu={}));var Ns=new ne(""),fI=!1,qf=class extends Yt{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(t=!1){super(),this.__isAsync=t,yd()&&(this.destroyRef=re(Xt,{optional:!0})??void 0,this.pendingTasks=re(en,{optional:!0})??void 0)}emit(t){let n=ae(null);try{super.next(t)}finally{ae(n)}}subscribe(t,n,r){let i=t,o=n||(()=>null),s=r;if(t&&typeof t=="object"){let u=t;i=u.next?.bind(u),o=u.error?.bind(u),s=u.complete?.bind(u)}this.__isAsync&&(o=this.wrapInTimeout(o),i&&(i=this.wrapInTimeout(i)),s&&(s=this.wrapInTimeout(s)));let a=super.subscribe({next:i,error:o,complete:s});return t instanceof _t&&t.add(a),a}wrapInTimeout(t){return n=>{let r=this.pendingTasks?.add();setTimeout(()=>{try{t(n)}finally{r!==void 0&&this.pendingTasks?.remove(r)}})}}},pr=qf;function pI(e){let t,n;function r(){e=Ri;try{n!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(n),t!==void 0&&clearTimeout(t)}catch{}}return t=setTimeout(()=>{e(),r()}),typeof requestAnimationFrame=="function"&&(n=requestAnimationFrame(()=>{e(),r()})),()=>r()}function fw(e){return queueMicrotask(()=>e()),()=>{e=Ri}}var Xp="isAngularZone",Bu=Xp+"_ID",kP=0,Ve=class e{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new pr(!1);onMicrotaskEmpty=new pr(!1);onStable=new pr(!1);onError=new pr(!1);constructor(t){let{enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:i=!1,scheduleInRootZone:o=fI}=t;if(typeof Zone>"u")throw new ie(908,!1);Zone.assertZonePatched();let s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!i&&r,s.shouldCoalesceRunChangeDetection=i,s.callbackScheduled=!1,s.scheduleInRootZone=o,OP(s)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(Xp)===!0}static assertInAngularZone(){if(!e.isInAngularZone())throw new ie(909,!1)}static assertNotInAngularZone(){if(e.isInAngularZone())throw new ie(909,!1)}run(t,n,r){return this._inner.run(t,n,r)}runTask(t,n,r,i){let o=this._inner,s=o.scheduleEventTask("NgZoneEvent: "+i,t,AP,Ri,Ri);try{return o.runTask(s,n,r)}finally{o.cancelTask(s)}}runGuarded(t,n,r){return this._inner.runGuarded(t,n,r)}runOutsideAngular(t){return this._outer.run(t)}},AP={};function eh(e){if(e._nesting==0&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function RP(e){if(e.isCheckStableRunning||e.callbackScheduled)return;e.callbackScheduled=!0;function t(){pI(()=>{e.callbackScheduled=!1,Gf(e),e.isCheckStableRunning=!0,eh(e),e.isCheckStableRunning=!1})}e.scheduleInRootZone?Zone.root.run(()=>{t()}):e._outer.run(()=>{t()}),Gf(e)}function OP(e){let t=()=>{RP(e)},n=kP++;e._inner=e._inner.fork({name:"angular",properties:{[Xp]:!0,[Bu]:n,[Bu+n]:!0},onInvokeTask:(r,i,o,s,a,u)=>{if(PP(u))return r.invokeTask(o,s,a,u);try{return pw(e),r.invokeTask(o,s,a,u)}finally{(e.shouldCoalesceEventChangeDetection&&s.type==="eventTask"||e.shouldCoalesceRunChangeDetection)&&t(),hw(e)}},onInvoke:(r,i,o,s,a,u,c)=>{try{return pw(e),r.invoke(o,s,a,u,c)}finally{e.shouldCoalesceRunChangeDetection&&!e.callbackScheduled&&!LP(u)&&t(),hw(e)}},onHasTask:(r,i,o,s)=>{r.hasTask(o,s),i===o&&(s.change=="microTask"?(e._hasPendingMicrotasks=s.microTask,Gf(e),eh(e)):s.change=="macroTask"&&(e.hasPendingMacrotasks=s.macroTask))},onHandleError:(r,i,o,s)=>(r.handleError(o,s),e.runOutsideAngular(()=>e.onError.emit(s)),!1)})}function Gf(e){e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&e.callbackScheduled===!0?e.hasPendingMicrotasks=!0:e.hasPendingMicrotasks=!1}function pw(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function hw(e){e._nesting--,eh(e)}var ju=class{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new pr;onMicrotaskEmpty=new pr;onStable=new pr;onError=new pr;run(t,n,r){return t.apply(n,r)}runGuarded(t,n,r){return t.apply(n,r)}runOutsideAngular(t){return t()}runTask(t,n,r,i){return t.apply(n,r)}};function PP(e){return hI(e,"__ignore_ng_zone__")}function LP(e){return hI(e,"__scheduler_tick__")}function hI(e,t){return!Array.isArray(e)||e.length!==1?!1:e[0]?.data?.[t]===!0}function mI(e="zone.js",t){return e==="noop"?new ju:e==="zone.js"?new Ve(t):e}var ms=class e{impl=null;execute(){this.impl?.execute()}static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new e})},gI=[0,1,2,3],Vu=class e{ngZone=re(Ve);scheduler=re(In);errorHandler=re(bn,{optional:!0});sequences=new Set;deferredRegistrations=new Set;executing=!1;constructor(){re(Ns,{optional:!0})}execute(){let t=this.sequences.size>0;t&&Oe(16),this.executing=!0;for(let n of gI)for(let r of this.sequences)if(!(r.erroredOrDestroyed||!r.hooks[n]))try{r.pipelinedValue=this.ngZone.runOutsideAngular(()=>this.maybeTrace(()=>{let i=r.hooks[n];return i(r.pipelinedValue)},r.snapshot))}catch(i){r.erroredOrDestroyed=!0,this.errorHandler?.handleError(i)}this.executing=!1;for(let n of this.sequences)n.afterRun(),n.once&&(this.sequences.delete(n),n.destroy());for(let n of this.deferredRegistrations)this.sequences.add(n);this.deferredRegistrations.size>0&&this.scheduler.notify(7),this.deferredRegistrations.clear(),t&&Oe(17)}register(t){let{view:n}=t;n!==void 0?((n[Pr]??=[]).push(t),zr(n),n[le]|=8192):this.executing?this.deferredRegistrations.add(t):this.addSequence(t)}addSequence(t){this.sequences.add(t),this.scheduler.notify(7)}unregister(t){this.executing&&this.sequences.has(t)?(t.erroredOrDestroyed=!0,t.pipelinedValue=void 0,t.once=!0):(this.sequences.delete(t),this.deferredRegistrations.delete(t))}maybeTrace(t,n){return n?n.run(zu.AFTER_NEXT_RENDER,t):t()}static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new e})},Hu=class{impl;hooks;view;once;snapshot;erroredOrDestroyed=!1;pipelinedValue=void 0;unregisterOnDestroy;constructor(t,n,r,i,o,s=null){this.impl=t,this.hooks=n,this.view=r,this.once=i,this.snapshot=s,this.unregisterOnDestroy=o?.onDestroy(()=>this.destroy())}afterRun(){this.erroredOrDestroyed=!1,this.pipelinedValue=void 0,this.snapshot?.dispose(),this.snapshot=null}destroy(){this.impl.unregister(this),this.unregisterOnDestroy?.();let t=this.view?.[Pr];t&&(this.view[Pr]=t.filter(n=>n!==this))}};function yI(e,t){let n=t?.injector??re(Ht);return Mt("NgAfterRender"),vI(e,n,t,!1)}function FP(e,t){let n=t?.injector??re(Ht);return Mt("NgAfterNextRender"),vI(e,n,t,!0)}function zP(e){return e instanceof Function?[void 0,void 0,e,void 0]:[e.earlyRead,e.write,e.mixedReadWrite,e.read]}function vI(e,t,n,r){let i=t.get(ms);i.impl??=t.get(Vu);let o=t.get(Ns,null,{optional:!0}),s=n?.manualCleanup!==!0?t.get(Xt):null,a=t.get(Mr,null,{optional:!0}),u=new Hu(i.impl,zP(e),a?.view,r,s,o?.snapshot(null));return i.impl.register(u),u}function ml(e){return e+1}function Nt(e,t){let n=e[U],r=ml(t.index);return e[r]}function BP(e,t,n){let r=e[U],i=ml(t);e[i]=n}function xt(e,t){let n=ml(t.index);return e.data[n]}function jP(e,t,n){let r=ml(t);e.data[r]=n}function VP(e,t,n){let r=t[U],i=xt(r,n);switch(e){case je.Complete:return i.primaryTmplIndex;case je.Loading:return i.loadingTmplIndex;case je.Error:return i.errorTmplIndex;case je.Placeholder:return i.placeholderTmplIndex;default:return null}}function Kf(e,t){return t===je.Placeholder?e.placeholderBlockConfig?.[dw]??null:t===je.Loading?e.loadingBlockConfig?.[dw]??null:null}function _I(e){return e.loadingBlockConfig?.[DP]??null}function mw(e,t){if(!e||e.length===0)return t;let n=new Set(e);for(let r of t)n.add(r);return e.length===n.size?e:Array.from(n)}function HP(e,t){let n=t.primaryTmplIndex+me;return lr(e,n)}function wI(e,t,n){let r=n.get(Ve);return tR(e,()=>r.run(t),()=>r.runOutsideAngular(()=>eR()))}function UP(e,t,n){return n==null?e:n>=0?Cd(n,e):e[t.index][Ke]??null}function WP(e,t){return Fr(me+t,e)}function co(e,t,n,r,i,o,s){let a=e[Re],u=a.get(Ve),c;function d(){if(Tn(e)){c.destroy();return}let p=Nt(e,t),h=p[Yr];if(h!==eo.Initial&&h!==je.Placeholder){c.destroy();return}let g=UP(e,t,r);if(!g||(c.destroy(),Tn(g)))return;let y=WP(g,n),w=i(y,()=>{u.run(()=>{e!==g&&Wa(g,w),o()})},a);e!==g&&Wo(g,w),Ms(s,p,w)}c=yI({read:d},{injector:a})}function th(e,t){let n=t.get(Qf),r=()=>n.remove(e);return n.add(e),r}var qP=()=>typeof requestIdleCallback<"u"?requestIdleCallback:setTimeout,GP=()=>typeof requestIdleCallback<"u"?cancelIdleCallback:clearTimeout,Qf=class e{executingCallbacks=!1;idleId=null;current=new Set;deferred=new Set;ngZone=re(Ve);requestIdleCallbackFn=qP().bind(globalThis);cancelIdleCallbackFn=GP().bind(globalThis);add(t){(this.executingCallbacks?this.deferred:this.current).add(t),this.idleId===null&&this.scheduleIdleCallback()}remove(t){let{current:n,deferred:r}=this;n.delete(t),r.delete(t),n.size===0&&r.size===0&&this.cancelIdleCallback()}scheduleIdleCallback(){let t=()=>{this.cancelIdleCallback(),this.executingCallbacks=!0;for(let n of this.current)n();if(this.current.clear(),this.executingCallbacks=!1,this.deferred.size>0){for(let n of this.deferred)this.current.add(n);this.deferred.clear(),this.scheduleIdleCallback()}};this.idleId=this.requestIdleCallbackFn(()=>this.ngZone.run(t))}cancelIdleCallback(){this.idleId!==null&&(this.cancelIdleCallbackFn(this.idleId),this.idleId=null)}ngOnDestroy(){this.cancelIdleCallback(),this.current.clear(),this.deferred.clear()}static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new e})};function nh(e){return(t,n)=>bI(e,t,n)}function bI(e,t,n){let r=n.get(Zf),i=n.get(Ve),o=()=>r.remove(t);return r.add(e,t,i),o}var Zf=class e{executingCallbacks=!1;timeoutId=null;invokeTimerAt=null;current=[];deferred=[];add(t,n,r){let i=this.executingCallbacks?this.deferred:this.current;this.addToQueue(i,Date.now()+t,n),this.scheduleTimer(r)}remove(t){let{current:n,deferred:r}=this;this.removeFromQueue(n,t)===-1&&this.removeFromQueue(r,t),n.length===0&&r.length===0&&this.clearTimeout()}addToQueue(t,n,r){let i=t.length;for(let o=0;o<t.length;o+=2)if(t[o]>n){i=o;break}fd(t,i,n,r)}removeFromQueue(t,n){let r=-1;for(let i=0;i<t.length;i+=2)if(t[i+1]===n){r=i;break}return r>-1&&dd(t,r,2),r}scheduleTimer(t){let n=()=>{this.clearTimeout(),this.executingCallbacks=!0;let i=[...this.current],o=Date.now();for(let a=0;a<i.length;a+=2){let u=i[a],c=i[a+1];if(u<=o)c();else break}let s=-1;for(let a=0;a<this.current.length&&this.current[a]<=o;a+=2)s=a+1;if(s>=0&&dd(this.current,0,s+1),this.executingCallbacks=!1,this.deferred.length>0){for(let a=0;a<this.deferred.length;a+=2){let u=this.deferred[a],c=this.deferred[a+1];this.addToQueue(this.current,u,c)}this.deferred.length=0}this.scheduleTimer(t)};if(this.current.length>0){let i=Date.now(),o=this.current[0];if(this.timeoutId===null||this.invokeTimerAt&&this.invokeTimerAt-o>16){this.clearTimeout();let s=Math.max(o-i,16);this.invokeTimerAt=o,this.timeoutId=t.runOutsideAngular(()=>setTimeout(()=>t.run(n),s))}}}clearTimeout(){this.timeoutId!==null&&(clearTimeout(this.timeoutId),this.timeoutId=null)}ngOnDestroy(){this.clearTimeout(),this.current.length=0,this.deferred.length=0}static \u0275prov=Ae({token:e,providedIn:"root",factory:()=>new e})},Yf=class e{cachedInjectors=new Map;getOrCreateInjector(t,n,r,i){if(!this.cachedInjectors.has(t)){let o=r.length>0?X0(r,n,i):null;this.cachedInjectors.set(t,o)}return this.cachedInjectors.get(t)}ngOnDestroy(){try{for(let t of this.cachedInjectors.values())t!==null&&t.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=Ae({token:e,providedIn:"environment",factory:()=>new e})};var KP=new ne("");function of(e,t,n){return e.get(Yf).getOrCreateInjector(t,e,n,"")}function QP(e,t,n){if(e instanceof Wi){let i=e.injector,o=e.parentInjector,s=of(o,t,n);return new Wi(i,s)}let r=e.get(Vt);if(r!==e){let i=of(r,t,n);return new Wi(e,i)}return of(e,t,n)}function hr(e,t,n,r=!1){let i=n[qe],o=i[U];if(Tn(i))return;let s=Nt(i,t),a=s[Yr],u=s[MP];if(!(u!==null&&e<u)&&yw(a,e)&&yw(s[qi]??-1,e)){let c=xt(o,t),p=!r&&!0&&(_I(c)!==null||Kf(c,je.Loading)!==null||Kf(c,je.Placeholder))?Jf:II;try{p(e,s,n,t,i)}catch(h){Vp(i,h)}}}function ZP(e,t){let n=e[Vn]?.findIndex(i=>i.data[Tp]===t[Yr])??-1;return{dehydratedView:n>-1?e[Vn][n]:null,dehydratedViewIx:n}}function II(e,t,n,r,i){Oe(20);let o=VP(e,i,r);if(o!==null){t[Yr]=e;let s=i[U],a=o+me,u=lr(s,a),c=0;Hp(n,c);let d;if(e===je.Complete){let y=xt(s,r),w=y.providers;w&&w.length>0&&(d=QP(i[Re],y,w))}let{dehydratedView:p,dehydratedViewIx:h}=ZP(n,t),g=uo(i,u,null,{injector:d,dehydratedView:p});if(lo(n,g,c,Wr(u,p)),al(g,2),h>-1&&n[Vn]?.splice(h,1),(e===je.Complete||e===je.Error)&&Array.isArray(t[Gi])){for(let y of t[Gi])y();t[Gi]=null}}Oe(21)}function YP(e,t,n,r,i){let o=Date.now(),s=i[U],a=xt(s,r);if(t[Zo]===null||t[Zo]<=o){t[Zo]=null;let u=_I(a),c=t[ou]!==null;if(e===je.Loading&&u!==null&&!c){t[qi]=e;let d=gw(u,t,r,n,i);t[ou]=d}else{e>je.Loading&&c&&(t[ou](),t[ou]=null,t[qi]=null),II(e,t,n,r,i);let d=Kf(a,e);d!==null&&(t[Zo]=o+d,gw(d,t,r,n,i))}}else t[qi]=e}function gw(e,t,n,r,i){return bI(e,()=>{let s=t[qi];t[Zo]=null,t[qi]=null,s!==null&&hr(s,n,r)},i[Re])}function yw(e,t){return e<t}function fo(e,t){let n=e[t.index];hr(je.Placeholder,t,n)}function vw(e,t,n){e.loadingPromise.then(()=>{e.loadingState===et.COMPLETE?hr(je.Complete,t,n):e.loadingState===et.FAILED&&hr(je.Error,t,n)})}var Jf=null;function JP(e,t,n,r){let i=e.consts;n!=null&&(t.placeholderBlockConfig=ft(i,n)),r!=null&&(t.loadingBlockConfig=ft(i,r)),Jf===null&&(Jf=YP)}var Xf=class e{log(t){console.log(t)}warn(t){console.warn(t)}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"platform"})},ep=class{resolverToTokenToDependencies=new WeakMap;resolverToProviders=new WeakMap;resolverToEffects=new WeakMap;standaloneInjectorToComponent=new WeakMap;reset(){this.resolverToTokenToDependencies=new WeakMap,this.resolverToProviders=new WeakMap,this.standaloneInjectorToComponent=new WeakMap}},HU=new ep;var XP=new ne(""),eL=new ne(""),_w=class e{_ngZone;registry;_isZoneStable=!0;_callbacks=[];_taskTrackingZone=null;_destroyRef;constructor(t,n,r){this._ngZone=t,this.registry=n,yd()&&(this._destroyRef=re(Xt,{optional:!0})??void 0),rh||(tL(r),r.addToWindow(n)),this._watchAngularEvents(),t.run(()=>{this._taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){let t=this._ngZone.onUnstable.subscribe({next:()=>{this._isZoneStable=!1}}),n=this._ngZone.runOutsideAngular(()=>this._ngZone.onStable.subscribe({next:()=>{Ve.assertNotInAngularZone(),queueMicrotask(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}}));this._destroyRef?.onDestroy(()=>{t.unsubscribe(),n.unsubscribe()})}isStable(){return this._isZoneStable&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())queueMicrotask(()=>{for(;this._callbacks.length!==0;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb()}});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(n=>n.updateCb&&n.updateCb(t)?(clearTimeout(n.timeoutId),!1):!0)}}getPendingTasks(){return this._taskTrackingZone?this._taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,n,r){let i=-1;n&&n>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),t()},n)),this._callbacks.push({doneCb:t,timeoutId:i,updateCb:r})}whenStable(t,n,r){if(r&&!this._taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(t,n,r),this._runCallbacksIfReady()}registerApplication(t){this.registry.registerApplication(t,this)}unregisterApplication(t){this.registry.unregisterApplication(t)}findProviders(t,n,r){return[]}static \u0275fac=function(n){return new(n||e)(mt(Ve),mt(tp),mt(eL))};static \u0275prov=Ae({token:e,factory:e.\u0275fac})},tp=class e{_applications=new Map;registerApplication(t,n){this._applications.set(t,n)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,n=!0){return rh?.findTestabilityInTree(this,t,n)??null}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"platform"})};function tL(e){rh=e}var rh;function ih(e){return!!e&&typeof e.then=="function"}function nL(e){return!!e&&typeof e.subscribe=="function"}var rL=new ne("");var gs=class e{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((t,n)=>{this.resolve=t,this.reject=n});appInits=re(rL,{optional:!0})??[];injector=re(Ht);constructor(){}runInitializers(){if(this.initialized)return;let t=[];for(let r of this.appInits){let i=Ba(this.injector,r);if(ih(i))t.push(i);else if(nL(i)){let o=new Promise((s,a)=>{i.subscribe({complete:s,error:a})});t.push(o)}}let n=()=>{this.done=!0,this.resolve()};Promise.all(t).then(()=>{n()}).catch(r=>{this.reject(r)}),t.length===0&&n(),this.initialized=!0}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})},xI=new ne("");function EI(){Pc(()=>{let e="";throw new ie(600,e)})}function iL(e){return e.isBoundToModule}var oL=10;function oh(e,t){return Array.isArray(t)?t.reduce(oh,e):{...e,...t}}var Wn=class e{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=re(Mn);afterRenderManager=re(ms);zonelessEnabled=re(Wd);rootEffectScheduler=re(Ro);dirtyFlags=0;tracingSnapshot=null;allTestViews=new Set;autoDetectTestViews=new Set;includeAllTestViews=!1;afterTick=new Yt;get allViews(){return[...(this.includeAllTestViews?this.allTestViews:this.autoDetectTestViews).keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];internalPendingTask=re(en);get isStable(){return this.internalPendingTask.hasPendingTasksObservable.pipe(Wc(t=>!t))}constructor(){re(Ns,{optional:!0})}whenStable(){let t;return new Promise(n=>{t=this.isStable.subscribe({next:r=>{r&&n()}})}).finally(()=>{t.unsubscribe()})}_injector=re(Vt);_rendererFactory=null;get injector(){return this._injector}bootstrap(t,n){return this.bootstrapImpl(t,n)}bootstrapImpl(t,n,r=Ht.NULL){return this._injector.get(Ve).run(()=>{Oe(10);let o=t instanceof $0;if(!this._injector.get(gs).done){let g="";throw new ie(405,g)}let a;o?a=t:a=this._injector.get(dl).resolveComponentFactory(t),this.componentTypes.push(a.componentType);let u=iL(a)?void 0:this._injector.get(ps),c=n||a.selector,d=a.create(r,[],c,u),p=d.location.nativeElement,h=d.injector.get(XP,null);return h?.registerApplication(p),d.onDestroy(()=>{this.detachView(d.hostView),es(this.components,d),h?.unregisterApplication(p)}),this._loadComponent(d),Oe(11,d),d})}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){Oe(12),this.tracingSnapshot!==null?this.tracingSnapshot.run(zu.CHANGE_DETECTION,this.tickImpl):this.tickImpl()}tickImpl=()=>{if(this._runningTick)throw new ie(101,!1);let t=ae(null);try{this._runningTick=!0,this.synchronize()}finally{this._runningTick=!1,this.tracingSnapshot?.dispose(),this.tracingSnapshot=null,ae(t),this.afterTick.next(),Oe(13)}};synchronize(){this._rendererFactory===null&&!this._injector.destroyed&&(this._rendererFactory=this._injector.get(ku,null,{optional:!0}));let t=0;for(;this.dirtyFlags!==0&&t++<oL;)Oe(14),this.synchronizeOnce(),Oe(15)}synchronizeOnce(){this.dirtyFlags&16&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush());let t=!1;if(this.dirtyFlags&7){let n=!!(this.dirtyFlags&1);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView:r}of this.allViews){if(!n&&!Uo(r))continue;let i=n&&!this.zonelessEnabled?0:1;f0(r,i),t=!0}if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),this.dirtyFlags&23)return}t||(this._rendererFactory?.begin?.(),this._rendererFactory?.end?.()),this.dirtyFlags&8&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){if(this.allViews.some(({_lView:t})=>Uo(t))){this.dirtyFlags|=2;return}else this.dirtyFlags&=-8}attachView(t){let n=t;this._views.push(n),n.attachToAppRef(this)}detachView(t){let n=t;es(this._views,n),n.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView);try{this.tick()}catch(r){this.internalErrorHandler(r)}this.components.push(t),this._injector.get(xI,[]).forEach(r=>r(t))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(t=>t()),this._views.slice().forEach(t=>t.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(t){return this._destroyListeners.push(t),()=>es(this._destroyListeners,t)}destroy(){if(this._destroyed)throw new ie(406,!1);let t=this._injector;t.destroy&&!t.destroyed&&t.destroy()}get viewCount(){return this._views.length}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})};function es(e,t){let n=e.indexOf(t);n>-1&&e.splice(n,1)}function sh(){let e,t;return{promise:new Promise((r,i)=>{e=r,t=i}),resolve:e,reject:t}}function TI(e){let t=P(),n=ge();if(fo(t,n),!SI(0,t))return;let r=t[Re],i=Nt(t,n),o=e(()=>Jr(0,t,n),r);Ms(0,i,o)}function CI(e,t){let n=P(),r=n[Re],i=ge(),o=n[U],s=xt(o,i);if(s.loadingState===et.NOT_STARTED){let a=Nt(n,i),c=e(()=>ks(s,n,i),r);Ms(1,a,c)}}function DI(e,t,n){let r=t[Re],i=Nt(t,n),o=i[hl],s=e(()=>gl(r,o),r);Ms(2,i,s)}function ks(e,t,n){ah(e,t,n)}function ah(e,t,n){let r=t[Re],i=t[U];if(e.loadingState!==et.NOT_STARTED)return e.loadingPromise??Promise.resolve();let o=Nt(t,n),s=HP(i,e);e.loadingState=et.IN_PROGRESS,pu(1,o);let a=e.dependencyResolverFn,u=r.get(Ao).add();return a?(e.loadingPromise=Promise.allSettled(a()).then(c=>{let d=!1,p=[],h=[];for(let g of c)if(g.status==="fulfilled"){let y=g.value,w=Ge(y)||Rt(y);if(w)p.push(w);else{let x=rn(y);x&&h.push(x)}}else{d=!0;break}if(d){if(e.loadingState=et.FAILED,e.errorTmplIndex===null){let y=new ie(-750,!1);Vp(t,y)}}else{e.loadingState=et.COMPLETE;let g=s.tView;if(p.length>0){g.directiveRegistry=mw(g.directiveRegistry,p);let y=p.map(x=>x.type),w=za(!1,...y);e.providers=w}h.length>0&&(g.pipeRegistry=mw(g.pipeRegistry,h))}}),e.loadingPromise.finally(()=>{e.loadingPromise=null,u()})):(e.loadingPromise=Promise.resolve().then(()=>{e.loadingPromise=null,e.loadingState=et.COMPLETE,u()}),e.loadingPromise)}function SI(e,t){return t[Re].get(KP,null,{optional:!0})?.behavior!==Wf.Manual}function Jr(e,t,n){let r=t[U],i=t[n.index];if(!SI(e,t))return;let o=Nt(t,n),s=xt(r,n);switch(cI(o),s.loadingState){case et.NOT_STARTED:hr(je.Loading,n,i),ah(s,t,n),s.loadingState===et.IN_PROGRESS&&vw(s,n,i);break;case et.IN_PROGRESS:hr(je.Loading,n,i),vw(s,n,i);break;case et.COMPLETE:hr(je.Complete,n,i);break;case et.FAILED:hr(je.Error,n,i);break;default:}}async function gl(e,t,n){let r=e.get(ws);if(r.hydrating.has(t))return;let{parentBlockPromise:o,hydrationQueue:s}=lR(t,e);if(s.length===0)return;o!==null&&s.shift(),uL(r,s),o!==null&&await o;let a=s[0];r.has(a)?await ww(e,s,n):r.awaitParentBlock(a,async()=>await ww(e,s,n))}async function ww(e,t,n){let r=e.get(ws),i=r.hydrating,o=e.get(en),s=o.add();for(let u=0;u<t.length;u++){let c=t[u],d=r.get(c);if(d!=null){if(await cL(d),await lL(e),sL(d)){f3(d),bw(t.slice(u),r);break}i.get(c).resolve()}else{aL(u,t,r),bw(t.slice(u),r);break}}let a=t[t.length-1];await i.get(a)?.promise,o.remove(s),n&&n(t),p3(r.get(a),t,r,e.get(Wn))}function sL(e){return Nt(e.lView,e.tNode)[Yr]===je.Error}function aL(e,t,n){let r=e-1,i=r>-1?n.get(t[r]):null;i&&cl(i.lContainer)}function bw(e,t){let n=t.hydrating;for(let r in e)n.get(r)?.reject();t.cleanup(e)}function uL(e,t){for(let n of t)e.hydrating.set(n,sh())}function lL(e){return new Promise(t=>FP(t,{injector:e}))}async function cL(e){let{tNode:t,lView:n}=e,r=Nt(n,t);return new Promise(i=>{dL(r,i),Jr(2,n,t)})}function dL(e,t){Array.isArray(e[Gi])||(e[Gi]=[]),e[Gi].push(t)}function Ye(e,t,n){return e===0?Iw(t,n):e===2?!Iw(t,n):!0}function fL(e){return e!=null&&(e&1)===1}function Iw(e,t){let n=e[Re],r=xt(e[U],t),i=Tb(n),o=fL(r.flags),a=Nt(e,t)[hl]!==null;return!(o&&a&&i)}function vr(e,t){let n=xt(e,t);return n.hydrateTriggers??=new Map}function pL(e,t,n,r,i,o,s,a,u,c){let d=P(),p=Ie(),h=e+me,g=Gr(d,p,e,null,0,0),y=d[Re];if(p.firstCreatePass){Mt("NgDefer");let S={primaryTmplIndex:t,loadingTmplIndex:r??null,placeholderTmplIndex:i??null,errorTmplIndex:o??null,placeholderBlockConfig:null,loadingBlockConfig:null,dependencyResolverFn:n??null,loadingState:et.NOT_STARTED,loadingPromise:null,providers:null,hydrateTriggers:null,debug:null,flags:c??0};u?.(p,S,a,s),jP(p,h,S)}let w=d[h];F0(w,g,d);let x=null,I=null;if(w[Vn]?.length>0){let S=w[Vn][0].data;I=S[Ep]??null,x=S[Tp]}let b=[null,eo.Initial,null,null,null,null,I,x,null,null];BP(d,h,b);let T=null;I!==null&&(T=y.get(ws),T.add(I,{lView:d,tNode:g,lContainer:w}));let C=()=>{cI(b),I!==null&&T?.cleanup([I])};Ms(0,b,()=>Wa(d,C)),Wo(d,C)}function hL(e){let t=P(),n=sn();if(!Ye(0,t,n))return;let r=It();if(Ue(t,r,e)){let i=ae(null);try{let o=!!e,a=Nt(t,n)[Yr];o===!1&&a===eo.Initial?fo(t,n):o===!0&&(a===eo.Initial||a===je.Placeholder)&&Jr(0,t,n)}finally{ae(i)}}}function mL(e){let t=P(),n=sn();if(!Ye(1,t,n))return;let r=It();if(Ue(t,r,e)){let i=ae(null);try{let o=!!e,s=t[U],a=xt(s,n);o===!0&&a.loadingState===et.NOT_STARTED&&ks(a,t,n)}finally{ae(i)}}}function gL(e){let t=P(),n=sn();if(!Ye(2,t,n))return;let r=It(),i=Ie();if(vr(i,n).set(6,null),Ue(t,r,e)){let s=t[Re],a=ae(null);try{if(!!e===!0){let d=Nt(t,n)[hl];gl(s,d)}}finally{ae(a)}}}function yL(){let e=P(),t=ge();if(!Ye(2,e,t))return;vr(Ie(),t).set(7,null)}function vL(){let e=P(),t=ge();Ye(0,e,t)&&TI(th)}function _L(){let e=P(),t=ge();Ye(1,e,t)&&CI(th)}function wL(){let e=P(),t=ge();if(!Ye(2,e,t))return;vr(Ie(),t).set(0,null),DI(th,e,t)}function bL(){let e=P(),t=ge();if(!Ye(0,e,t))return;xt(e[U],t).loadingTmplIndex===null&&fo(e,t),Jr(0,e,t)}function IL(){let e=P(),t=ge();if(!Ye(1,e,t))return;let n=e[U],r=xt(n,t);r.loadingState===et.NOT_STARTED&&ah(r,e,t)}function xL(){let e=P(),t=ge();if(!Ye(2,e,t))return;vr(Ie(),t).set(1,null);{let r=e[Re],o=Nt(e,t)[hl];gl(r,o)}}function EL(e){let t=P(),n=ge();Ye(0,t,n)&&TI(nh(e))}function TL(e){let t=P(),n=ge();Ye(1,t,n)&&CI(nh(e))}function CL(e){let t=P(),n=ge();if(!Ye(2,t,n))return;vr(Ie(),n).set(5,{delay:e}),DI(nh(e),t,n)}function DL(e,t){let n=P(),r=ge();Ye(0,n,r)&&(fo(n,r),co(n,r,e,t,bb,()=>Jr(0,n,r),0))}function SL(e,t){let n=P(),r=ge();if(!Ye(1,n,r))return;let i=n[U],o=xt(i,r);o.loadingState===et.NOT_STARTED&&co(n,r,e,t,bb,()=>ks(o,n,r),1)}function $L(){let e=P(),t=ge();if(!Ye(2,e,t))return;vr(Ie(),t).set(4,null)}function ML(e,t){let n=P(),r=ge();Ye(0,n,r)&&(fo(n,r),co(n,r,e,t,wb,()=>Jr(0,n,r),0))}function NL(e,t){let n=P(),r=ge();if(!Ye(1,n,r))return;let i=n[U],o=xt(i,r);o.loadingState===et.NOT_STARTED&&co(n,r,e,t,wb,()=>ks(o,n,r),1)}function kL(){let e=P(),t=ge();if(!Ye(2,e,t))return;vr(Ie(),t).set(3,null)}function AL(e,t){let n=P(),r=ge();Ye(0,n,r)&&(fo(n,r),co(n,r,e,t,wI,()=>Jr(0,n,r),0))}function RL(e,t){let n=P(),r=ge();if(!Ye(1,n,r))return;let i=n[U],o=xt(i,r);o.loadingState===et.NOT_STARTED&&co(n,r,e,t,wI,()=>ks(o,n,r),1)}function OL(){let e=P(),t=ge();if(!Ye(2,e,t))return;vr(Ie(),t).set(2,null)}function $I(e,t){let n=P(),r=It();if(Ue(n,r,t)){let i=Ie(),o=sn();if(ol(o,i,n,e,t))ar(o)&&o0(n,o.index);else{let a=dt(o,n);nl(n[be],a,null,o.value,e,t,null)}}return $I}function MI(e,t,n,r){let i=P(),o=It();if(Ue(i,o,t)){let s=Ie(),a=sn();$O(a,i,e,t,n,r)}return MI}var PL=!1,Xr=typeof document<"u"&&typeof document?.documentElement?.getAnimations=="function";function yl(e){return e[Re].get(cO,PL)}function LL(e,t,n){let r=to.get(e);if(r){for(let i of t)r.classList.push(i);for(let i of n)r.cleanupFns.push(i)}else to.set(e,{classList:t,cleanupFns:n})}function uh(e){let t=to.get(e);if(t){for(let n of t.cleanupFns)n();to.delete(e)}jr.delete(e)}var FL=()=>{},to=new WeakMap,jr=new WeakMap,Ki=new WeakMap;function Uu(e,t){let n=Ki.get(e);if(n&&n.length>0){let r=n.findIndex(i=>i===t);r>-1&&n.splice(r,1)}n?.length===0&&Ki.delete(e)}function NI(e,t){let n=Ki.get(e)?.shift(),r=t[jn];if(r){let o=$u(e.index,r)?.previousSibling;n&&o&&n===o&&n.dispatchEvent(new CustomEvent("animationend",{detail:{cancel:!0}}))}}function kI(e,t){Ki.has(e)?Ki.get(e)?.push(t):Ki.set(e,[t])}function AI(e){let t=e[En]??={};return t.enter??=new Map}function As(e){let t=e[En]??={};return t.leave??=new Map}function RI(e){let t=typeof e=="function"?e():e,n=Array.isArray(t)?t:null;return typeof t=="string"&&(n=t.trim().split(/\s+/).filter(r=>r)),n}function zL(e,t){if(!Xr)return;let n=to.get(e);if(n&&n.classList.length>0&&BL(e,n.classList))for(let r of n.classList)t.removeClass(e,r);uh(e)}function BL(e,t){for(let n of t)if(e.classList.contains(n))return!0;return!1}function OI(e,t){let n=jr.get(t);return n===void 0?!0:t===e.target&&(n.animationName!==void 0&&e.animationName===n.animationName||n.propertyName!==void 0&&e.propertyName===n.propertyName)}function vl(e,t,n){let r=e.get(t.index)??{animateFns:[]};r.animateFns.push(n),e.set(t.index,r)}function xw(e,t){if(e)for(let n of e)n();for(let n of t)n()}function Ew(e,t){let n=As(e).get(t.index);n&&(n.resolvers=void 0)}function hu(e){if(Mt("NgAnimateEnter"),!Xr)return hu;let t=P();if(yl(t))return hu;let n=ge();return NI(n,t),vl(AI(t),n,()=>jL(t,n,e)),PI(t),hu}function jL(e,t,n){let r=dt(t,e),i=e[be],o=e[Re].get(Ve),s=RI(n),a=[],u=d=>{if(d.target!==r)return;let p=d instanceof AnimationEvent?"animationend":"transitionend";o.runOutsideAngular(()=>{i.listen(r,p,c)})},c=d=>{d.target===r&&VL(d,r,i)};if(s&&s.length>0){o.runOutsideAngular(()=>{a.push(i.listen(r,"animationstart",u)),a.push(i.listen(r,"transitionstart",u))}),LL(r,s,a);for(let d of s)i.addClass(r,d);o.runOutsideAngular(()=>{requestAnimationFrame(()=>{if(Gb(r,jr,Xr),!jr.has(r)){for(let d of s)i.removeClass(r,d);uh(r)}})})}}function VL(e,t,n){let r=to.get(t);if(!(e.target!==t||!r)&&OI(e,t)){e.stopImmediatePropagation();for(let i of r.classList)n.removeClass(t,i);uh(t)}}function mu(e){if(Mt("NgAnimateEnter"),!Xr)return mu;let t=P();if(yl(t))return mu;let n=ge();return NI(n,t),vl(AI(t),n,()=>HL(t,n,e)),PI(t),mu}function HL(e,t,n){let r=dt(t,e);n.call(e[Be],{target:r,animationComplete:FL})}function gu(e){if(Mt("NgAnimateLeave"),!Xr)return gu;let t=P();if(yl(t))return gu;let r=ge();return vl(As(t),r,()=>UL(t,r,e)),lh(t[Re]),gu}function UL(e,t,n){let{promise:r,resolve:i}=sh(),o=dt(t,e),s=e[be],a=e[Re].get(Ve);Xu.add(e),(As(e).get(t.index).resolvers??=[]).push(i);let u=RI(n);return u&&u.length>0?WL(o,t,e,u,s,a):i(),{promise:r,resolve:i}}function WL(e,t,n,r,i,o){zL(e,i);let s=[],a=As(n).get(t.index)?.resolvers,u=c=>{if(c.target===e&&(c instanceof CustomEvent||OI(c,e))){if(c.stopImmediatePropagation(),jr.delete(e),Uu(t,e),Array.isArray(t.projection))for(let d of r)i.removeClass(e,d);xw(a,s),Ew(n,t)}};o.runOutsideAngular(()=>{s.push(i.listen(e,"animationend",u)),s.push(i.listen(e,"transitionend",u))}),kI(t,e);for(let c of r)i.addClass(e,c);o.runOutsideAngular(()=>{requestAnimationFrame(()=>{Gb(e,jr,Xr),jr.has(e)||(Uu(t,e),xw(a,s),Ew(n,t))})})}function np(e){if(Mt("NgAnimateLeave"),!Xr)return np;let t=P(),n=ge();return Xu.add(t),vl(As(t),n,()=>qL(t,n,e)),lh(t[Re]),np}function qL(e,t,n){let{promise:r,resolve:i}=sh(),o=dt(t,e),s=e[be],a=yl(e),u=e[Re].get(Ve),c=e[Re].get(dO);if(a)i();else{let d=setTimeout(()=>{Uu(t,o),i()},c),p={target:o,animationComplete:()=>{Uu(t,o),clearTimeout(d),i()}};kI(t,o),u.runOutsideAngular(()=>{s.listen(o,"animationend",()=>{i()},{once:!0})}),n.call(e[Be],p)}return r}function PI(e){lh(e[Re]);let t=e[En]?.enter;if(t){let n=e[Re].get(Cs);for(let[r,i]of t)for(let o of i.animateFns)n.queue.add(o)}}function lh(e){let t=e.get(Cs);t.isScheduled||(yI(()=>{GL(e)},{injector:e}),t.isScheduled=!0)}function GL(e){let t=e.get(Cs);for(let n of t.queue)n();t.queue.clear()}function KL(){return P()[gt][Be]}var rp=class{destroy(t){}updateValue(t,n){}swap(t,n){let r=Math.min(t,n),i=Math.max(t,n),o=this.detach(i);if(i-r>1){let s=this.detach(r);this.attach(r,o),this.attach(i,s)}else this.attach(r,o)}move(t,n){this.attach(n,this.detach(t,!0))}};function sf(e,t,n,r,i){return e===n&&Object.is(t,r)?1:Object.is(i(e,t),i(n,r))?-1:0}function QL(e,t,n){let r,i,o=0,s=e.length-1,a=void 0;if(Array.isArray(t)){let u=t.length-1;for(;o<=s&&o<=u;){let c=e.at(o),d=t[o],p=sf(o,c,o,d,n);if(p!==0){p<0&&e.updateValue(o,d),o++;continue}let h=e.at(s),g=t[u],y=sf(s,h,u,g,n);if(y!==0){y<0&&e.updateValue(s,g),s--,u--;continue}let w=n(o,c),x=n(s,h),I=n(o,d);if(Object.is(I,x)){let b=n(u,g);Object.is(b,w)?(e.swap(o,s),e.updateValue(s,g),u--,s--):e.move(s,o),e.updateValue(o,d),o++;continue}if(r??=new Wu,i??=Cw(e,o,s,n),ip(e,r,o,I))e.updateValue(o,d),o++,s++;else if(i.has(I))r.set(w,e.detach(o)),s--;else{let b=e.create(o,t[o]);e.attach(o,b),o++,s++}}for(;o<=u;)Tw(e,r,n,o,t[o]),o++}else if(t!=null){let u=t[Symbol.iterator](),c=u.next();for(;!c.done&&o<=s;){let d=e.at(o),p=c.value,h=sf(o,d,o,p,n);if(h!==0)h<0&&e.updateValue(o,p),o++,c=u.next();else{r??=new Wu,i??=Cw(e,o,s,n);let g=n(o,p);if(ip(e,r,o,g))e.updateValue(o,p),o++,s++,c=u.next();else if(!i.has(g))e.attach(o,e.create(o,p)),o++,s++,c=u.next();else{let y=n(o,d);r.set(y,e.detach(o)),s--}}}for(;!c.done;)Tw(e,r,n,e.length,c.value),c=u.next()}for(;o<=s;)e.destroy(e.detach(s--));r?.forEach(u=>{e.destroy(u)})}function ip(e,t,n,r){return t!==void 0&&t.has(r)?(e.attach(n,t.get(r)),t.delete(r),!0):!1}function Tw(e,t,n,r,i){if(ip(e,t,r,n(r,i)))e.updateValue(r,i);else{let o=e.create(r,i);e.attach(r,o)}}function Cw(e,t,n,r){let i=new Set;for(let o=t;o<=n;o++)i.add(r(o,e.at(o)));return i}var Wu=class{kvMap=new Map;_vMap=void 0;has(t){return this.kvMap.has(t)}delete(t){if(!this.has(t))return!1;let n=this.kvMap.get(t);return this._vMap!==void 0&&this._vMap.has(n)?(this.kvMap.set(t,this._vMap.get(n)),this._vMap.delete(n)):this.kvMap.delete(t),!0}get(t){return this.kvMap.get(t)}set(t,n){if(this.kvMap.has(t)){let r=this.kvMap.get(t);this._vMap===void 0&&(this._vMap=new Map);let i=this._vMap;for(;i.has(r);)r=i.get(r);i.set(r,n)}else this.kvMap.set(t,n)}forEach(t){for(let[n,r]of this.kvMap)if(t(r,n),this._vMap!==void 0){let i=this._vMap;for(;i.has(r);)r=i.get(r),t(r,n)}}};function ZL(e,t,n,r,i,o,s,a){Mt("NgControlFlow");let u=P(),c=Ie(),d=ft(c.consts,o);return Gr(u,c,e,t,n,r,i,d,256,s,a),ch}function ch(e,t,n,r,i,o,s,a){Mt("NgControlFlow");let u=P(),c=Ie(),d=ft(c.consts,o);return Gr(u,c,e,t,n,r,i,d,512,s,a),ch}function YL(e,t){Mt("NgControlFlow");let n=P(),r=It(),i=n[r]!==Pe?n[r]:-1,o=i!==-1?qu(n,me+i):void 0,s=0;if(Ue(n,r,e)){let a=ae(null);try{if(o!==void 0&&Hp(o,s),e!==-1){let u=me+e,c=qu(n,u),d=up(n[U],u),p=S0(c,d,n),h=uo(n,d,t,{dehydratedView:p});lo(c,h,s,Wr(d,p))}}finally{ae(a)}}else if(o!==void 0){let a=v0(o,s);a!==void 0&&(a[Be]=t)}}var op=class{lContainer;$implicit;$index;constructor(t,n,r){this.lContainer=t,this.$implicit=n,this.$index=r}get $count(){return this.lContainer.length-Ke}};function JL(e){return e}function XL(e,t){return t}var sp=class{hasEmptyBlock;trackByFn;liveCollection;constructor(t,n,r){this.hasEmptyBlock=t,this.trackByFn=n,this.liveCollection=r}};function eF(e,t,n,r,i,o,s,a,u,c,d,p,h){Mt("NgControlFlow");let g=P(),y=Ie(),w=u!==void 0,x=P(),I=a?s.bind(x[gt][Be]):s,b=new sp(w,I);x[me+e]=b,Gr(g,y,e+1,t,n,r,i,ft(y.consts,o),256),w&&Gr(g,y,e+2,u,c,d,p,ft(y.consts,h),512)}var ap=class extends rp{lContainer;hostLView;templateTNode;operationsCounter=void 0;needsIndexUpdate=!1;constructor(t,n,r){super(),this.lContainer=t,this.hostLView=n,this.templateTNode=r}get length(){return this.lContainer.length-Ke}at(t){return this.getLView(t)[Be].$implicit}attach(t,n){let r=n[ir];this.needsIndexUpdate||=t!==this.length,lo(this.lContainer,n,t,Wr(this.templateTNode,r))}detach(t,n){return this.needsIndexUpdate||=t!==this.length-1,n&&nF(this.lContainer,t),rF(this.lContainer,t)}create(t,n){let r=Nu(this.lContainer,this.templateTNode.tView.ssrId),i=uo(this.hostLView,this.templateTNode,new op(this.lContainer,n,t),{dehydratedView:r});return this.operationsCounter?.recordCreate(),i}destroy(t){Ds(t[U],t),this.operationsCounter?.recordDestroy()}updateValue(t,n){this.getLView(t)[Be].$implicit=n}reset(){this.needsIndexUpdate=!1,this.operationsCounter?.reset()}updateIndexes(){if(this.needsIndexUpdate)for(let t=0;t<this.length;t++)this.getLView(t)[Be].$index=t}getLView(t){return iF(this.lContainer,t)}};function tF(e){let t=ae(null),n=ot();try{let r=P(),i=r[U],o=r[n],s=n+1,a=qu(r,s);if(o.liveCollection===void 0){let c=up(i,s);o.liveCollection=new ap(a,r,c)}else o.liveCollection.reset();let u=o.liveCollection;if(QL(u,e,o.trackByFn),u.updateIndexes(),o.hasEmptyBlock){let c=It(),d=u.length===0;if(Ue(r,c,d)){let p=n+2,h=qu(r,p);if(d){let g=up(i,p),y=S0(h,g,r),w=uo(r,g,void 0,{dehydratedView:y});lo(h,w,0,Wr(g,y))}else i.firstUpdatePass&&T0(h),Hp(h,0)}}}finally{ae(t)}}function qu(e,t){return e[t]}function nF(e,t){if(e.length<=Ke)return;let n=Ke+t,r=e[n];r&&r[En]&&(r[En].skipLeaveAnimations=!0)}function rF(e,t){return ls(e,t)}function iF(e,t){return v0(e,t)}function up(e,t){return lr(e,t)}function LI(e,t,n){let r=P(),i=It();if(Ue(r,i,t)){let o=Ie(),s=sn();zp(s,r,e,t,r[be],n)}return LI}function lp(e,t,n,r,i){ol(t,e,n,i?"class":"style",r)}function dh(e,t,n,r){let i=P(),o=i[U],s=e+me,a=o.firstCreatePass?qp(s,i,2,t,jp,qa(),n,r):o.data[s];if(rl(a,i,e,t,BI),Ni(a)){let u=i[U];tl(u,i,a),Cp(u,a,i)}return r!=null&&ao(i,a),dh}function fh(){let e=Ie(),t=ge(),n=il(t);return e.firstCreatePass&&Gp(e,n),Nd(n)&&kd(),$d(),n.classesWithoutHost!=null&&gA(n)&&lp(e,n,P(),n.classesWithoutHost,!0),n.stylesWithoutHost!=null&&yA(n)&&lp(e,n,P(),n.stylesWithoutHost,!1),fh}function FI(e,t,n,r){return dh(e,t,n,r),fh(),FI}function ph(e,t,n,r){let i=P(),o=i[U],s=e+me,a=o.firstCreatePass?k0(s,o,2,t,n,r):o.data[s];return rl(a,i,e,t,BI),r!=null&&ao(i,a),ph}function hh(){let e=ge(),t=il(e);return Nd(t)&&kd(),$d(),hh}function zI(e,t,n,r){return ph(e,t,n,r),hh(),zI}var BI=(e,t,n,r,i)=>(Ai(!0),Np(t[be],r,x_()));function mh(e,t,n){let r=P(),i=r[U],o=e+me,s=i.firstCreatePass?qp(o,r,8,"ng-container",jp,qa(),t,n):i.data[o];if(rl(s,r,e,"ng-container",UI),Ni(s)){let a=r[U];tl(a,r,s),Cp(a,s,r)}return n!=null&&ao(r,s),mh}function _l(){let e=Ie(),t=ge(),n=il(t);return e.firstCreatePass&&Gp(e,n),_l}function jI(e,t,n){return mh(e,t,n),_l(),jI}function gh(e,t,n){let r=P(),i=r[U],o=e+me,s=i.firstCreatePass?k0(o,i,8,"ng-container",t,n):i.data[o];return rl(s,r,e,"ng-container",UI),n!=null&&ao(r,s),gh}function VI(){let e=ge(),t=il(e);return _l}function HI(e,t,n){return gh(e,t,n),VI(),HI}var UI=(e,t,n,r,i)=>(Ai(!0),Bb(t[be],""));function oF(){return P()}function WI(e,t,n){let r=P(),i=It();if(Ue(r,i,t)){let o=Ie(),s=sn();Bp(s,r,e,t,r[be],n)}return WI}function qI(e,t,n){let r=P(),i=It();if(Ue(r,i,t)){let o=Ie(),s=sn(),a=Qa(o.data),u=s0(a,s,r);Bp(s,r,e,t,u,n)}return qI}var su=void 0;function sF(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return t===1&&n===0?1:5}var aF=["en",[["a","p"],["AM","PM"]],[["AM","PM"]],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],su,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],su,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",su,"{1} 'at' {0}",su],[".",",",";","%","+","-","E","\xD7","\u2030","\u221E","NaN",":"],["#,##0.###","#,##0%","\xA4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",sF],af={};function uF(e){let t=cF(e),n=Dw(t);if(n)return n;let r=t.split("-")[0];if(n=Dw(r),n)return n;if(r==="en")return aF;throw new ie(701,!1)}function lF(e){return uF(e)[cp.PluralCase]}function Dw(e){return e in af||(af[e]=Ut.ng&&Ut.ng.common&&Ut.ng.common.locales&&Ut.ng.common.locales[e]),af[e]}var cp;(function(e){e[e.LocaleId=0]="LocaleId",e[e.DayPeriodsFormat=1]="DayPeriodsFormat",e[e.DayPeriodsStandalone=2]="DayPeriodsStandalone",e[e.DaysFormat=3]="DaysFormat",e[e.DaysStandalone=4]="DaysStandalone",e[e.MonthsFormat=5]="MonthsFormat",e[e.MonthsStandalone=6]="MonthsStandalone",e[e.Eras=7]="Eras",e[e.FirstDayOfWeek=8]="FirstDayOfWeek",e[e.WeekendRange=9]="WeekendRange",e[e.DateFormat=10]="DateFormat",e[e.TimeFormat=11]="TimeFormat",e[e.DateTimeFormat=12]="DateTimeFormat",e[e.NumberSymbols=13]="NumberSymbols",e[e.NumberFormats=14]="NumberFormats",e[e.CurrencyCode=15]="CurrencyCode",e[e.CurrencySymbol=16]="CurrencySymbol",e[e.CurrencyName=17]="CurrencyName",e[e.Currencies=18]="Currencies",e[e.Directionality=19]="Directionality",e[e.PluralCase=20]="PluralCase",e[e.ExtraData=21]="ExtraData"})(cp||(cp={}));function cF(e){return e.toLowerCase().replace(/_/g,"-")}var dF=["zero","one","two","few","many"];function fF(e,t){let n=lF(t)(parseInt(e,10)),r=dF[n];return r!==void 0?r:"other"}var Rs="en-US",pF="USD",GI={marker:"element"},KI={marker:"ICU"},Nn;(function(e){e[e.SHIFT=2]="SHIFT",e[e.APPEND_EAGERLY=1]="APPEND_EAGERLY",e[e.COMMENT=2]="COMMENT"})(Nn||(Nn={}));var QI=Rs;function ZI(e){typeof e=="string"&&(QI=e.toLowerCase().replace(/_/g,"-"))}function hF(){return QI}var ys=0,ts=0;function mF(e){e&&(ys=ys|1<<Math.min(ts,31)),ts++}function gF(e,t,n){if(ts>0){let r=e.data[n],i=Array.isArray(r)?r:r.update,o=Sn()-ts-1;JI(e,t,i,o,ys)}ys=0,ts=0}function yF(e,t,n){let r=e[be];switch(n){case Node.COMMENT_NODE:return Bb(r,t);case Node.TEXT_NODE:return Fb(r,t);case Node.ELEMENT_NODE:return Np(r,t,null)}}var yu=(e,t,n,r)=>(Ai(!0),yF(e,n,r));function vF(e,t,n,r){let i=e[be];for(let o=0;o<t.length;o++){let s=t[o++],a=t[o],u=(s&Nn.COMMENT)===Nn.COMMENT,c=(s&Nn.APPEND_EAGERLY)===Nn.APPEND_EAGERLY,d=s>>>Nn.SHIFT,p=e[d],h=!1;p===null&&(p=e[d]=yu(e,d,a,u?Node.COMMENT_NODE:Node.TEXT_NODE),h=Go()),c&&n!==null&&h&&Ur(i,n,p,r,!1)}}function YI(e,t,n,r){let i=n[be],o=null,s;for(let a=0;a<t.length;a++){let u=t[a];if(typeof u=="string"){let c=t[++a];n[c]===null&&(n[c]=yu(n,c,u,Node.TEXT_NODE))}else if(typeof u=="number")switch(u&1){case 0:let c=t3(u);o===null&&(o=c,s=i.parentNode(r));let d,p;if(c===o?(d=r,p=s):(d=null,p=$t(n[c])),p!==null){let w=n3(u),x=n[w];Ur(i,p,x,d,!1);let I=Jo(e,w);if(I!==null&&typeof I=="object"){let b=ll(I,n);b!==null&&YI(e,I.create[b],n,n[I.anchorIdx])}}break;case 1:let h=u>>>1,g=t[++a],y=t[++a];nl(i,Fr(h,n),null,null,g,y,null);break;default:}else switch(u){case KI:let c=t[++a],d=t[++a];if(n[d]===null){let g=n[d]=yu(n,d,c,Node.COMMENT_NODE);mr(g,n)}break;case GI:let p=t[++a],h=t[++a];if(n[h]===null){let g=n[h]=yu(n,h,p,Node.ELEMENT_NODE);mr(g,n)}break;default:}}}function JI(e,t,n,r,i){for(let o=0;o<n.length;o++){let s=n[o],a=n[++o];if(s&i){let u="";for(let c=o+1;c<=o+a;c++){let d=n[c];if(typeof d=="string")u+=d;else if(typeof d=="number")if(d<0)u+=ve(t[r-d]);else{let p=d>>>2;switch(d&3){case 1:let h=n[++c],g=n[++c],y=e.data[p];typeof y=="string"?nl(t[be],t[p],null,y,h,u,g):zp(y,t,h,u,t[be],g);break;case 0:let w=t[p];w!==null&&zb(t[be],w,u);break;case 2:_F(e,Jo(e,p),t,u);break;case 3:Sw(e,Jo(e,p),r,t);break}}}}else{let u=n[o+1];if(u>0&&(u&3)===3){let c=u>>>2,d=Jo(e,c);t[d.currentCaseLViewIndex]<0&&Sw(e,d,r,t)}}o+=a}}function Sw(e,t,n,r){let i=r[t.currentCaseLViewIndex];if(i!==null){let o=ys;i<0&&(i=r[t.currentCaseLViewIndex]=~i,o=-1),JI(e,r,t.update[i],n,o)}}function _F(e,t,n,r){let i=wF(t,r);if(ll(t,n)!==i&&(XI(e,t,n),n[t.currentCaseLViewIndex]=i===null?null:~i,i!==null)){let s=n[t.anchorIdx];s&&YI(e,t.create[i],n,s),l3(n,t.anchorIdx,i)}}function XI(e,t,n){let r=ll(t,n);if(r!==null){let i=t.remove[r];for(let o=0;o<i.length;o++){let s=i[o];if(s>0){let a=Fr(s,n);a!==null&&Es(n[be],a)}else XI(e,Jo(e,~s),n)}}}function wF(e,t){let n=e.cases.indexOf(t);if(n===-1)switch(e.type){case 1:{let r=fF(t,hF());n=e.cases.indexOf(r),n===-1&&r!=="other"&&(n=e.cases.indexOf("other"));break}case 0:{n=e.cases.indexOf("other");break}}return n===-1?null:n}var Gu=/(\d+):?\d*/gi,bF=/({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi,IF=/(\d+)/,ex=/^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/,ns="\uFFFD",xF=/\/?\*(\d+:\d+)/gi,EF=/(\/?[#*]\d+):?\d*/gi,TF=/\uE500/g;function CF(e){return e.replace(TF," ")}function DF(e,t,n,r,i,o){let s=ki(),a=[],u=[],c=[[]],d=[[]];i=NF(i,o);let p=CF(i).split(EF);for(let h=0;h<p.length;h++){let g=p[h];if((h&1)===0){let y=dp(g);for(let w=0;w<y.length;w++){let x=y[w];if((w&1)===0){let I=x;I!==""&&SF(d[0],e,s,c[0],a,u,n,I)}else{let I=x;if(typeof I!="object")throw new Error(`Unable to parse ICU expression in "${i}" message.`);let T=tx(e,s,c[0],n,a,"",!0).index;rx(d[0],e,n,u,t,I,T)}}}else{let y=g.charCodeAt(0)===47,w=g.charCodeAt(y?1:0),x=me+Number.parseInt(g.substring(y?2:1));if(y)c.shift(),d.shift(),Dn(ki(),!1);else{let I=e3(e,c[0],x);c.unshift([]),Dn(I,!0);let b={kind:2,index:x,children:[],type:w===35?0:1};d[0].push(b),d.unshift(b.children)}}}e.data[r]={create:a,update:u,ast:d[0],parentTNodeIndex:t}}function tx(e,t,n,r,i,o,s){let a=Ts(e,r,1,null),u=a<<Nn.SHIFT,c=ki();t===c&&(c=null),c===null&&(u|=Nn.APPEND_EAGERLY),s&&(u|=Nn.COMMENT,oO(o3)),i.push(u,o===null?"":o);let d=Up(e,a,s?32:1,o===null?"":o,null);I0(n,d);let p=d.index;return Dn(d,!1),c!==null&&t!==c&&XO(c,p),d}function SF(e,t,n,r,i,o,s,a){let u=a.match(Gu),d=tx(t,n,r,s,i,u?null:a,!1).index;u&&rs(o,a,d,null,0,null),e.push({kind:0,index:d})}function $F(e,t,n){let i=ge().index,o=[];if(e.firstCreatePass&&e.data[t]===null){for(let s=0;s<n.length;s+=2){let a=n[s],u=n[s+1];if(u!==""){if(bF.test(u))throw new Error(`ICU expressions are not supported in attributes. Message: "${u}".`);rs(o,u,i,a,MF(o),null)}}e.data[t]=o}}function rs(e,t,n,r,i,o){let s=e.length,a=s+1;e.push(null,null);let u=s+2,c=t.split(Gu),d=0;for(let p=0;p<c.length;p++){let h=c[p];if(p&1){let g=i+parseInt(h,10);e.push(-1-g),d=d|nx(g)}else h!==""&&e.push(h)}return e.push(n<<2|(r?1:0)),r&&e.push(r,o),e[s]=d,e[a]=e.length-u,d}function MF(e){let t=0;for(let n=0;n<e.length;n++){let r=e[n];typeof r=="number"&&r<0&&t++}return t}function nx(e){return 1<<Math.min(e,31)}function $w(e){let t,n="",r=0,i=!1,o;for(;(t=xF.exec(e))!==null;)i?t[0]===`${ns}/*${o}${ns}`&&(r=t.index,i=!1):(n+=e.substring(r,t.index+t[0].length),o=t[1],i=!0);return n+=e.slice(r),n}function NF(e,t){if(i3(t))return $w(e);{let n=e.indexOf(`:${t}${ns}`)+2+t.toString().length,r=e.search(new RegExp(`${ns}\\/\\*\\d+:${t}${ns}`));return $w(e.substring(n,r))}}function rx(e,t,n,r,i,o,s){let a=0,u={type:o.type,currentCaseLViewIndex:Ts(t,n,1,null),anchorIdx:s,cases:[],create:[],remove:[],update:[]};OF(r,o,s),JO(t,s,u);let c=o.values,d=[];for(let p=0;p<c.length;p++){let h=c[p],g=[];for(let w=0;w<h.length;w++){let x=h[w];if(typeof x!="string"){let I=g.push(x)-1;h[w]=`<!--\uFFFD${I}\uFFFD-->`}}let y=[];d.push(y),a=AF(y,t,u,n,r,i,o.cases[p],h.join(""),g)|a}a&&PF(r,a,s),e.push({kind:3,index:s,cases:d,currentCaseLViewIndex:u.currentCaseLViewIndex})}function kF(e){let t=[],n=[],r=1,i=0;e=e.replace(ex,function(s,a,u){return u==="select"?r=0:r=1,i=parseInt(a.slice(1),10),""});let o=dp(e);for(let s=0;s<o.length;){let a=o[s++].trim();r===1&&(a=a.replace(/\s*(?:=)?(\w+)\s*/,"$1")),a.length&&t.push(a);let u=dp(o[s++]);t.length>n.length&&n.push(u)}return{type:r,mainBinding:i,cases:t,values:n}}function dp(e){if(!e)return[];let t=0,n=[],r=[],i=/[{}]/g;i.lastIndex=0;let o;for(;o=i.exec(e);){let a=o.index;if(o[0]=="}"){if(n.pop(),n.length==0){let u=e.substring(t,a);ex.test(u)?r.push(kF(u)):r.push(u),t=a+1}}else{if(n.length==0){let u=e.substring(t,a);r.push(u),t=a+1}n.push("{")}}let s=e.substring(t);return r.push(s),r}function AF(e,t,n,r,i,o,s,a,u){let c=[],d=[],p=[];n.cases.push(s),n.create.push(c),n.remove.push(d),n.update.push(p);let g=Sb(Qr()).getInertBodyElement(a),y=Df(g)||g;return y?ix(e,t,n,r,i,c,d,p,y,o,u,0):0}function ix(e,t,n,r,i,o,s,a,u,c,d,p){let h=0,g=u.firstChild;for(;g;){let y=Ts(t,r,1,null);switch(g.nodeType){case Node.ELEMENT_NODE:let w=g,x=w.tagName.toLowerCase();if(Tf.hasOwnProperty(x)){uf(o,GI,x,c,y),t.data[y]=x;let C=w.attributes;for(let $=0;$<C.length;$++){let M=C.item($),L=M.name.toLowerCase();!!M.value.match(Gu)?kb.hasOwnProperty(L)&&($p[L]?rs(a,M.value,y,M.name,0,Sp):rs(a,M.value,y,M.name,0,null)):LF(o,y,M)}let S={kind:1,index:y,children:[]};e.push(S),h=ix(S.children,t,n,r,i,o,s,a,g,y,d,p+1)|h,Mw(s,y,p)}break;case Node.TEXT_NODE:let I=g.textContent||"",b=I.match(Gu);uf(o,null,b?"":I,c,y),Mw(s,y,p),b&&(h=rs(a,I,y,null,0,null)|h),e.push({kind:0,index:y});break;case Node.COMMENT_NODE:let T=IF.exec(g.textContent||"");if(T){let C=parseInt(T[1],10),S=d[C];uf(o,KI,"",c,y),rx(e,t,r,i,c,S,y),RF(s,y,p)}break}g=g.nextSibling}return h}function Mw(e,t,n){n===0&&e.push(t)}function RF(e,t,n){n===0&&(e.push(~t),e.push(t))}function OF(e,t,n){e.push(nx(t.mainBinding),2,-1-t.mainBinding,n<<2|2)}function PF(e,t,n){e.push(t,1,n<<2|3)}function uf(e,t,n,r,i){t!==null&&e.push(t),e.push(n,i,r3(0,r,i))}function LF(e,t,n){e.push(t<<1|1,n.name,n.value)}var Nw=0,FF=/\[(.+??)\]/,zF=/\[(.+??)\]|(\/?\*\d+:\d+)/g,BF=/({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g,jF=/{([A-Z0-9_]+)}/g,VF=/I18N_EXP_(ICU(_\d+)?)/g,HF=/\/\*/,UF=/\d+\:(\d+)/;function WF(e,t={}){let n=e;if(FF.test(e)){let r={},i=[Nw];n=n.replace(zF,(o,s,a)=>{let u=s||a,c=r[u]||[];if(c.length||(u.split("|").forEach(w=>{let x=w.match(UF),I=x?parseInt(x[1],10):Nw,b=HF.test(w);c.push([I,b,w])}),r[u]=c),!c.length)throw new Error(`i18n postprocess: unmatched placeholder - ${u}`);let d=i[i.length-1],p=0;for(let w=0;w<c.length;w++)if(c[w][0]===d){p=w;break}let[h,g,y]=c[p];return g?i.pop():d!==h&&i.push(h),c.splice(p,1),y})}return Object.keys(t).length&&(n=n.replace(BF,(r,i,o,s,a,u)=>t.hasOwnProperty(o)?`${i}${t[o]}${u}`:r),n=n.replace(jF,(r,i)=>t.hasOwnProperty(i)?t[i]:r),n=n.replace(VF,(r,i)=>{if(t.hasOwnProperty(i)){let o=t[i];if(!o.length)throw new Error(`i18n postprocess: unmatched ICU - ${r} with key: ${i}`);return o.shift()}return r})),n}function ox(e,t,n=-1){let r=Ie(),i=P(),o=me+e,s=ft(r.consts,t),a=ki();if(r.firstCreatePass&&DF(r,a===null?0:a.index,i,o,s,n),r.type===2){let h=i[gt];h[le]|=32}else i[le]|=32;let u=r.data[o],c=a===i[ct]?null:a,d=Yb(r,c,i),p=a&&a.type&8?i[a.index]:null;a3(i,o,a,n),vF(i,u.create,d,p),zd(!0)}function sx(){zd(!1)}function qF(e,t,n){ox(e,t,n),sx()}function GF(e,t){let n=Ie(),r=ft(n.consts,t);$F(n,e+me,r)}function ax(e){let t=P();return mF(Ue(t,It(),e)),ax}function KF(e){gF(Ie(),P(),e+me)}function QF(e,t={}){return WF(e,t)}function ux(e,t,n){let r=P(),i=Ie(),o=ge();return yh(i,r,r[be],o,e,t,n),ux}function lx(e,t){let n=ge(),r=P(),i=Ie(),o=Qa(i.data),s=s0(o,n,r);return yh(i,r,s,n,e,t),lx}function cx(e,t,n){let r=P(),i=Ie(),o=ge();return(o.type&3||n)&&R0(o,i,r,n,r[be],e,t,fu(o,r,t)),cx}function yh(e,t,n,r,i,o,s){let a=!0,u=null;if((r.type&3||s)&&(u??=fu(r,t,o),R0(r,e,t,s,n,i,o,u)&&(a=!1)),a){let c=r.outputs?.[i],d=r.hostDirectiveOutputs?.[i];if(d&&d.length)for(let p=0;p<d.length;p+=2){let h=d[p],g=d[p+1];u??=fu(r,t,o),iw(r,t,h,g,i,u)}if(c&&c.length)for(let p of c)u??=fu(r,t,o),iw(r,t,p,i,i,u)}}function ZF(e=1){return __(e)}function YF(e,t){let n=null,r=GR(e);for(let i=0;i<t.length;i++){let o=t[i];if(o==="*"){n=i;continue}if(r===null?Lb(e,o,!0):ZR(r,o))return i}return n}function JF(e){let t=P()[gt][ct];if(!t.projection){let n=e?e.length:1,r=t.projection=Fo(n,null),i=r.slice(),o=t.child;for(;o!==null;){if(o.type!==128){let s=e?YF(o,e):0;s!==null&&(i[s]?i[s].projectionNext=o:r[s]=o,i[s]=o)}o=o.next}}}function XF(e,t=0,n,r,i,o){let s=P(),a=Ie(),u=r?e+1:null;u!==null&&Gr(s,a,u,r,i,o,null,n);let c=Zr(a,me+e,16,null,n||null);c.projection===null&&(c.projection=t),Od();let p=!s[ir]||Md();s[gt][ct].projection[c.projection]===null&&u!==null?ez(s,a,u):p&&!Yu(c)&&_O(a,s,c)}function ez(e,t,n){let r=me+n,i=t.data[r],o=e[r],s=Nu(o,i.tView.ssrId),a=uo(e,i,void 0,{dehydratedView:s});lo(o,a,0,Wr(i,s))}function tz(e,t,n,r){V0(e,t,n,r)}function nz(e,t,n){j0(e,t,n)}function rz(e){let t=P(),n=Ie(),r=Za();qo(r+1);let i=Zp(n,r);if(e.dirty&&i_(t)===((i.metadata.flags&2)===2)){if(i.matches===null)e.reset([]);else{let o=U0(t,r);e.reset(o,ab),e.notifyOnChanges()}return!0}return!1}function iz(){return Qp(P(),Za())}function oz(e,t,n,r,i){q0(t,V0(e,n,r,i))}function sz(e,t,n,r){q0(e,j0(t,n,r))}function az(e=1){qo(Za()+e)}function uz(e){let t=Pd();return cr(t,me+e)}function au(e,t){return e<<17|t<<2}function Kr(e){return e>>17&32767}function lz(e){return(e&2)==2}function cz(e,t){return e&131071|t<<17}function fp(e){return e|2}function no(e){return(e&131068)>>2}function lf(e,t){return e&-131069|t<<2}function dz(e){return(e&1)===1}function pp(e){return e|1}function fz(e,t,n,r,i,o){let s=o?t.classBindings:t.styleBindings,a=Kr(s),u=no(s);e[r]=n;let c=!1,d;if(Array.isArray(n)){let p=n;d=p[1],(d===null||Si(p,d)>0)&&(c=!0)}else d=n;if(i)if(u!==0){let h=Kr(e[a+1]);e[r+1]=au(h,a),h!==0&&(e[h+1]=lf(e[h+1],r)),e[a+1]=cz(e[a+1],r)}else e[r+1]=au(a,0),a!==0&&(e[a+1]=lf(e[a+1],r)),a=r;else e[r+1]=au(u,0),a===0?a=r:e[u+1]=lf(e[u+1],r),u=r;c&&(e[r+1]=fp(e[r+1])),kw(e,d,r,!0),kw(e,d,r,!1),pz(t,d,e,r,o),s=au(a,u),o?t.classBindings=s:t.styleBindings=s}function pz(e,t,n,r,i){let o=i?e.residualClasses:e.residualStyles;o!=null&&typeof t=="string"&&Si(o,t)>=0&&(n[r+1]=pp(n[r+1]))}function kw(e,t,n,r){let i=e[n+1],o=t===null,s=r?Kr(i):no(i),a=!1;for(;s!==0&&(a===!1||o);){let u=e[s],c=e[s+1];hz(u,t)&&(a=!0,e[s+1]=r?pp(c):fp(c)),s=r?Kr(c):no(c)}a&&(e[n+1]=r?fp(i):pp(i))}function hz(e,t){return e===null||t==null||(Array.isArray(e)?e[1]:e)===t?!0:Array.isArray(e)&&typeof t=="string"?Si(e,t)>=0:!1}var tt={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function dx(e){return e.substring(tt.key,tt.keyEnd)}function mz(e){return e.substring(tt.value,tt.valueEnd)}function gz(e){return hx(e),fx(e,ro(e,0,tt.textEnd))}function fx(e,t){let n=tt.textEnd;return n===t?-1:(t=tt.keyEnd=vz(e,tt.key=t,n),ro(e,t,n))}function yz(e){return hx(e),px(e,ro(e,0,tt.textEnd))}function px(e,t){let n=tt.textEnd,r=tt.key=ro(e,t,n);return n===r?-1:(r=tt.keyEnd=_z(e,r,n),r=Aw(e,r,n,58),r=tt.value=ro(e,r,n),r=tt.valueEnd=wz(e,r,n),Aw(e,r,n,59))}function hx(e){tt.key=0,tt.keyEnd=0,tt.value=0,tt.valueEnd=0,tt.textEnd=e.length}function ro(e,t,n){for(;t<n&&e.charCodeAt(t)<=32;)t++;return t}function vz(e,t,n){for(;t<n&&e.charCodeAt(t)>32;)t++;return t}function _z(e,t,n){let r;for(;t<n&&((r=e.charCodeAt(t))===45||r===95||(r&-33)>=65&&(r&-33)<=90||r>=48&&r<=57);)t++;return t}function Aw(e,t,n,r){return t=ro(e,t,n),t<n&&t++,t}function wz(e,t,n){let r=-1,i=-1,o=-1,s=t,a=s;for(;s<n;){let u=e.charCodeAt(s++);if(u===59)return a;u===34||u===39?a=s=Rw(e,u,s,n):t===s-4&&o===85&&i===82&&r===76&&u===40?a=s=Rw(e,41,s,n):u>32&&(a=s),o=i,i=r,r=u&-33}return a}function Rw(e,t,n,r){let i=-1,o=n;for(;o<r;){let s=e.charCodeAt(o++);if(s==t&&i!==92)return o;s==92&&i===92?i=0:i=s}throw new Error}function mx(e,t,n){return yx(e,t,n,!1),mx}function gx(e,t){return yx(e,t,null,!0),gx}function bz(e){vx(bx,Iz,e,!1)}function Iz(e,t){for(let n=yz(t);n>=0;n=px(t,n))bx(e,dx(t),mz(t))}function xz(e){vx(Mz,Ez,e,!0)}function Ez(e,t){for(let n=gz(t);n>=0;n=fx(t,n))zo(e,dx(t),!0)}function yx(e,t,n,r){let i=P(),o=Ie(),s=$n(2);if(o.firstUpdatePass&&wx(o,e,s,r),t!==Pe&&Ue(i,s,t)){let a=o.data[ot()];Ix(o,a,i,i[be],e,i[s+1]=kz(t,n),r,s)}}function vx(e,t,n,r){let i=Ie(),o=$n(2);i.firstUpdatePass&&wx(i,null,o,r);let s=P();if(n!==Pe&&Ue(s,o,n)){let a=i.data[ot()];if(xx(a,r)&&!_x(i,o)){let u=r?a.classesWithoutHost:a.stylesWithoutHost;u!==null&&(n=$a(u,n||"")),lp(i,a,s,n,r)}else Nz(i,a,s,s[be],s[o+1],s[o+1]=$z(e,t,n),r,o)}}function _x(e,t){return t>=e.expandoStartIndex}function wx(e,t,n,r){let i=e.data;if(i[n+1]===null){let o=i[ot()],s=_x(e,n);xx(o,r)&&t===null&&!s&&(t=!1),t=Tz(i,o,t,r),fz(i,o,t,n,s,r)}}function Tz(e,t,n,r){let i=Qa(e),o=r?t.residualClasses:t.residualStyles;if(i===null)(r?t.classBindings:t.styleBindings)===0&&(n=cf(null,e,t,n,r),n=vs(n,t.attrs,r),o=null);else{let s=t.directiveStylingLast;if(s===-1||e[s]!==i)if(n=cf(i,e,t,n,r),o===null){let u=Cz(e,t,r);u!==void 0&&Array.isArray(u)&&(u=cf(null,e,t,u[1],r),u=vs(u,t.attrs,r),Dz(e,t,r,u))}else o=Sz(e,t,r)}return o!==void 0&&(r?t.residualClasses=o:t.residualStyles=o),n}function Cz(e,t,n){let r=n?t.classBindings:t.styleBindings;if(no(r)!==0)return e[Kr(r)]}function Dz(e,t,n,r){let i=n?t.classBindings:t.styleBindings;e[Kr(i)]=r}function Sz(e,t,n){let r,i=t.directiveEnd;for(let o=1+t.directiveStylingLast;o<i;o++){let s=e[o].hostAttrs;r=vs(r,s,n)}return vs(r,t.attrs,n)}function cf(e,t,n,r,i){let o=null,s=n.directiveEnd,a=n.directiveStylingLast;for(a===-1?a=n.directiveStart:a++;a<s&&(o=t[a],r=vs(r,o.hostAttrs,i),o!==e);)a++;return e!==null&&(n.directiveStylingLast=a),r}function vs(e,t,n){let r=n?1:2,i=-1;if(t!==null)for(let o=0;o<t.length;o++){let s=t[o];typeof s=="number"?i=s:i===r&&(Array.isArray(e)||(e=e===void 0?[]:["",e]),zo(e,s,n?!0:t[++o]))}return e===void 0?null:e}function $z(e,t,n){if(n==null||n==="")return Ne;let r=[],i=yr(n);if(Array.isArray(i))for(let o=0;o<i.length;o++)e(r,i[o],!0);else if(typeof i=="object")for(let o in i)i.hasOwnProperty(o)&&e(r,o,i[o]);else typeof i=="string"&&t(r,i);return r}function bx(e,t,n){zo(e,t,yr(n))}function Mz(e,t,n){let r=String(t);r!==""&&!r.includes(" ")&&zo(e,r,n)}function Nz(e,t,n,r,i,o,s,a){i===Pe&&(i=Ne);let u=0,c=0,d=0<i.length?i[0]:null,p=0<o.length?o[0]:null;for(;d!==null||p!==null;){let h=u<i.length?i[u+1]:void 0,g=c<o.length?o[c+1]:void 0,y=null,w;d===p?(u+=2,c+=2,h!==g&&(y=p,w=g)):p===null||d!==null&&d<p?(u+=2,y=d):(c+=2,y=p,w=g),y!==null&&Ix(e,t,n,r,y,w,s,a),d=u<i.length?i[u]:null,p=c<o.length?o[c]:null}}function Ix(e,t,n,r,i,o,s,a){if(!(t.type&3))return;let u=e.data,c=u[a+1],d=dz(c)?Ow(u,t,n,i,no(c),s):void 0;if(!Ku(d)){Ku(o)||lz(c)&&(o=Ow(u,null,n,i,a,s));let p=Fr(ot(),n);bO(r,s,p,i,o)}}function Ow(e,t,n,r,i,o){let s=t===null,a;for(;i>0;){let u=e[i],c=Array.isArray(u),d=c?u[1]:u,p=d===null,h=n[i+1];h===Pe&&(h=p?Ne:void 0);let g=p?Pa(h,r):d===r?h:void 0;if(c&&!Ku(g)&&(g=Pa(u,r)),Ku(g)&&(a=g,s))return a;let y=e[i+1];i=s?Kr(y):no(y)}if(t!==null){let u=o?t.residualClasses:t.residualStyles;u!=null&&(a=Pa(u,r))}return a}function Ku(e){return e!==void 0}function kz(e,t){return e==null||e===""||(typeof t=="string"?e=e+t:typeof e=="object"&&(e=Jt(yr(e)))),e}function xx(e,t){return(e.flags&(t?8:16))!==0}function Az(e,t=""){let n=P(),r=Ie(),i=e+me,o=r.firstCreatePass?Zr(r,i,1,t,null):r.data[i],s=Rz(r,n,o,t,e);n[i]=s,Go()&&Lp(r,n,s,o),Dn(o,!1)}var Rz=(e,t,n,r,i)=>(Ai(!0),Fb(t[be],r));function Ex(e,t){let n=!1,r=Sn();for(let o=1;o<t.length;o+=2)n=Ue(e,r++,t[o])||n;if(Fd(r),!n)return Pe;let i=t[0];for(let o=1;o<t.length;o+=2)i+=ve(t[o])+(o+1!==t.length?t[o+1]:"");return i}function Tx(e,t,n,r=""){return Ue(e,It(),n)?t+ve(n)+r:Pe}function Cx(e,t,n,r,i,o=""){let s=Sn(),a=qr(e,s,n,i);return $n(2),a?t+ve(n)+r+ve(i)+o:Pe}function Dx(e,t,n,r,i,o,s,a=""){let u=Sn(),c=pl(e,u,n,i,s);return $n(3),c?t+ve(n)+r+ve(i)+o+ve(s)+a:Pe}function Sx(e,t,n,r,i,o,s,a,u,c=""){let d=Sn(),p=qt(e,d,n,i,s,u);return $n(4),p?t+ve(n)+r+ve(i)+o+ve(s)+a+ve(u)+c:Pe}function $x(e,t,n,r,i,o,s,a,u,c,d,p=""){let h=Sn(),g=qt(e,h,n,i,s,u);return g=Ue(e,h+4,d)||g,$n(5),g?t+ve(n)+r+ve(i)+o+ve(s)+a+ve(u)+c+ve(d)+p:Pe}function Mx(e,t,n,r,i,o,s,a,u,c,d,p,h,g=""){let y=Sn(),w=qt(e,y,n,i,s,u);return w=qr(e,y+4,d,h)||w,$n(6),w?t+ve(n)+r+ve(i)+o+ve(s)+a+ve(u)+c+ve(d)+p+ve(h)+g:Pe}function Nx(e,t,n,r,i,o,s,a,u,c,d,p,h,g,y,w=""){let x=Sn(),I=qt(e,x,n,i,s,u);return I=pl(e,x+4,d,h,y)||I,$n(7),I?t+ve(n)+r+ve(i)+o+ve(s)+a+ve(u)+c+ve(d)+p+ve(h)+g+ve(y)+w:Pe}function kx(e,t,n,r,i,o,s,a,u,c,d,p,h,g,y,w,x,I=""){let b=Sn(),T=qt(e,b,n,i,s,u);return T=qt(e,b+4,d,h,y,x)||T,$n(8),T?t+ve(n)+r+ve(i)+o+ve(s)+a+ve(u)+c+ve(d)+p+ve(h)+g+ve(y)+w+ve(x)+I:Pe}function Ax(e){return vh("",e),Ax}function vh(e,t,n){let r=P(),i=Tx(r,e,t,n);return i!==Pe&&Kn(r,ot(),i),vh}function Rx(e,t,n,r,i){let o=P(),s=Cx(o,e,t,n,r,i);return s!==Pe&&Kn(o,ot(),s),Rx}function Ox(e,t,n,r,i,o,s){let a=P(),u=Dx(a,e,t,n,r,i,o,s);return u!==Pe&&Kn(a,ot(),u),Ox}function Px(e,t,n,r,i,o,s,a,u){let c=P(),d=Sx(c,e,t,n,r,i,o,s,a,u);return d!==Pe&&Kn(c,ot(),d),Px}function Lx(e,t,n,r,i,o,s,a,u,c,d){let p=P(),h=$x(p,e,t,n,r,i,o,s,a,u,c,d);return h!==Pe&&Kn(p,ot(),h),Lx}function Fx(e,t,n,r,i,o,s,a,u,c,d,p,h){let g=P(),y=Mx(g,e,t,n,r,i,o,s,a,u,c,d,p,h);return y!==Pe&&Kn(g,ot(),y),Fx}function zx(e,t,n,r,i,o,s,a,u,c,d,p,h,g,y){let w=P(),x=Nx(w,e,t,n,r,i,o,s,a,u,c,d,p,h,g,y);return x!==Pe&&Kn(w,ot(),x),zx}function Bx(e,t,n,r,i,o,s,a,u,c,d,p,h,g,y,w,x){let I=P(),b=kx(I,e,t,n,r,i,o,s,a,u,c,d,p,h,g,y,w,x);return b!==Pe&&Kn(I,ot(),b),Bx}function jx(e){let t=P(),n=Ex(t,e);return n!==Pe&&Kn(t,ot(),n),jx}function Kn(e,t,n){let r=Fr(t,e);zb(e[be],r,n)}function Vx(e,t,n){Ud(t)&&(t=t());let r=P(),i=It();if(Ue(r,i,t)){let o=Ie(),s=sn();zp(s,r,e,t,r[be],n)}return Vx}function Oz(e,t){let n=Ud(e);return n&&e.set(t),n}function Hx(e,t){let n=P(),r=Ie(),i=ge();return yh(r,n,n[be],i,e,t),Hx}var Ux={};function Wx(e){let t=Ie(),n=P(),r=e+me,i=Zr(t,r,128,null,null);return Dn(i,!1),Va(t,n,r,Ux),Wx}function Pz(e){Mt("NgLet");let t=Ie(),n=P(),r=ot();return Va(t,n,r,e),e}function Lz(e){let t=Pd(),n=cr(t,me+e);if(n===Ux)throw new ie(314,!1);return n}function Fz(e,t){let n=Ie(),r=P(),i=r[be],o="data-ng-source-location";for(let[s,a,u,c]of t){let d=lr(n,s+me),p=Fr(s+me,r);if(!p.hasAttribute(o)){let h=`${e}@o:${a},l:${u},c:${c}`;i.setAttribute(p,o,h)}}}function zz(e){return Ue(P(),It(),e)?ve(e):Pe}function Bz(e,t,n=""){return Tx(P(),e,t,n)}function jz(e,t,n,r,i=""){return Cx(P(),e,t,n,r,i)}function Vz(e,t,n,r,i,o,s=""){return Dx(P(),e,t,n,r,i,o,s)}function Hz(e,t,n,r,i,o,s,a,u=""){return Sx(P(),e,t,n,r,i,o,s,a,u)}function Uz(e,t,n,r,i,o,s,a,u,c,d=""){return $x(P(),e,t,n,r,i,o,s,a,u,c,d)}function Wz(e,t,n,r,i,o,s,a,u,c,d,p,h=""){return Mx(P(),e,t,n,r,i,o,s,a,u,c,d,p,h)}function qz(e,t,n,r,i,o,s,a,u,c,d,p,h,g,y=""){return Nx(P(),e,t,n,r,i,o,s,a,u,c,d,p,h,g,y)}function Gz(e,t,n,r,i,o,s,a,u,c,d,p,h,g,y,w,x=""){return kx(P(),e,t,n,r,i,o,s,a,u,c,d,p,h,g,y,w,x)}function Kz(e){return Ex(P(),e)}function Qz(e,t,n){let r=Ie();if(r.firstCreatePass){let i=St(e);hp(n,r.data,r.blueprint,i,!0),hp(t,r.data,r.blueprint,i,!1)}}function hp(e,t,n,r,i){if(e=Se(e),Array.isArray(e))for(let o=0;o<e.length;o++)hp(e[o],t,n,r,i);else{let o=Ie(),s=P(),a=ge(),u=$r(e)?e:Se(e.provide),c=gd(e),d=a.providerIndexes&1048575,p=a.directiveStart,h=a.providerIndexes>>20;if($r(e)||!e.multi){let g=new Vr(c,i,Ss,null),y=ff(u,t,i?d:d+h,p);y===-1?(vf(xu(a,s),o,u),df(o,e,t.length),t.push(u),a.directiveStart++,a.directiveEnd++,i&&(a.providerIndexes+=1048576),n.push(g),s.push(g)):(n[y]=g,s[y]=g)}else{let g=ff(u,t,d+h,p),y=ff(u,t,d,d+h),w=g>=0&&n[g],x=y>=0&&n[y];if(i&&!x||!i&&!w){vf(xu(a,s),o,u);let I=Jz(i?Yz:Zz,n.length,i,r,c,e);!i&&x&&(n[y].providerFactory=I),df(o,e,t.length,0),t.push(u),a.directiveStart++,a.directiveEnd++,i&&(a.providerIndexes+=1048576),n.push(I),s.push(I)}else{let I=qx(n[i?y:g],c,!i&&r);df(o,e,g>-1?g:y,I)}!i&&r&&x&&n[y].componentProviders++}}}function df(e,t,n,r){let i=$r(t),o=r_(t);if(i||o){let u=(o?Se(t.useClass):t).prototype.ngOnDestroy;if(u){let c=e.destroyHooks||(e.destroyHooks=[]);if(!i&&t.multi){let d=c.indexOf(n);d===-1?c.push(n,[r,u]):c[d+1].push(r,u)}else c.push(n,u)}}}function qx(e,t,n){return n&&e.componentProviders++,e.multi.push(t)-1}function ff(e,t,n,r){for(let i=n;i<r;i++)if(t[i]===e)return i;return-1}function Zz(e,t,n,r,i){return mp(this.multi,[])}function Yz(e,t,n,r,i){let o=this.multi,s;if(this.providerFactory){let a=this.providerFactory.componentProviders,u=is(r,r[U],this.providerFactory.index,i);s=u.slice(0,a),mp(o,s);for(let c=a;c<u.length;c++)s.push(u[c])}else s=[],mp(o,s);return s}function mp(e,t){for(let n=0;n<e.length;n++){let r=e[n];t.push(r())}return t}function Jz(e,t,n,r,i,o){let s=new Vr(e,n,Ss,null);return s.multi=[],s.index=t,s.componentProviders=0,qx(s,i,r&&!n),s}function Xz(e,t=[]){return n=>{n.providersResolver=(r,i)=>Qz(r,i?i(e):e,t)}}function eB(e){return t=>{e.length<1||(t.getExternalStyles=n=>e.map(i=>i+"?ngcomp"+(n?"="+encodeURIComponent(n):"")+"&e="+t.encapsulation))}}function tB(e,t,n){let r=e.\u0275cmp;r.directiveDefs=Fu(t,eI),r.pipeDefs=Fu(n,rn)}function nB(e,t){return gr(()=>{let n=La(e);n.declarations=uu(t.declarations||Ne),n.imports=uu(t.imports||Ne),n.exports=uu(t.exports||Ne),t.bootstrap&&(n.bootstrap=uu(t.bootstrap)),cs.registerNgModule(e,t)})}function uu(e){if(typeof e=="function")return e;let t=nn(e);return t.some(Oo)?()=>t.map(Se).map(Pw):t.map(Pw)}function Pw(e){return Wp(e)?e.ngModule:e}function rB(e,t,n){let r=yt()+e,i=P();return i[r]===Pe?An(i,r,n?t.call(n):t()):$s(i,r)}function iB(e,t,n,r){return Gx(P(),yt(),e,t,n,r)}function oB(e,t,n,r,i){return Kx(P(),yt(),e,t,n,r,i)}function sB(e,t,n,r,i,o){return Qx(P(),yt(),e,t,n,r,i,o)}function aB(e,t,n,r,i,o,s){return Zx(P(),yt(),e,t,n,r,i,o,s)}function uB(e,t,n,r,i,o,s,a){let u=yt()+e,c=P(),d=qt(c,u,n,r,i,o);return Ue(c,u+4,s)||d?An(c,u+5,a?t.call(a,n,r,i,o,s):t(n,r,i,o,s)):$s(c,u+5)}function lB(e,t,n,r,i,o,s,a,u){let c=yt()+e,d=P(),p=qt(d,c,n,r,i,o);return qr(d,c+4,s,a)||p?An(d,c+6,u?t.call(u,n,r,i,o,s,a):t(n,r,i,o,s,a)):$s(d,c+6)}function cB(e,t,n,r,i,o,s,a,u,c){let d=yt()+e,p=P(),h=qt(p,d,n,r,i,o);return pl(p,d+4,s,a,u)||h?An(p,d+7,c?t.call(c,n,r,i,o,s,a,u):t(n,r,i,o,s,a,u)):$s(p,d+7)}function dB(e,t,n,r,i,o,s,a,u,c,d){let p=yt()+e,h=P(),g=qt(h,p,n,r,i,o);return qt(h,p+4,s,a,u,c)||g?An(h,p+8,d?t.call(d,n,r,i,o,s,a,u,c):t(n,r,i,o,s,a,u,c)):$s(h,p+8)}function fB(e,t,n,r){return Yx(P(),yt(),e,t,n,r)}function Os(e,t){let n=e[t];return n===Pe?void 0:n}function Gx(e,t,n,r,i,o){let s=t+n;return Ue(e,s,i)?An(e,s+1,o?r.call(o,i):r(i)):Os(e,s+1)}function Kx(e,t,n,r,i,o,s){let a=t+n;return qr(e,a,i,o)?An(e,a+2,s?r.call(s,i,o):r(i,o)):Os(e,a+2)}function Qx(e,t,n,r,i,o,s,a){let u=t+n;return pl(e,u,i,o,s)?An(e,u+3,a?r.call(a,i,o,s):r(i,o,s)):Os(e,u+3)}function Zx(e,t,n,r,i,o,s,a,u){let c=t+n;return qt(e,c,i,o,s,a)?An(e,c+4,u?r.call(u,i,o,s,a):r(i,o,s,a)):Os(e,c+4)}function Yx(e,t,n,r,i,o){let s=t+n,a=!1;for(let u=0;u<i.length;u++)Ue(e,s++,i[u])&&(a=!0);return a?An(e,s,r.apply(o,i)):Os(e,s)}function pB(e,t){let n=Ie(),r,i=e+me;n.firstCreatePass?(r=hB(t,n.pipeRegistry),n.data[i]=r,r.onDestroy&&(n.destroyHooks??=[]).push(i,r.onDestroy)):r=n.data[i];let o=r.factory||(r.factory=nr(r.type,!0)),s,a=wt(Ss);try{let u=Iu(!1),c=o();return Iu(u),Va(n,P(),i,c),c}finally{wt(a)}}function hB(e,t){if(t)for(let n=t.length-1;n>=0;n--){let r=t[n];if(e===r.name)return r}}function mB(e,t,n){let r=e+me,i=P(),o=cr(i,r);return Ps(i,r)?Gx(i,yt(),t,o.transform,n,o):o.transform(n)}function gB(e,t,n,r){let i=e+me,o=P(),s=cr(o,i);return Ps(o,i)?Kx(o,yt(),t,s.transform,n,r,s):s.transform(n,r)}function yB(e,t,n,r,i){let o=e+me,s=P(),a=cr(s,o);return Ps(s,o)?Qx(s,yt(),t,a.transform,n,r,i,a):a.transform(n,r,i)}function vB(e,t,n,r,i,o){let s=e+me,a=P(),u=cr(a,s);return Ps(a,s)?Zx(a,yt(),t,u.transform,n,r,i,o,u):u.transform(n,r,i,o)}function _B(e,t,n){let r=e+me,i=P(),o=cr(i,r);return Ps(i,r)?Yx(i,yt(),t,o.transform,n,o):o.transform.apply(o,n)}function Ps(e,t){return e[U].data[t].pure}function wB(e,t){return ul(e,t)}function bB(e,t){return()=>{try{return cs.getComponentDependencies(e,t).dependencies}catch(n){throw console.error(`Computing dependencies in local compilation mode for the component "${e.name}" failed with the exception:`,n),n}}}function IB(e,t){let n=Ge(e);n!==null&&(n.debugInfo=t)}function xB(e,t,n){let r=`./@ng/component?c=${e}&t=${encodeURIComponent(t)}`;return new URL(r,n).href}function EB(e,t,n,r,i=null,o=null){let s=Ge(e);t.apply(null,[e,n,...r]);let{newDef:a,oldDef:u}=TB(s,Ge(e));if(e[Ti]=a,u.tView){let c=HA().values();for(let d of c)ur(d)&&d[qe]===null&&vu(i,o,a,u,d)}}function TB(e,t){let n={...e};return{newDef:Object.assign(e,t,{directiveDefs:n.directiveDefs,pipeDefs:n.pipeDefs,setInput:n.setInput,type:n.type}),oldDef:n}}function vu(e,t,n,r,i){let o=i[U];if(o===r.tView){DB(e,t,n,r,i);return}for(let s=me;s<o.bindingStartIndex;s++){let a=i[s];if(Dt(a)){bt(a[ut])&&vu(e,t,n,r,a[ut]);for(let u=Ke;u<a.length;u++)vu(e,t,n,r,a[u])}else bt(a)&&vu(e,t,n,r,a)}}function CB(e,t){e.componentReplaced?.(t.id)}function DB(e,t,n,r,i){let o=i[Be],s=i[ut],a=i[qe],u=i[ct],c=i[Re].get(Ve,null),d=()=>{if(r.encapsulation===Un.ShadowDom){let y=s.cloneNode(!1);s.replaceWith(y),s=y}let p=Hb(n),h=Ju(a,p,o,Ap(n),s,u,null,null,null,null,null);SB(a,i,h,u.index),Ds(i[U],i);let g=i[on].rendererFactory;CB(g,r),h[be]=g.createRenderer(s,n),Kb(i[U],i),$B(u),sl(p,h,o),p0(p,h,p.template,o)};c===null?Lw(e,t,d):c.run(()=>Lw(e,t,d))}function Lw(e,t,n){try{n()}catch(r){let i=r;if(t!==null&&i.message){let o=i.message+(i.stack?`
`+i.stack:"");e?.hot?.send?.("angular:invalidate",{id:t,message:o,error:!0})}throw r}}function SB(e,t,n,r){for(let i=me;i<e[U].bindingStartIndex;i++){let o=e[i];if((bt(o)||Dt(o))&&o[lt]===t){o[lt]=n;break}}e[or]===t&&(e[or]=n),e[jo]===t&&(e[jo]=n),n[lt]=t[lt],t[lt]=null,e[r]=n}function $B(e){if(e.projection!==null){for(let t of e.projection)Qw(t)&&(t.projectionNext=null,t.flags&=-3);e.projection=null}}var Hn={\u0275\u0275animateEnter:hu,\u0275\u0275animateEnterListener:mu,\u0275\u0275animateLeave:gu,\u0275\u0275animateLeaveListener:np,\u0275\u0275attribute:MI,\u0275\u0275defineComponent:aP,\u0275\u0275defineDirective:cP,\u0275\u0275defineInjectable:Ae,\u0275\u0275defineInjector:Na,\u0275\u0275defineNgModule:tI,\u0275\u0275definePipe:dP,\u0275\u0275directiveInject:Ss,\u0275\u0275getInheritedFactory:SA,\u0275\u0275inject:mt,\u0275\u0275injectAttribute:bp,\u0275\u0275invalidFactory:_3,\u0275\u0275invalidFactoryDep:ld,\u0275\u0275templateRefExtractor:wB,\u0275\u0275resetView:f_,\u0275\u0275HostDirectivesFeature:bP,\u0275\u0275NgOnChangesFeature:cA,\u0275\u0275ProvidersFeature:Xz,\u0275\u0275CopyDefinitionFeature:wP,\u0275\u0275InheritDefinitionFeature:oI,\u0275\u0275ExternalStylesFeature:eB,\u0275\u0275nextContext:ZF,\u0275\u0275namespaceHTML:I_,\u0275\u0275namespaceMathML:b_,\u0275\u0275namespaceSVG:w_,\u0275\u0275enableBindings:l_,\u0275\u0275disableBindings:c_,\u0275\u0275elementStart:dh,\u0275\u0275elementEnd:fh,\u0275\u0275element:FI,\u0275\u0275elementContainerStart:mh,\u0275\u0275elementContainerEnd:_l,\u0275\u0275domElement:zI,\u0275\u0275domElementStart:ph,\u0275\u0275domElementEnd:hh,\u0275\u0275domElementContainer:HI,\u0275\u0275domElementContainerStart:gh,\u0275\u0275domElementContainerEnd:VI,\u0275\u0275domTemplate:lI,\u0275\u0275domListener:cx,\u0275\u0275elementContainer:jI,\u0275\u0275pureFunction0:rB,\u0275\u0275pureFunction1:iB,\u0275\u0275pureFunction2:oB,\u0275\u0275pureFunction3:sB,\u0275\u0275pureFunction4:aB,\u0275\u0275pureFunction5:uB,\u0275\u0275pureFunction6:lB,\u0275\u0275pureFunction7:cB,\u0275\u0275pureFunction8:dB,\u0275\u0275pureFunctionV:fB,\u0275\u0275getCurrentView:oF,\u0275\u0275restoreView:d_,\u0275\u0275listener:ux,\u0275\u0275projection:XF,\u0275\u0275syntheticHostProperty:qI,\u0275\u0275syntheticHostListener:lx,\u0275\u0275pipeBind1:mB,\u0275\u0275pipeBind2:gB,\u0275\u0275pipeBind3:yB,\u0275\u0275pipeBind4:vB,\u0275\u0275pipeBindV:_B,\u0275\u0275projectionDef:JF,\u0275\u0275domProperty:WI,\u0275\u0275ariaProperty:$I,\u0275\u0275property:LI,\u0275\u0275pipe:pB,\u0275\u0275queryRefresh:rz,\u0275\u0275queryAdvance:az,\u0275\u0275viewQuery:nz,\u0275\u0275viewQuerySignal:sz,\u0275\u0275loadQuery:iz,\u0275\u0275contentQuery:tz,\u0275\u0275contentQuerySignal:oz,\u0275\u0275reference:uz,\u0275\u0275classMap:xz,\u0275\u0275styleMap:bz,\u0275\u0275styleProp:mx,\u0275\u0275classProp:gx,\u0275\u0275advance:iO,\u0275\u0275template:uI,\u0275\u0275conditional:YL,\u0275\u0275conditionalCreate:ZL,\u0275\u0275conditionalBranchCreate:ch,\u0275\u0275defer:pL,\u0275\u0275deferWhen:hL,\u0275\u0275deferOnIdle:vL,\u0275\u0275deferOnImmediate:bL,\u0275\u0275deferOnTimer:EL,\u0275\u0275deferOnHover:DL,\u0275\u0275deferOnInteraction:ML,\u0275\u0275deferOnViewport:AL,\u0275\u0275deferPrefetchWhen:mL,\u0275\u0275deferPrefetchOnIdle:_L,\u0275\u0275deferPrefetchOnImmediate:IL,\u0275\u0275deferPrefetchOnTimer:TL,\u0275\u0275deferPrefetchOnHover:SL,\u0275\u0275deferPrefetchOnInteraction:NL,\u0275\u0275deferPrefetchOnViewport:RL,\u0275\u0275deferHydrateWhen:gL,\u0275\u0275deferHydrateNever:yL,\u0275\u0275deferHydrateOnIdle:wL,\u0275\u0275deferHydrateOnImmediate:xL,\u0275\u0275deferHydrateOnTimer:CL,\u0275\u0275deferHydrateOnHover:$L,\u0275\u0275deferHydrateOnInteraction:kL,\u0275\u0275deferHydrateOnViewport:OL,\u0275\u0275deferEnableTimerScheduling:JP,\u0275\u0275repeater:tF,\u0275\u0275repeaterCreate:eF,\u0275\u0275repeaterTrackByIndex:JL,\u0275\u0275repeaterTrackByIdentity:XL,\u0275\u0275componentInstance:KL,\u0275\u0275text:Az,\u0275\u0275textInterpolate:Ax,\u0275\u0275textInterpolate1:vh,\u0275\u0275textInterpolate2:Rx,\u0275\u0275textInterpolate3:Ox,\u0275\u0275textInterpolate4:Px,\u0275\u0275textInterpolate5:Lx,\u0275\u0275textInterpolate6:Fx,\u0275\u0275textInterpolate7:zx,\u0275\u0275textInterpolate8:Bx,\u0275\u0275textInterpolateV:jx,\u0275\u0275i18n:qF,\u0275\u0275i18nAttributes:GF,\u0275\u0275i18nExp:ax,\u0275\u0275i18nStart:ox,\u0275\u0275i18nEnd:sx,\u0275\u0275i18nApply:KF,\u0275\u0275i18nPostprocess:QF,\u0275\u0275resolveWindow:zR,\u0275\u0275resolveDocument:BR,\u0275\u0275resolveBody:jR,\u0275\u0275setComponentScope:tB,\u0275\u0275setNgModuleScope:nB,\u0275\u0275registerNgModuleType:Y0,\u0275\u0275getComponentDepsFactory:bB,\u0275setClassDebugInfo:IB,\u0275\u0275declareLet:Wx,\u0275\u0275storeLet:Pz,\u0275\u0275readContextLet:Lz,\u0275\u0275attachSourceLocations:Fz,\u0275\u0275interpolate:zz,\u0275\u0275interpolate1:Bz,\u0275\u0275interpolate2:jz,\u0275\u0275interpolate3:Vz,\u0275\u0275interpolate4:Hz,\u0275\u0275interpolate5:Uz,\u0275\u0275interpolate6:Wz,\u0275\u0275interpolate7:qz,\u0275\u0275interpolate8:Gz,\u0275\u0275interpolateV:Kz,\u0275\u0275sanitizeHtml:DR,\u0275\u0275sanitizeStyle:SR,\u0275\u0275sanitizeResourceUrl:Ob,\u0275\u0275sanitizeScript:$R,\u0275\u0275sanitizeUrl:Rb,\u0275\u0275sanitizeUrlOrResourceUrl:AR,\u0275\u0275trustConstantHtml:MR,\u0275\u0275trustConstantResourceUrl:NR,\u0275\u0275validateIframeAttribute:oP,forwardRef:Ma,resolveForwardRef:Se,\u0275\u0275twoWayProperty:Vx,\u0275\u0275twoWayBindingSet:Oz,\u0275\u0275twoWayListener:Hx,\u0275\u0275replaceMetadata:EB,\u0275\u0275getReplaceMetadataURL:xB},Yo=null;function Jx(e){Yo!==null&&(e.defaultEncapsulation!==Yo.defaultEncapsulation||e.preserveWhitespaces!==Yo.preserveWhitespaces)||(Yo=e)}function MB(){return Yo}var _u=[];function NB(e,t){_u.push({moduleType:e,ngModule:t})}var pf=!1;function kB(){if(!pf){pf=!0;try{for(let e=_u.length-1;e>=0;e--){let{moduleType:t,ngModule:n}=_u[e];n.declarations&&n.declarations.every(Xx)&&(_u.splice(e,1),OB(t,n))}}finally{pf=!1}}}function Xx(e){return Array.isArray(e)?e.every(Xx):!!Se(e)}function AB(e,t={}){RB(e,t),t.id!==void 0&&Y0(e,t.id),NB(e,t)}function RB(e,t,n=!1){let r=nn(t.declarations||Ne),i=null;Object.defineProperty(e,sd,{configurable:!0,get:()=>(i===null&&(i=Pt({usage:0,kind:"NgModule",type:e}).compileNgModule(Hn,`ng:///${e.name}/\u0275mod.js`,{type:e,bootstrap:nn(t.bootstrap||Ne).map(Se),declarations:r.map(Se),imports:nn(t.imports||Ne).map(Se).map(Fw),exports:nn(t.exports||Ne).map(Se).map(Fw),schemas:t.schemas?nn(t.schemas):null,id:t.id||null}),i.schemas||(i.schemas=[])),i)});let o=null;Object.defineProperty(e,wn,{get:()=>{if(o===null){let a=Pt({usage:0,kind:"NgModule",type:e});o=a.compileFactory(Hn,`ng:///${e.name}/\u0275fac.js`,{name:e.name,type:e,deps:Zu(e),target:a.FactoryTarget.NgModule,typeArgumentCount:0})}return o},configurable:!1});let s=null;Object.defineProperty(e,Ca,{get:()=>{if(s===null){let a={name:e.name,type:e,providers:t.providers||Ne,imports:[(t.imports||Ne).map(Se),(t.exports||Ne).map(Se)]};s=Pt({usage:0,kind:"NgModule",type:e}).compileInjector(Hn,`ng:///${e.name}/\u0275inj.js`,a)}return s},configurable:!1})}function OB(e,t){let n=nn(t.declarations||Ne),r=tE(e);n.forEach(i=>{if(i=Se(i),i.hasOwnProperty(Ti)){let s=Ge(i);eE(s,r)}else!i.hasOwnProperty(ka)&&!i.hasOwnProperty(Aa)&&(i.ngSelectorScope=e)})}function eE(e,t){e.directiveDefs=()=>Array.from(t.compilation.directives).map(n=>n.hasOwnProperty(Ti)?Ge(n):Rt(n)).filter(n=>!!n),e.pipeDefs=()=>Array.from(t.compilation.pipes).map(n=>rn(n)),e.schemas=t.schemas,e.tView=null}function tE(e){if(Pi(e)){let t=cs.getNgModuleScope(e);return{schemas:La(e).schemas||null,...t}}else if(Fa(e)){if((Ge(e)||Rt(e))!==null)return{schemas:null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set([e]),pipes:new Set}};if(rn(e)!==null)return{schemas:null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set,pipes:new Set([e])}}}throw new Error(`${e.name} does not have a module def (\u0275mod property)`)}function Fw(e){return Wp(e)?e.ngModule:e}var hf=0;function PB(e,t){let n=null;X3(e,t),iE(e,t),Object.defineProperty(e,Ti,{get:()=>{if(n===null){let r=Pt({usage:0,kind:"component",type:e});if(Q0(t)){let d=[`Component '${e.name}' is not resolved:`];throw t.templateUrl&&d.push(` - templateUrl: ${t.templateUrl}`),t.styleUrls&&t.styleUrls.length&&d.push(` - styleUrls: ${JSON.stringify(t.styleUrls)}`),t.styleUrl&&d.push(` - styleUrl: ${t.styleUrl}`),d.push("Did you run and wait for 'resolveComponentResources()'?"),new Error(d.join(`
`))}let i=MB(),o=t.preserveWhitespaces;o===void 0&&(i!==null&&i.preserveWhitespaces!==void 0?o=i.preserveWhitespaces:o=!1);let s=t.encapsulation;s===void 0&&(i!==null&&i.defaultEncapsulation!==void 0?s=i.defaultEncapsulation:s=Un.Emulated);let a=t.templateUrl||`ng:///${e.name}/template.html`,u=oE(e,t),c={...u,typeSourceSpan:r.createParseSourceSpan("Component",e.name,a),template:t.template||"",preserveWhitespaces:o,styles:typeof t.styles=="string"?[t.styles]:t.styles||Ne,animations:t.animations,declarations:[],changeDetection:t.changeDetection,encapsulation:s,interpolation:t.interpolation,viewProviders:t.viewProviders||null,hasDirectiveDependencies:!u.isStandalone||t.imports!=null&&t.imports.length>0};hf++;try{if(c.usesInheritance&&sE(e),n=r.compileComponent(Hn,a,c),c.isStandalone){let d=nn(t.imports||Ne),{directiveDefs:p,pipeDefs:h}=LB(e,d);n.directiveDefs=p,n.pipeDefs=h,n.dependencies=()=>d.map(Se)}}finally{hf--}if(hf===0&&kB(),FB(e)){let d=tE(e.ngSelectorScope);eE(n,d)}if(t.schemas)if(c.isStandalone)n.schemas=t.schemas;else throw new Error(`The 'schemas' was specified for the ${tn(e)} but is only valid on a component that is standalone.`);else c.isStandalone&&(n.schemas=[])}return n},set:r=>{n=r},configurable:!1})}function LB(e,t){return{directiveDefs:()=>Xo(e)?[...cs.getStandaloneComponentScope(e,t).compilation.directives].map(o=>Ge(o)||Rt(o)).filter(o=>o!==null):[],pipeDefs:()=>Xo(e)?[...cs.getStandaloneComponentScope(e,t).compilation.pipes].map(o=>rn(o)).filter(o=>o!==null):[]}}function FB(e){return e.ngSelectorScope!==void 0}function nE(e,t){let n=null;iE(e,t||{}),Object.defineProperty(e,ka,{get:()=>{if(n===null){let r=rE(e,t||{});n=Pt({usage:0,kind:"directive",type:e}).compileDirective(Hn,r.sourceMapUrl,r.metadata)}return n},configurable:!1})}function rE(e,t){let n=e&&e.name,r=`ng:///${n}/\u0275dir.js`,i=Pt({usage:0,kind:"directive",type:e}),o=oE(e,t);return o.typeSourceSpan=i.createParseSourceSpan("Directive",n,r),o.usesInheritance&&sE(e),{metadata:o,sourceMapUrl:r}}function iE(e,t){let n=null;Object.defineProperty(e,wn,{get:()=>{if(n===null){let r=rE(e,t),i=Pt({usage:0,kind:"directive",type:e});n=i.compileFactory(Hn,`ng:///${e.name}/\u0275fac.js`,{name:r.metadata.name,type:r.metadata.type,typeArgumentCount:0,deps:Zu(e),target:i.FactoryTarget.Directive})}return n},configurable:!1})}function zB(e){return Object.getPrototypeOf(e.prototype)===Object.prototype}function oE(e,t){let n=Ip(),r=n.ownPropMetadata(e);return{name:e.name,type:e,selector:t.selector!==void 0?t.selector:null,host:t.host||Wt,propMetadata:r,inputs:t.inputs||Ne,outputs:t.outputs||Ne,queries:zw(e,r,aE),lifecycle:{usesOnChanges:n.hasLifecycleHook(e,"ngOnChanges")},typeSourceSpan:null,usesInheritance:!zB(e),exportAs:VB(t.exportAs),providers:t.providers||null,viewQueries:zw(e,r,uE),isStandalone:t.standalone===void 0?!0:!!t.standalone,isSignal:!!t.signals,hostDirectives:t.hostDirectives?.map(i=>typeof i=="function"?{directive:i}:i)||null}}function sE(e){let t=Object.prototype,n=Object.getPrototypeOf(e.prototype).constructor;for(;n&&n!==t;)!Rt(n)&&!Ge(n)&&UB(n)&&nE(n,null),n=Object.getPrototypeOf(n)}function BB(e){return typeof e=="string"?cE(e):Se(e)}function jB(e,t){return{propertyName:e,predicate:BB(t.selector),descendants:t.descendants,first:t.first,read:t.read?t.read:null,static:!!t.static,emitDistinctChangesOnly:!!t.emitDistinctChangesOnly,isSignal:!!t.isSignal}}function zw(e,t,n){let r=[];for(let i in t)if(t.hasOwnProperty(i)){let o=t[i];o.forEach(s=>{if(n(s)){if(!s.selector)throw new Error(`Can't construct a query for the property "${i}" of "${tn(e)}" since the query selector wasn't defined.`);if(o.some(lE))throw new Error("Cannot combine @Input decorators with query decorators");r.push(jB(i,s))}})}return r}function VB(e){return e===void 0?null:cE(e)}function aE(e){let t=e.ngMetadataName;return t==="ContentChild"||t==="ContentChildren"}function uE(e){let t=e.ngMetadataName;return t==="ViewChild"||t==="ViewChildren"}function lE(e){return e.ngMetadataName==="Input"}function cE(e){return e.split(",").map(t=>t.trim())}var HB=["ngOnChanges","ngOnInit","ngOnDestroy","ngDoCheck","ngAfterViewInit","ngAfterViewChecked","ngAfterContentInit","ngAfterContentChecked"];function UB(e){let t=Ip();if(HB.some(r=>t.hasLifecycleHook(e,r)))return!0;let n=t.propMetadata(e);for(let r in n){let i=n[r];for(let o=0;o<i.length;o++){let s=i[o],a=s.ngMetadataName;if(lE(s)||aE(s)||uE(s)||a==="Output"||a==="HostBinding"||a==="HostListener")return!0}}return!1}function WB(e,t){let n=null,r=null;Object.defineProperty(e,wn,{get:()=>{if(r===null){let i=Bw(e,t),o=Pt({usage:0,kind:"pipe",type:i.type});r=o.compileFactory(Hn,`ng:///${i.name}/\u0275fac.js`,{name:i.name,type:i.type,typeArgumentCount:0,deps:Zu(e),target:o.FactoryTarget.Pipe})}return r},configurable:!1}),Object.defineProperty(e,Aa,{get:()=>{if(n===null){let i=Bw(e,t);n=Pt({usage:0,kind:"pipe",type:i.type}).compilePipe(Hn,`ng:///${i.name}/\u0275pipe.js`,i)}return n},configurable:!1})}function Bw(e,t){return{type:e,name:e.name,pipeName:t.name,pure:t.pure!==void 0?t.pure:!0,isStandalone:t.standalone===void 0?!0:!!t.standalone}}var qB=_s("Directive",(e={})=>e,void 0,void 0,(e,t)=>nE(e,t)),UU=_s("Component",(e={})=>({changeDetection:Eu.Default,...e}),qB,void 0,(e,t)=>PB(e,t)),WU=_s("Pipe",e=>({pure:!0,...e}),void 0,void 0,(e,t)=>WB(e,t)),qU=qn("Input",e=>e?typeof e=="string"?{alias:e}:e:{}),GU=qn("Output",e=>({alias:e})),KU=qn("HostBinding",e=>({hostPropertyName:e})),QU=qn("HostListener",(e,t)=>({eventName:e,args:t})),GB=_s("NgModule",e=>e,void 0,void 0,(e,t)=>AB(e,t)),gp=class{ngModuleFactory;componentFactories;constructor(t,n){this.ngModuleFactory=t,this.componentFactories=n}},jw=class e{compileModuleSync(t){return new hs(t)}compileModuleAsync(t){return Promise.resolve(this.compileModuleSync(t))}compileModuleAndAllComponentsSync(t){let n=this.compileModuleSync(t),r=Ar(t),i=ji(r.declarations).reduce((o,s)=>{let a=Ge(s);return a&&o.push(new Xi(a)),o},[]);return new gp(n,i)}compileModuleAndAllComponentsAsync(t){return Promise.resolve(this.compileModuleAndAllComponentsSync(t))}clearCache(){}clearCacheFor(t){}getModuleId(t){}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})},dE=new ne("");var yp=class e{zone=re(Ve);changeDetectionScheduler=re(In);applicationRef=re(Wn);applicationErrorHandler=re(Mn);_onMicrotaskEmptySubscription;initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{try{this.applicationRef.dirtyFlags|=1,this.applicationRef._tick()}catch(t){this.applicationErrorHandler(t)}})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})},KB=new ne("",{factory:()=>!1});function fE({ngZoneFactory:e,ignoreChangesOutsideZone:t,scheduleInRootZone:n}){return e??=()=>new Ve({..._h(),scheduleInRootZone:n}),[{provide:Ve,useFactory:e},{provide:kr,multi:!0,useFactory:()=>{let r=re(yp,{optional:!0});return()=>r.initialize()}},{provide:kr,multi:!0,useFactory:()=>{let r=re(vp);return()=>{r.initialize()}}},t===!0?{provide:qd,useValue:!0}:[],{provide:Gd,useValue:n??fI},{provide:Mn,useFactory:()=>{let r=re(Ve),i=re(Vt),o;return s=>{r.runOutsideAngular(()=>{i.destroyed&&!o?setTimeout(()=>{throw s}):(o??=i.get(bn),o.handleError(s))})}}}]}function _h(e){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:e?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:e?.runCoalescing??!1}}var vp=class e{subscription=new _t;initialized=!1;zone=re(Ve);pendingTasks=re(en);initialize(){if(this.initialized)return;this.initialized=!0;let t=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(t=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{Ve.assertNotInAngularZone(),queueMicrotask(()=>{t!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(t),t=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{Ve.assertInAngularZone(),t??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})};var Qu=class e{applicationErrorHandler=re(Mn);appRef=re(Wn);taskService=re(en);ngZone=re(Ve);zonelessEnabled=re(Wd);tracing=re(Ns,{optional:!0});disableScheduling=re(qd,{optional:!0})??!1;zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new _t;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(Bu):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(re(Gd,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof ju||!this.zoneIsDefined)}notify(t){if(!this.zonelessEnabled&&t===5)return;let n=!1;switch(t){case 0:{this.appRef.dirtyFlags|=2;break}case 3:case 2:case 4:case 5:case 1:{this.appRef.dirtyFlags|=4;break}case 6:{this.appRef.dirtyFlags|=2,n=!0;break}case 12:{this.appRef.dirtyFlags|=16,n=!0;break}case 13:{this.appRef.dirtyFlags|=2,n=!0;break}case 11:{n=!0;break}case 9:case 8:case 7:case 10:default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick(n))return;let r=this.useMicrotaskScheduler?fw:pI;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>r(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>r(()=>this.tick()))}shouldScheduleTick(t){return!(this.disableScheduling&&!t||this.appRef.destroyed||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(Bu+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(this.appRef.dirtyFlags===0){this.cleanup();return}!this.zonelessEnabled&&this.appRef.dirtyFlags&7&&(this.appRef.dirtyFlags|=1);let t=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(n){this.taskService.remove(t),this.applicationErrorHandler(n)}finally{this.cleanup()}this.useMicrotaskScheduler=!0,fw(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(t)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let t=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(t)}}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})};function QB(){return typeof $localize<"u"&&$localize.locale||Rs}var wh=new ne("",{providedIn:"root",factory:()=>re(wh,{optional:!0,skipSelf:!0})||QB()}),ZU=new ne("",{providedIn:"root",factory:()=>pF}),YU=new ne(""),JU=new ne(""),Vw;(function(e){e[e.Error=0]="Error",e[e.Warning=1]="Warning",e[e.Ignore=2]="Ignore"})(Vw||(Vw={}));var wl=class{destroyed=!1;listeners=null;errorHandler=re(bn,{optional:!0});destroyRef=re(Xt);constructor(){this.destroyRef.onDestroy(()=>{this.destroyed=!0,this.listeners=null})}subscribe(t){if(this.destroyed)throw new ie(953,!1);return(this.listeners??=[]).push(t),{unsubscribe:()=>{let n=this.listeners?.indexOf(t);n!==void 0&&n!==-1&&this.listeners?.splice(n,1)}}}emit(t){if(this.destroyed){console.warn(Nr(953,!1));return}if(this.listeners===null)return;let n=ae(null);try{for(let r of this.listeners)try{r(t)}catch(i){this.errorHandler?.handleError(i)}}finally{ae(n)}}};var pE=class{[it];constructor(t){this[it]=t}destroy(){this[it].destroy()}};var Sl=Symbol("InputSignalNode#UNSET"),$E={..._a,transformFn:void 0,applyValueToInputSignal(e,t){vi(e,t)}};function ME(e,t){let n=Object.create($E);n.value=e,n.transformFn=t?.transform;function r(){if(gi(n),n.value===Sl){let i=null;throw new ie(-950,i)}return n.value}return r[it]=n,r}var hE;(function(e){e[e.Directive=0]="Directive",e[e.Component=1]="Component",e[e.Injectable=2]="Injectable",e[e.Pipe=3]="Pipe",e[e.NgModule=4]="NgModule"})(hE||(hE={}));var mE;(function(e){e[e.Directive=0]="Directive",e[e.Pipe=1]="Pipe",e[e.NgModule=2]="NgModule"})(mE||(mE={}));var gE;(function(e){e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom"})(gE||(gE={}));var ZB=new ne("");ZB.__NG_ELEMENT_ID__=e=>{let t=ge();if(t===null)throw new ie(204,!1);if(t.type&2)return t.value;if(e&8)return null;throw new ie(204,!1)};function yE(e,t){return ME(e,t)}function YB(e){return ME(Sl,e)}var Aq=(yE.required=YB,yE);function vE(e,t){return Yp(t)}function JB(e,t){return Jp(t)}var Rq=(vE.required=JB,vE);function _E(e,t){return Yp(t)}function XB(e,t){return Jp(t)}var Oq=(_E.required=XB,_E);function NE(e,t){let n=Object.create($E),r=new wl;n.value=e;function i(){return gi(n),wE(n.value),n.value}return i[it]=n,i.asReadonly=Xa.bind(i),i.set=o=>{n.equal(n.value,o)||(vi(n,o),r.emit(o))},i.update=o=>{wE(n.value),i.set(o(n.value))},i.subscribe=r.subscribe.bind(r),i.destroyRef=r.destroyRef,i}function wE(e){if(e===Sl)throw new ie(952,!1)}function bE(e,t){return NE(e,t)}function ej(e){return NE(Sl,e)}var Pq=(bE.required=ej,bE),kE=!0,po=class{},Lq=qn("ContentChildren",(e,t={})=>({selector:e,first:!1,isViewQuery:!1,descendants:!1,emitDistinctChangesOnly:kE,...t}),po),Fq=qn("ContentChild",(e,t={})=>({selector:e,first:!0,isViewQuery:!1,descendants:!0,...t}),po),zq=qn("ViewChildren",(e,t={})=>({selector:e,first:!1,isViewQuery:!0,descendants:!0,emitDistinctChangesOnly:kE,...t}),po),Bq=qn("ViewChild",(e,t)=>({selector:e,first:!0,isViewQuery:!0,descendants:!0,...t}),po);function tj(e,t,n){let r=new hs(n);return Promise.resolve(r)}function IE(e){for(let t=e.length-1;t>=0;t--)if(e[t]!==void 0)return e[t]}var nj=200,xE=1200,EE=class e{window=null;observer=null;options=re(hb);lcpImageUrl;start(){if(typeof PerformanceObserver>"u"||this.options?.disableImageSizeWarning&&this.options?.disableImageLazyLoadWarning)return;this.observer=this.initPerformanceObserver();let t=Qr(),n=t.defaultView;if(n){this.window=n;let r=()=>{setTimeout(this.scanImages.bind(this),nj)},i=()=>{t.readyState==="complete"?r():this.window?.addEventListener("load",r,{once:!0})};typeof Zone<"u"?Zone.root.run(()=>i()):i()}}ngOnDestroy(){this.observer?.disconnect()}initPerformanceObserver(){if(typeof PerformanceObserver>"u")return null;let t=new PerformanceObserver(n=>{let r=n.getEntries();if(r.length===0)return;let o=r[r.length-1].element?.src??"";o.startsWith("data:")||o.startsWith("blob:")||(this.lcpImageUrl=o)});return t.observe({type:"largest-contentful-paint",buffered:!0}),t}scanImages(){let t=Qr().querySelectorAll("img"),n,r=!1;for(let i=0;i<t.length;i++){let o=t[i];o&&(this.options?.disableImageSizeWarning||!o.getAttribute("ng-img")&&this.isOversized(o)&&ij(o.src),!this.options?.disableImageLazyLoadWarning&&this.lcpImageUrl&&o.src===this.lcpImageUrl&&(n=!0,(o.loading!=="lazy"||o.getAttribute("ng-img"))&&(r=!0)))}n&&!r&&this.lcpImageUrl&&!this.options?.disableImageLazyLoadWarning&&rj(this.lcpImageUrl)}isOversized(t){if(!this.window)return!1;let n=[".svg"],r=(t.src||"").toLowerCase();if(n.some(w=>r.endsWith(w)))return!1;let i=this.window.getComputedStyle(t),o=parseFloat(i.getPropertyValue("width")),s=parseFloat(i.getPropertyValue("height")),a=i.getPropertyValue("box-sizing");if(i.getPropertyValue("object-fit")==="cover")return!1;if(a==="border-box"){let w=i.getPropertyValue("padding-top"),x=i.getPropertyValue("padding-right"),I=i.getPropertyValue("padding-bottom"),b=i.getPropertyValue("padding-left");o-=parseFloat(x)+parseFloat(b),s-=parseFloat(w)+parseFloat(I)}let c=t.naturalWidth,d=t.naturalHeight,p=this.window.devicePixelRatio*o,h=this.window.devicePixelRatio*s,g=c-p>=xE,y=d-h>=xE;return g||y}static \u0275fac=function(n){return new(n||e)};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"root"})};function rj(e){console.warn(Nr(-913,`An image with src ${e} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`))}function ij(e){console.warn(Nr(-913,`An image with src ${e} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`))}var bl=new ne(""),oj=new ne("");function Ls(e){return!e.moduleRef}function sj(e){let t=Ls(e)?e.r3Injector:e.moduleRef.injector,n=t.get(Ve);return n.run(()=>{Ls(e)?e.r3Injector.resolveInjectorInitializers():e.moduleRef.resolveInjectorInitializers();let r=t.get(Mn),i;if(n.runOutsideAngular(()=>{i=n.onError.subscribe({next:r})}),Ls(e)){let o=()=>t.destroy(),s=e.platformInjector.get(bl);s.add(o),t.onDestroy(()=>{i.unsubscribe(),s.delete(o)})}else{let o=()=>e.moduleRef.destroy(),s=e.platformInjector.get(bl);s.add(o),e.moduleRef.onDestroy(()=>{es(e.allPlatformModules,e.moduleRef),i.unsubscribe(),s.delete(o)})}return uj(r,n,()=>{let o=t.get(en),s=o.add(),a=t.get(gs);return a.runInitializers(),a.donePromise.then(()=>{let u=t.get(wh,Rs);if(ZI(u||Rs),!t.get(oj,!0))return Ls(e)?t.get(Wn):(e.allPlatformModules.push(e.moduleRef),e.moduleRef);if(Ls(e)){let d=t.get(Wn);return e.rootComponent!==void 0&&d.bootstrap(e.rootComponent),d}else return AE?.(e.moduleRef,e.allPlatformModules),e.moduleRef}).finally(()=>void o.remove(s))})})}var AE;function TE(){AE=aj}function aj(e,t){let n=e.injector.get(Wn);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(r=>n.bootstrap(r));else if(e.instance.ngDoBootstrap)e.instance.ngDoBootstrap(n);else throw new ie(-403,!1);t.push(e)}function uj(e,t,n){try{let r=n();return ih(r)?r.catch(i=>{throw t.runOutsideAngular(()=>e(i)),i}):r}catch(r){throw t.runOutsideAngular(()=>e(r)),r}}var Il=class e{_injector;_modules=[];_destroyListeners=[];_destroyed=!1;constructor(t){this._injector=t}bootstrapModuleFactory(t,n){let r=n?.scheduleInRootZone,i=()=>mI(n?.ngZone,{..._h({eventCoalescing:n?.ngZoneEventCoalescing,runCoalescing:n?.ngZoneRunCoalescing}),scheduleInRootZone:r}),o=n?.ignoreChangesOutsideZone,s=[fE({ngZoneFactory:i,ignoreChangesOutsideZone:o}),{provide:In,useExisting:Qu},T_],a=J0(t.moduleType,this.injector,s);return TE(),sj({moduleRef:a,allPlatformModules:this._modules,platformInjector:this.injector})}bootstrapModule(t,n=[]){let r=oh({},n);return TE(),tj(this.injector,r,t).then(i=>this.bootstrapModuleFactory(i,r))}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new ie(404,!1);this._modules.slice().forEach(n=>n.destroy()),this._destroyListeners.forEach(n=>n());let t=this._injector.get(bl,null);t&&(t.forEach(n=>n()),t.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}static \u0275fac=function(n){return new(n||e)(mt(Ht))};static \u0275prov=Ae({token:e,factory:e.\u0275fac,providedIn:"platform"})},Ch=null;function lj(e){if(Dh())throw new ie(400,!1);EI(),Ch=e;let t=e.get(Il);return pj(e),t}function cj(e,t,n=[]){let r=`Platform: ${t}`,i=new ne(r);return(o=[])=>{let s=Dh();if(!s){let a=[...n,...o,{provide:i,useValue:!0}];s=e?.(a)??lj(dj(a,r))}return fj(i)}}function dj(e=[],t){return Ht.create({name:t,providers:[{provide:md,useValue:"platform"},{provide:bl,useValue:new Set([()=>Ch=null])},...e]})}function fj(e){let t=Dh();if(!t)throw new ie(-401,!1);return t}function Dh(){return Ch?.get(Il)??null}function pj(e){let t=e.get(pb,null);Ba(e,()=>{t?.forEach(n=>n())})}function RE(){return!1}var xl=class{constructor(){}supports(t){return Kp(t)}create(t){return new bh(t)}},hj=(e,t)=>t,bh=class{length=0;collection;_linkedRecords=null;_unlinkedRecords=null;_previousItHead=null;_itHead=null;_itTail=null;_additionsHead=null;_additionsTail=null;_movesHead=null;_movesTail=null;_removalsHead=null;_removalsTail=null;_identityChangesHead=null;_identityChangesTail=null;_trackByFn;constructor(t){this._trackByFn=t||hj}forEachItem(t){let n;for(n=this._itHead;n!==null;n=n._next)t(n)}forEachOperation(t){let n=this._itHead,r=this._removalsHead,i=0,o=null;for(;n||r;){let s=!r||n&&n.currentIndex<CE(r,i,o)?n:r,a=CE(s,i,o),u=s.currentIndex;if(s===r)i--,r=r._nextRemoved;else if(n=n._next,s.previousIndex==null)i++;else{o||(o=[]);let c=a-i,d=u-i;if(c!=d){for(let h=0;h<c;h++){let g=h<o.length?o[h]:o[h]=0,y=g+h;d<=y&&y<c&&(o[h]=g+1)}let p=s.previousIndex;o[p]=d-c}}a!==u&&t(s,a,u)}}forEachPreviousItem(t){let n;for(n=this._previousItHead;n!==null;n=n._nextPrevious)t(n)}forEachAddedItem(t){let n;for(n=this._additionsHead;n!==null;n=n._nextAdded)t(n)}forEachMovedItem(t){let n;for(n=this._movesHead;n!==null;n=n._nextMoved)t(n)}forEachRemovedItem(t){let n;for(n=this._removalsHead;n!==null;n=n._nextRemoved)t(n)}forEachIdentityChange(t){let n;for(n=this._identityChangesHead;n!==null;n=n._nextIdentityChange)t(n)}diff(t){if(t==null&&(t=[]),!Kp(t))throw new ie(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let n=this._itHead,r=!1,i,o,s;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)o=t[a],s=this._trackByFn(a,o),n===null||!Object.is(n.trackById,s)?(n=this._mismatch(n,o,s,a),r=!0):(r&&(n=this._verifyReinsertion(n,o,s,a)),Object.is(n.item,o)||this._addIdentityChange(n,o)),n=n._next}else i=0,A0(t,a=>{s=this._trackByFn(i,a),n===null||!Object.is(n.trackById,s)?(n=this._mismatch(n,a,s,i),r=!0):(r&&(n=this._verifyReinsertion(n,a,s,i)),Object.is(n.item,a)||this._addIdentityChange(n,a)),n=n._next,i++}),this.length=i;return this._truncate(n),this.collection=t,this.isDirty}get isDirty(){return this._additionsHead!==null||this._movesHead!==null||this._removalsHead!==null||this._identityChangesHead!==null}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;t!==null;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;t!==null;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;t!==null;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,n,r,i){let o;return t===null?o=this._itTail:(o=t._prev,this._remove(t)),t=this._unlinkedRecords===null?null:this._unlinkedRecords.get(r,null),t!==null?(Object.is(t.item,n)||this._addIdentityChange(t,n),this._reinsertAfter(t,o,i)):(t=this._linkedRecords===null?null:this._linkedRecords.get(r,i),t!==null?(Object.is(t.item,n)||this._addIdentityChange(t,n),this._moveAfter(t,o,i)):t=this._addAfter(new Ih(n,r),o,i)),t}_verifyReinsertion(t,n,r,i){let o=this._unlinkedRecords===null?null:this._unlinkedRecords.get(r,null);return o!==null?t=this._reinsertAfter(o,t._prev,i):t.currentIndex!=i&&(t.currentIndex=i,this._addToMoves(t,i)),t}_truncate(t){for(;t!==null;){let n=t._next;this._addToRemovals(this._unlink(t)),t=n}this._unlinkedRecords!==null&&this._unlinkedRecords.clear(),this._additionsTail!==null&&(this._additionsTail._nextAdded=null),this._movesTail!==null&&(this._movesTail._nextMoved=null),this._itTail!==null&&(this._itTail._next=null),this._removalsTail!==null&&(this._removalsTail._nextRemoved=null),this._identityChangesTail!==null&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,n,r){this._unlinkedRecords!==null&&this._unlinkedRecords.remove(t);let i=t._prevRemoved,o=t._nextRemoved;return i===null?this._removalsHead=o:i._nextRemoved=o,o===null?this._removalsTail=i:o._prevRemoved=i,this._insertAfter(t,n,r),this._addToMoves(t,r),t}_moveAfter(t,n,r){return this._unlink(t),this._insertAfter(t,n,r),this._addToMoves(t,r),t}_addAfter(t,n,r){return this._insertAfter(t,n,r),this._additionsTail===null?this._additionsTail=this._additionsHead=t:this._additionsTail=this._additionsTail._nextAdded=t,t}_insertAfter(t,n,r){let i=n===null?this._itHead:n._next;return t._next=i,t._prev=n,i===null?this._itTail=t:i._prev=t,n===null?this._itHead=t:n._next=t,this._linkedRecords===null&&(this._linkedRecords=new El),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){this._linkedRecords!==null&&this._linkedRecords.remove(t);let n=t._prev,r=t._next;return n===null?this._itHead=r:n._next=r,r===null?this._itTail=n:r._prev=n,t}_addToMoves(t,n){return t.previousIndex===n||(this._movesTail===null?this._movesTail=this._movesHead=t:this._movesTail=this._movesTail._nextMoved=t),t}_addToRemovals(t){return this._unlinkedRecords===null&&(this._unlinkedRecords=new El),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,this._removalsTail===null?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,n){return t.item=n,this._identityChangesTail===null?this._identityChangesTail=this._identityChangesHead=t:this._identityChangesTail=this._identityChangesTail._nextIdentityChange=t,t}},Ih=class{item;trackById;currentIndex=null;previousIndex=null;_nextPrevious=null;_prev=null;_next=null;_prevDup=null;_nextDup=null;_prevRemoved=null;_nextRemoved=null;_nextAdded=null;_nextMoved=null;_nextIdentityChange=null;constructor(t,n){this.item=t,this.trackById=n}},xh=class{_head=null;_tail=null;add(t){this._head===null?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,n){let r;for(r=this._head;r!==null;r=r._nextDup)if((n===null||n<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){let n=t._prevDup,r=t._nextDup;return n===null?this._head=r:n._nextDup=r,r===null?this._tail=n:r._prevDup=n,this._head===null}},El=class{map=new Map;put(t){let n=t.trackById,r=this.map.get(n);r||(r=new xh,this.map.set(n,r)),r.add(t)}get(t,n){let r=t,i=this.map.get(r);return i?i.get(t,n):null}remove(t){let n=t.trackById;return this.map.get(n).remove(t)&&this.map.delete(n),t}get isEmpty(){return this.map.size===0}clear(){this.map.clear()}};function CE(e,t,n){let r=e.previousIndex;if(r===null)return r;let i=0;return n&&r<n.length&&(i=n[r]),r+t+i}var Tl=class{constructor(){}supports(t){return t instanceof Map||fl(t)}create(){return new Eh}},Eh=class{_records=new Map;_mapHead=null;_appendAfter=null;_previousMapHead=null;_changesHead=null;_changesTail=null;_additionsHead=null;_additionsTail=null;_removalsHead=null;_removalsTail=null;get isDirty(){return this._additionsHead!==null||this._changesHead!==null||this._removalsHead!==null}forEachItem(t){let n;for(n=this._mapHead;n!==null;n=n._next)t(n)}forEachPreviousItem(t){let n;for(n=this._previousMapHead;n!==null;n=n._nextPrevious)t(n)}forEachChangedItem(t){let n;for(n=this._changesHead;n!==null;n=n._nextChanged)t(n)}forEachAddedItem(t){let n;for(n=this._additionsHead;n!==null;n=n._nextAdded)t(n)}forEachRemovedItem(t){let n;for(n=this._removalsHead;n!==null;n=n._nextRemoved)t(n)}diff(t){if(!t)t=new Map;else if(!(t instanceof Map||fl(t)))throw new ie(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let n=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,i)=>{if(n&&n.key===i)this._maybeAddToChanges(n,r),this._appendAfter=n,n=n._next;else{let o=this._getOrCreateRecordForKey(i,r);n=this._insertBeforeOrAppend(n,o)}}),n){n._prev&&(n._prev._next=null),this._removalsHead=n;for(let r=n;r!==null;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,n){if(t){let r=t._prev;return n._next=t,n._prev=r,t._prev=n,r&&(r._next=n),t===this._mapHead&&(this._mapHead=n),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=n,n._prev=this._appendAfter):this._mapHead=n,this._appendAfter=n,null}_getOrCreateRecordForKey(t,n){if(this._records.has(t)){let i=this._records.get(t);this._maybeAddToChanges(i,n);let o=i._prev,s=i._next;return o&&(o._next=s),s&&(s._prev=o),i._next=null,i._prev=null,i}let r=new Th(t);return this._records.set(t,r),r.currentValue=n,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;t!==null;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;t!==null;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;t!=null;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,n){Object.is(n,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=n,this._addToChanges(t))}_addToAdditions(t){this._additionsHead===null?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){this._changesHead===null?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,n){t instanceof Map?t.forEach(n):Object.keys(t).forEach(r=>n(t[r],r))}},Th=class{key;previousValue=null;currentValue=null;_nextPrevious=null;_next=null;_prev=null;_nextAdded=null;_nextRemoved=null;_nextChanged=null;constructor(t){this.key=t}};function DE(){return new Cl([new xl])}var Cl=class e{factories;static \u0275prov=Ae({token:e,providedIn:"root",factory:DE});constructor(t){this.factories=t}static create(t,n){if(n!=null){let r=n.factories.slice();t=t.concat(r)}return new e(t)}static extend(t){return{provide:e,useFactory:()=>{let n=re(e,{optional:!0,skipSelf:!0});return e.create(t,n||DE())}}}find(t){let n=this.factories.find(r=>r.supports(t));if(n!=null)return n;throw new ie(901,!1)}};function SE(){return new Dl([new Tl])}var Dl=class e{static \u0275prov=Ae({token:e,providedIn:"root",factory:SE});factories;constructor(t){this.factories=t}static create(t,n){if(n){let r=n.factories.slice();t=t.concat(r)}return new e(t)}static extend(t){return{provide:e,useFactory:()=>{let n=re(e,{optional:!0,skipSelf:!0});return e.create(t,n||SE())}}}find(t){let n=this.factories.find(r=>r.supports(t));if(n)return n;throw new ie(901,!1)}},mj=[new Tl],gj=[new xl],jq=new Cl(gj),Vq=new Dl(mj),Hq=cj(null,"core",[]);var Uq=new ne("",{providedIn:"platform",factory:()=>null}),Wq=new ne("",{providedIn:"platform",factory:()=>null}),qq=new ne("",{providedIn:"platform",factory:()=>null});var Lm=Object.defineProperty,yj=Object.getOwnPropertyDescriptor,vj=Object.getOwnPropertyNames,_j=Object.prototype.hasOwnProperty,wj=(e=>typeof Tr<"u"?Tr:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof Tr<"u"?Tr:t)[n]}):e)(function(e){if(typeof Tr<"u")return Tr.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),H=(e,t)=>()=>(e&&(t=e(e=0)),t),Xs=(e,t)=>{for(var n in t)Lm(e,n,{get:t[n],enumerable:!0})},bj=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of vj(t))!_j.call(e,i)&&i!==n&&Lm(e,i,{get:()=>t[i],enumerable:!(r=yj(t,i))||r.enumerable});return e},Wl=e=>bj(Lm({},"__esModule",{value:!0}),e),Fs,_r,go,OE,pD,hD=H(()=>{"use strict";Fs=new Map,_r=[],go=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let r=Fs.get(e);if(r===void 0)Fs.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let i=_r.indexOf(e);i!==-1&&_r.splice(i,1);for(let o=0;o<_r.length;o++)if(Fs.get(_r[o]).priority<=n){_r.splice(o,0,e);return}_r.push(e)}return}throw new TypeError("not a valid backend")},OE=async e=>{let t=Fs.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(r){return n||(t.error=`${r}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},pD=async e=>{let t=e.executionProviders||[],n=t.map(u=>typeof u=="string"?u:u.name),r=n.length===0?_r:n,i,o=[],s=new Set;for(let u of r){let c=await OE(u);typeof c=="string"?o.push({name:u,err:c}):(i||(i=c),i===c&&s.add(u))}if(!i)throw new Error(`no available backend found. ERR: ${o.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:c}of o)n.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${c}`);let a=t.filter(u=>s.has(typeof u=="string"?u:u.name));return[i,new Proxy(e,{get:(u,c)=>c==="executionProviders"?a:Reflect.get(u,c)})]}}),Ij=H(()=>{"use strict";hD()}),mD,xj=H(()=>{"use strict";mD="1.21.0"}),Sh,Kt,gD=H(()=>{"use strict";xj(),Sh="warning",Kt={wasm:{},webgl:{},webgpu:{},versions:{common:mD},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Sh=e}},get logLevel(){return Sh}},Object.defineProperty(Kt,"logLevel",{enumerable:!0})}),Le,Ej=H(()=>{"use strict";gD(),Le=Kt}),yD,vD,Tj=H(()=>{"use strict";yD=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(r!=null){let i,o;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(i=e.dims[2],o=e.dims[3]):(i=e.dims[3],o=e.dims[2]);let s=t?.format!==void 0?t.format:"RGB",a=t?.norm,u,c;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?c=[0,0,0,0]:typeof a.bias=="number"?c=[a.bias,a.bias,a.bias,a.bias]:(c=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(c[3]=a.bias[3]));let d=o*i,p=0,h=d,g=d*2,y=-1;s==="RGBA"?(p=0,h=d,g=d*2,y=d*3):s==="RGB"?(p=0,h=d,g=d*2):s==="RBG"&&(p=0,g=d,h=d*2);for(let w=0;w<o;w++)for(let x=0;x<i;x++){let I=(e.data[p++]-c[0])*u[0],b=(e.data[h++]-c[1])*u[1],T=(e.data[g++]-c[2])*u[2],C=y===-1?255:(e.data[y++]-c[3])*u[3];r.fillStyle="rgba("+I+","+b+","+T+","+C+")",r.fillRect(x,w,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},vD=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),r;if(n!=null){let i,o,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(i=e.dims[2],o=e.dims[1],s=e.dims[3]):(i=e.dims[3],o=e.dims[2],s=e.dims[1]);let a=t!==void 0&&t.format!==void 0?t.format:"RGB",u=t?.norm,c,d;u===void 0||u.mean===void 0?c=[255,255,255,255]:typeof u.mean=="number"?c=[u.mean,u.mean,u.mean,u.mean]:(c=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(c[3]=u.mean[3])),u===void 0||u.bias===void 0?d=[0,0,0,0]:typeof u.bias=="number"?d=[u.bias,u.bias,u.bias,u.bias]:(d=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(d[3]=u.bias[3]));let p=o*i;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!=="RGBA"||s===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let h=4,g=0,y=1,w=2,x=3,I=0,b=p,T=p*2,C=-1;a==="RGBA"?(I=0,b=p,T=p*2,C=p*3):a==="RGB"?(I=0,b=p,T=p*2):a==="RBG"&&(I=0,T=p,b=p*2),r=n.createImageData(i,o);for(let S=0;S<o*i;g+=h,y+=h,w+=h,x+=h,S++)r.data[g]=(e.data[I++]-d[0])*c[0],r.data[y]=(e.data[b++]-d[1])*c[1],r.data[w]=(e.data[T++]-d[2])*c[2],r.data[x]=C===-1?255:(e.data[C++]-d[3])*c[3]}else throw new Error("Can not access image data");return r}}),$l,_D,wD,bD,ID,xD,Cj=H(()=>{"use strict";Fm(),$l=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:r}=t,i=t.norm??{mean:255,bias:0},o,s;typeof i.mean=="number"?o=[i.mean,i.mean,i.mean,i.mean]:o=[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],typeof i.bias=="number"?s=[i.bias,i.bias,i.bias,i.bias]:s=[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let a=t.format!==void 0?t.format:"RGBA",u=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",c=n*r,d=u==="RGBA"?new Float32Array(c*4):new Float32Array(c*3),p=4,h=0,g=1,y=2,w=3,x=0,I=c,b=c*2,T=-1;a==="RGB"&&(p=3,h=0,g=1,y=2,w=-1),u==="RGBA"?T=c*3:u==="RBG"?(x=0,b=c,I=c*2):u==="BGR"&&(b=0,I=c,x=c*2);for(let C=0;C<c;C++,h+=p,y+=p,g+=p,w+=p)d[x++]=(e[h]+s[0])/o[0],d[I++]=(e[g]+s[1])/o[1],d[b++]=(e[y]+s[2])/o[2],T!==-1&&w!==-1&&(d[T++]=(e[w]+s[3])/o[3]);return u==="RGBA"?new Ft("float32",d,[1,4,n,r]):new Ft("float32",d,[1,3,n,r])},_D=async(e,t)=>{let n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,r=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o=typeof e=="string",s,a=t??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},c=d=>typeof HTMLCanvasElement<"u"&&d instanceof HTMLCanvasElement||d instanceof OffscreenCanvas?d.getContext("2d"):null;if(n){let d=u();d.width=e.width,d.height=e.height;let p=c(d);if(p!=null){let h=e.height,g=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(h=t.resizedHeight,g=t.resizedWidth),t!==void 0){if(a=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=h,a.width=g}else a.tensorFormat="RGBA",a.height=h,a.width=g;p.drawImage(e,0,0),s=p.getImageData(0,0,g,h).data}else throw new Error("Can not access image data")}else if(r){let d,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(d=t.resizedHeight,p=t.resizedWidth):(d=e.height,p=e.width),t!==void 0&&(a=t),a.format="RGBA",a.height=d,a.width=p,t!==void 0){let h=u();h.width=p,h.height=d;let g=c(h);if(g!=null)g.putImageData(e,0,0),s=g.getImageData(0,0,p,d).data;else throw new Error("Can not access image data")}else s=e.data}else if(i){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let d=u();d.width=e.width,d.height=e.height;let p=c(d);if(p!=null){let h=e.height,g=e.width;return p.drawImage(e,0,0,g,h),s=p.getImageData(0,0,g,h).data,a.height=h,a.width=g,$l(s,a)}else throw new Error("Can not access image data")}else{if(o)return new Promise((d,p)=>{let h=u(),g=c(h);if(!e||!g)return p();let y=new Image;y.crossOrigin="Anonymous",y.src=e,y.onload=()=>{h.width=y.width,h.height=y.height,g.drawImage(y,0,0,h.width,h.height);let w=g.getImageData(0,0,h.width,h.height);a.height=h.height,a.width=h.width,d($l(w.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return $l(s,a);throw new Error("Input data provided is not supported - aborted tensor creation")},wD=(e,t)=>{let{width:n,height:r,download:i,dispose:o}=t,s=[1,r,n,4];return new Ft({location:"texture",type:"float32",texture:e,dims:s,download:i,dispose:o})},bD=(e,t)=>{let{dataType:n,dims:r,download:i,dispose:o}=t;return new Ft({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:i,dispose:o})},ID=(e,t)=>{let{dataType:n,dims:r,download:i,dispose:o}=t;return new Ft({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:i,dispose:o})},xD=(e,t,n)=>new Ft({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),ii,Gs,$h,ED,Dj=H(()=>{"use strict";ii=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Gs=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),$h=!1,ED=()=>{if(!$h){$h=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<"u"&&n.from;e&&(ii.set("int64",BigInt64Array),Gs.set(BigInt64Array,"int64")),t&&(ii.set("uint64",BigUint64Array),Gs.set(BigUint64Array,"uint64")),r?(ii.set("float16",n),Gs.set(n,"float16")):ii.set("float16",Uint16Array)}}}),TD,CD,Sj=H(()=>{"use strict";Fm(),TD=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},CD=(e,t)=>{switch(e.location){case"cpu":return new Ft(e.type,e.data,t);case"cpu-pinned":return new Ft({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ft({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ft({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Ft({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),Ft,Fm=H(()=>{"use strict";Tj(),Cj(),Dj(),Sj(),Ft=class{constructor(e,t,n){ED();let r,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,r=e.type,i=e.dims,e.location){case"cpu-pinned":{let s=ii.get(r);if(!s)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof s))throw new TypeError(`buffer should be of type ${s.name}`);this.cpuData=e.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,a;if(typeof e=="string")if(r=e,a=n,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");s=t}else{let u=ii.get(e);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&u===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${u.name} as data.`);e==="uint64"||e==="int64"?s=u.from(t,BigInt):s=u.from(t)}else if(t instanceof u)s=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")s=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&u!==Uint16Array)s=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${r} tensor's data must be type of ${u}`)}else if(a=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let u=typeof e[0];if(u==="string")r="string",s=e;else if(u==="boolean")r="bool",s=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else if(e instanceof Uint8ClampedArray)r="uint8",s=Uint8Array.from(e);else{let u=Gs.get(e.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=u,s=e}if(a===void 0)a=[s.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");i=a,this.cpuData=s,this.dataLocation="cpu"}let o=TD(i);if(this.cpuData&&o!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(o/2)===this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=i,this.size=o}static async fromImage(e,t){return _D(e,t)}static fromTexture(e,t){return wD(e,t)}static fromGpuBuffer(e,t){return bD(e,t)}static fromMLTensor(e,t){return ID(e,t)}static fromPinnedBuffer(e,t,n){return xD(e,t,n)}toDataURL(e){return yD(this,e)}toImageData(e){return vD(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return CD(this,e)}}}),Qt,DD=H(()=>{"use strict";Fm(),Qt=Ft}),ql,Mh,On,pn,SD=H(()=>{"use strict";gD(),ql=(e,t)=>{(typeof Kt.trace>"u"?!Kt.wasm.trace:!Kt.trace)||console.timeStamp(`${e}::ORT::${t}`)},Mh=(e,t)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],r=!1;for(let i=0;i<n.length;i++){if(r&&!n[i].includes("TRACE_FUNC")){let o=`FUNC_${e}::${n[i].trim().split(" ")[1]}`;t&&(o+=`::${t}`),ql("CPU",o);return}n[i].includes("TRACE_FUNC")&&(r=!0)}},On=e=>{(typeof Kt.trace>"u"?!Kt.wasm.trace:!Kt.trace)||Mh("BEGIN",e)},pn=e=>{(typeof Kt.trace>"u"?!Kt.wasm.trace:!Kt.trace)||Mh("END",e)}}),$D,$j=H(()=>{"use strict";hD(),DD(),SD(),$D=class MD{constructor(t){this.handler=t}async run(t,n,r){On();let i={},o={};if(typeof t!="object"||t===null||t instanceof Qt||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Qt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let c of n){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);i[c]=null}if(typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,d=Object.getOwnPropertyNames(n);for(let p of this.outputNames)if(d.indexOf(p)!==-1){let h=n[p];(h===null||h instanceof Qt)&&(c=!0,s=!1,i[p]=h)}if(c){if(typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else o=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of this.inputNames)if(typeof t[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if(s)for(let c of this.outputNames)i[c]=null;let a=await this.handler.run(t,i,o),u={};for(let c in a)if(Object.hasOwnProperty.call(a,c)){let d=a[c];d instanceof Qt?u[c]=d:u[c]=new Qt(d.type,d.data,d.dims)}return pn(),u}async release(){return this.handler.dispose()}static async create(t,n,r,i){On();let o,s={};if(typeof t=="string"){if(o=t,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(o=t,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let d=t,p=0,h=t.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(p=n,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=d.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${d.byteLength}).`);if(h=t.byteLength-p,typeof r=="number"){if(h=r,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||p+h>d.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${d.byteLength-p}].`);if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(d,p,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[a,u]=await pD(s),c=await a.createInferenceSessionHandler(o,u);return pn(),new MD(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Xl,Mj=H(()=>{"use strict";$j(),Xl=$D}),Nj=H(()=>{"use strict"}),kj=H(()=>{"use strict"}),Aj=H(()=>{"use strict"}),Rj=H(()=>{"use strict"}),Oj={};Xs(Oj,{InferenceSession:()=>Xl,TRACE:()=>ql,TRACE_FUNC_BEGIN:()=>On,TRACE_FUNC_END:()=>pn,Tensor:()=>Qt,env:()=>Le,registerBackend:()=>go});var hn=H(()=>{"use strict";Ij(),Ej(),Mj(),DD(),Nj(),kj(),SD(),Aj(),Rj()}),zm=H(()=>{"use strict"}),ND={};Xs(ND,{default:()=>kD});var Nh,kh,kD,Pj=H(()=>{"use strict";O2(),ci(),Bm(),Nh="ort-wasm-proxy-worker",kh=globalThis.self?.name===Nh,kh&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":jm(n.wasm).then(()=>{og(n).then(()=>{postMessage({type:t})},r=>{postMessage({type:t,err:r})})},r=>{postMessage({type:t,err:r})});break;case"init-ep":{let{epName:r,env:i}=n;sg(i,r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})});break}case"copy-from":{let{buffer:r}=n,i=Jl(r);postMessage({type:t,out:i});break}case"create":{let{model:r,options:i}=n;ag(r,i).then(o=>{postMessage({type:t,out:o})},o=>{postMessage({type:t,err:o})});break}case"release":ug(n),postMessage({type:t});break;case"run":{let{sessionId:r,inputIndices:i,inputs:o,outputIndices:s,options:a}=n;lg(r,i,o,s,new Array(s.length).fill(null),a).then(u=>{u.some(c=>c[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:u},dg([...o,...u]))},u=>{postMessage({type:t,err:u})});break}case"end-profiling":cg(n),postMessage({type:t});break;default:}}catch(r){postMessage({type:t,err:r})}}),kD=kh?null:e=>new Worker(e??Lt,{type:"module",name:Nh})}),AD={};Xs(AD,{default:()=>RD});var Ah,Rh,RD,PE,Lj=H(()=>{"use strict";Rh=(Ah=import.meta.url,async function(e={}){var t,n,r=e,i=new Promise((l,f)=>{t=l,n=f}),o=typeof window=="object",s=typeof WorkerGlobalScope<"u",a=s&&self.name?.startsWith("em-pthread");r.mountExternalData=(l,f)=>{l.startsWith("./")&&(l=l.substring(2)),(r.Bd||(r.Bd=new Map)).set(l,f)},r.unmountExternalData=()=>{delete r.Bd};var u=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let c=()=>{let l=(m,v,_)=>(...E)=>{let D=gn,N=v?.();E=m(...E);let A=v?.();return N!==A&&(m=A,_(N),v=_=null),gn!=D?new Promise((j,q)=>{yc={resolve:j,reject:q}}):E},f=m=>async(...v)=>{try{if(r.Cd)throw Error("Session already started");let _=r.Cd={be:v[0],errors:[]},E=await m(...v);if(r.Cd!==_)throw Error("Session mismatch");r.Dd?.flush();let D=_.errors;if(0<D.length){let N=await Promise.all(D);if(N=N.filter(A=>A),0<N.length)throw Error(N.join(`
`))}return E}finally{r.Cd=null}};r._OrtCreateSession=l(r._OrtCreateSession,()=>r._OrtCreateSession,m=>r._OrtCreateSession=m),r._OrtRun=f(l(r._OrtRun,()=>r._OrtRun,m=>r._OrtRun=m)),r._OrtRunWithBinding=f(l(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,m=>r._OrtRunWithBinding=m)),r._OrtBindInput=l(r._OrtBindInput,()=>r._OrtBindInput,m=>r._OrtBindInput=m),c=void 0};r.jsepInit=(l,f)=>{if(c?.(),l==="webgpu"){[r.Dd,r.Rd,r.Vd,r.Hd,r.Ud,r.hc,r.Wd,r.Zd,r.Sd,r.Td,r.Xd]=f;let m=r.Dd;r.jsepRegisterBuffer=(v,_,E,D)=>m.registerBuffer(v,_,E,D),r.jsepGetBuffer=v=>m.getBuffer(v),r.jsepCreateDownloader=(v,_,E)=>m.createDownloader(v,_,E),r.jsepOnCreateSession=v=>{m.onCreateSession(v)},r.jsepOnReleaseSession=v=>{m.onReleaseSession(v)},r.jsepOnRunStart=v=>m.onRunStart(v),r.$d=(v,_)=>{m.upload(v,_)}}else if(l==="webnn"){[r.Dd,r.Yd,r.Id,r.jsepEnsureTensor,r.Jd,r.jsepDownloadTensor]=f,r.jsepReleaseTensorId=r.Id,r.jsepUploadTensor=r.Jd;let m=r.Dd;r.jsepOnRunStart=v=>m.onRunStart(v),r.jsepOnRunEnd=m.onRunEnd.bind(m),r.jsepRegisterMLContext=(v,_)=>{m.registerMLContext(v,_)},r.jsepOnReleaseSession=v=>{m.onReleaseSession(v)},r.jsepCreateMLTensorDownloader=(v,_)=>m.createMLTensorDownloader(v,_),r.jsepRegisterMLTensor=(v,_,E,D)=>m.registerMLTensor(v,_,E,D),r.jsepCreateMLContext=v=>m.createMLContext(v),r.jsepRegisterMLConstant=(v,_,E,D,N)=>m.registerMLConstant(v,_,E,D,N,r.Bd),r.jsepRegisterGraphInput=m.registerGraphInput.bind(m),r.jsepIsGraphInput=m.isGraphInput.bind(m),r.jsepCreateTemporaryTensor=m.createTemporaryTensor.bind(m)}};var d,p,h=Object.assign({},r),g=(l,f)=>{throw f},y="";(o||s)&&(s?y=self.location.href:typeof document<"u"&&document.currentScript&&(y=document.currentScript.src),Ah&&(y=Ah),y=y.startsWith("blob:")?"":y.slice(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1),s&&(p=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),d=async l=>{if(Ee(l))return new Promise((m,v)=>{var _=new XMLHttpRequest;_.open("GET",l,!0),_.responseType="arraybuffer",_.onload=()=>{_.status==200||_.status==0&&_.response?m(_.response):v(_.status)},_.onerror=v,_.send(null)});var f=await fetch(l,{credentials:"same-origin"});if(f.ok)return f.arrayBuffer();throw Error(f.status+" : "+f.url)});var w=console.log.bind(console),x=console.error.bind(console),I=w,b=x;Object.assign(r,h),h=null;var T,C,S,$,M,L,V,G,X,oe,B,ye,xe,K=r.wasmBinary,we=!1,Ee=l=>l.startsWith("file://");function Q(){return T.buffer!=$.buffer&&Tt(),$}function Te(){return T.buffer!=$.buffer&&Tt(),M}function z(){return T.buffer!=$.buffer&&Tt(),L}function W(){return T.buffer!=$.buffer&&Tt(),V}function R(){return T.buffer!=$.buffer&&Tt(),G}function te(){return T.buffer!=$.buffer&&Tt(),X}function Ze(){return T.buffer!=$.buffer&&Tt(),oe}function kt(){return T.buffer!=$.buffer&&Tt(),xe}if(a){let l=function(f){try{var m=f.data,v=m.yd;if(v==="load"){let _=[];self.onmessage=E=>_.push(E),self.startWorker=()=>{postMessage({yd:"loaded"});for(let E of _)l(E);self.onmessage=l};for(let E of m.Od)r[E]&&!r[E].proxy||(r[E]=(...D)=>{postMessage({yd:"callHandler",Nd:E,args:D})},E=="print"&&(I=r[E]),E=="printErr"&&(b=r[E]));T=m.he,Tt(),Je(m.ie)}else if(v==="run"){Y2(m.xd),bc(m.xd,0,0,1,0,0),bg(),mc(m.xd),Pn||(my(),Pn=!0);try{J2(m.de,m.Fd)}catch(_){if(_!="unwind")throw _}}else m.target!=="setimmediate"&&(v==="checkMailbox"?Pn&&na():v&&(b(`worker: received unknown command ${v}`),b(m)))}catch(_){throw gy(),_}};var at=l,Je,Pn=!1;b=function(...f){f=f.join(" "),console.error(f)},self.alert=function(...f){postMessage({yd:"alert",text:f.join(" "),fe:ca()})},self.onunhandledrejection=f=>{throw f.reason||f},self.onmessage=l}function Tt(){var l=T.buffer;r.HEAP8=$=new Int8Array(l),r.HEAP16=L=new Int16Array(l),r.HEAPU8=M=new Uint8Array(l),r.HEAPU16=V=new Uint16Array(l),r.HEAP32=G=new Int32Array(l),r.HEAPU32=X=new Uint32Array(l),r.HEAPF32=oe=new Float32Array(l),r.HEAPF64=xe=new Float64Array(l),r.HEAP64=B=new BigInt64Array(l),r.HEAPU64=ye=new BigUint64Array(l)}function ea(){a?startWorker(r):F.Bb()}a||(T=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),Tt());var tc,wo=0,bo=null;function hg(){if(--wo==0&&bo){var l=bo;bo=null,l()}}function Ln(l){throw b(l="Aborted("+l+")"),we=!0,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function mg(){return{a:{Ta:Z2,Va:Q2,W:X2,la:eM,b:nM,u:rM,R:iM,Za:oM,d:sM,pb:Tg,g:tM,T:Sg,Ga:$g,lb:Ng,nb:kg,Ha:Ag,Ea:Rg,wb:Og,Da:Pg,pa:Lg,mb:Fg,jb:zg,Fa:Bg,kb:jg,Ma:aM,za:lM,eb:cM,cb:fM,ya:hM,V:mM,N:gM,db:yM,ma:EM,fb:TM,zb:CM,hb:DM,qb:SM,ab:$M,Aa:MM,yb:mc,Ja:NM,S:kM,Wa:AM,$:PM,G:LM,E:zM,m:fc,H:BM,B:HM,X:UM,J:WM,v:qM,O:GM,D:KM,t:QM,A:ZM,z:YM,w:JM,r:XM,tb:eN,ub:tN,vb:nN,rb:ty,sb:ny,bb:ry,Oa:iN,La:aN,y:uN,ja:lN,Ba:cN,Ka:oN,qa:dN,Ia:fN,ib:pN,U:rN,fa:hN,Sa:mN,gb:gN,Qa:yN,Pa:vN,Ab:ay,Ca:uy,ob:sc,aa:ly,oa:cy,xb:dy,na:fy,$a:WN,ia:ik,sa:lk,ga:HN,da:YN,ua:ak,p:jN,e:TN,c:xN,ea:QN,f:CN,n:SN,k:LN,Y:MN,ka:FN,j:VN,wa:KN,Ra:fk,ca:nk,Ua:dk,P:ZN,K:kN,_:tk,Q:UN,Z:ok,x:NN,l:EN,va:ek,i:IN,h:$N,ra:ck,ta:uk,o:DN,q:AN,s:ON,I:PN,C:BN,L:zN,xa:GN,_a:qN,F:rk,Ya:JN,ba:sk,M:RN,Xa:XN,ha:wN,a:T,Na:oc}}}var nc={1319426:()=>typeof wasmOffsetConverter<"u",1319483:(l,f,m,v,_)=>{if(r===void 0||!r.Bd)return 1;if((l=Xe(Number(l>>>0))).startsWith("./")&&(l=l.substring(2)),!(l=r.Bd.get(l)))return 2;if(f=Number(f>>>0),m=Number(m>>>0),v=Number(v>>>0),f+m>l.byteLength)return 3;try{let E=l.subarray(f,f+m);switch(_){case 0:Te().set(E,v>>>0);break;case 1:r.$d(v,E);break;default:return 4}return 0}catch{return 4}},1320198:(l,f,m)=>{r.Jd(l,Te().subarray(f>>>0,f+m>>>0))},1320261:()=>r.Yd(),1320302:l=>{r.Id(l)},1320338:()=>{r.Sd()},1320369:()=>{r.Td()},1320398:()=>{r.Xd()},1320423:l=>r.Rd(l),1320456:l=>r.Vd(l),1320488:(l,f,m)=>{r.Hd(Number(l),Number(f),Number(m),!0)},1320551:(l,f,m)=>{r.Hd(Number(l),Number(f),Number(m))},1320608:l=>{r.hc("Abs",l,void 0)},1320659:l=>{r.hc("Neg",l,void 0)},1320710:l=>{r.hc("Floor",l,void 0)},1320763:l=>{r.hc("Ceil",l,void 0)},1320815:l=>{r.hc("Reciprocal",l,void 0)},1320873:l=>{r.hc("Sqrt",l,void 0)},1320925:l=>{r.hc("Exp",l,void 0)},1320976:l=>{r.hc("Erf",l,void 0)},1321027:l=>{r.hc("Sigmoid",l,void 0)},1321082:(l,f,m)=>{r.hc("HardSigmoid",l,{alpha:f,beta:m})},1321161:l=>{r.hc("Log",l,void 0)},1321212:l=>{r.hc("Sin",l,void 0)},1321263:l=>{r.hc("Cos",l,void 0)},1321314:l=>{r.hc("Tan",l,void 0)},1321365:l=>{r.hc("Asin",l,void 0)},1321417:l=>{r.hc("Acos",l,void 0)},1321469:l=>{r.hc("Atan",l,void 0)},1321521:l=>{r.hc("Sinh",l,void 0)},1321573:l=>{r.hc("Cosh",l,void 0)},1321625:l=>{r.hc("Asinh",l,void 0)},1321678:l=>{r.hc("Acosh",l,void 0)},1321731:l=>{r.hc("Atanh",l,void 0)},1321784:l=>{r.hc("Tanh",l,void 0)},1321836:l=>{r.hc("Not",l,void 0)},1321887:(l,f,m)=>{r.hc("Clip",l,{min:f,max:m})},1321956:l=>{r.hc("Clip",l,void 0)},1322008:(l,f)=>{r.hc("Elu",l,{alpha:f})},1322066:l=>{r.hc("Gelu",l,void 0)},1322118:l=>{r.hc("Relu",l,void 0)},1322170:(l,f)=>{r.hc("LeakyRelu",l,{alpha:f})},1322234:(l,f)=>{r.hc("ThresholdedRelu",l,{alpha:f})},1322304:(l,f)=>{r.hc("Cast",l,{to:f})},1322362:l=>{r.hc("Add",l,void 0)},1322413:l=>{r.hc("Sub",l,void 0)},1322464:l=>{r.hc("Mul",l,void 0)},1322515:l=>{r.hc("Div",l,void 0)},1322566:l=>{r.hc("Pow",l,void 0)},1322617:l=>{r.hc("Equal",l,void 0)},1322670:l=>{r.hc("Greater",l,void 0)},1322725:l=>{r.hc("GreaterOrEqual",l,void 0)},1322787:l=>{r.hc("Less",l,void 0)},1322839:l=>{r.hc("LessOrEqual",l,void 0)},1322898:(l,f,m,v,_)=>{r.hc("ReduceMean",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1323073:(l,f,m,v,_)=>{r.hc("ReduceMax",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1323247:(l,f,m,v,_)=>{r.hc("ReduceMin",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1323421:(l,f,m,v,_)=>{r.hc("ReduceProd",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1323596:(l,f,m,v,_)=>{r.hc("ReduceSum",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1323770:(l,f,m,v,_)=>{r.hc("ReduceL1",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1323943:(l,f,m,v,_)=>{r.hc("ReduceL2",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1324116:(l,f,m,v,_)=>{r.hc("ReduceLogSum",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1324293:(l,f,m,v,_)=>{r.hc("ReduceSumSquare",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1324473:(l,f,m,v,_)=>{r.hc("ReduceLogSumExp",l,{keepDims:!!f,noopWithEmptyAxes:!!m,axes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1324653:l=>{r.hc("Where",l,void 0)},1324706:(l,f,m)=>{r.hc("Transpose",l,{perm:f?Array.from(R().subarray(Number(f)>>>0,Number(m)>>>0)):[]})},1324830:(l,f,m,v)=>{r.hc("DepthToSpace",l,{blocksize:f,mode:Xe(m),format:v?"NHWC":"NCHW"})},1324963:(l,f,m,v)=>{r.hc("DepthToSpace",l,{blocksize:f,mode:Xe(m),format:v?"NHWC":"NCHW"})},1325096:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe,jt)=>{r.hc("ConvTranspose",l,{format:A?"NHWC":"NCHW",autoPad:f,dilations:[m],group:v,kernelShape:[_],pads:[E,D],strides:[N],wIsConst:()=>!!Q()[j>>>0],outputPadding:q?Array.from(R().subarray(Number(q)>>>0,Number(ee)>>>0)):[],outputShape:fe?Array.from(R().subarray(Number(fe)>>>0,Number(Fe)>>>0)):[],activation:Xe(jt)})},1325529:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>{r.hc("ConvTranspose",l,{format:N?"NHWC":"NCHW",autoPad:f,dilations:Array.from(R().subarray(Number(m)>>>0,2+(Number(m)>>>0)>>>0)),group:v,kernelShape:Array.from(R().subarray(Number(_)>>>0,2+(Number(_)>>>0)>>>0)),pads:Array.from(R().subarray(Number(E)>>>0,4+(Number(E)>>>0)>>>0)),strides:Array.from(R().subarray(Number(D)>>>0,2+(Number(D)>>>0)>>>0)),wIsConst:()=>!!Q()[A>>>0],outputPadding:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],outputShape:ee?Array.from(R().subarray(Number(ee)>>>0,Number(fe)>>>0)):[],activation:Xe(Fe)})},1326190:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe,jt)=>{r.hc("ConvTranspose",l,{format:A?"NHWC":"NCHW",autoPad:f,dilations:[m],group:v,kernelShape:[_],pads:[E,D],strides:[N],wIsConst:()=>!!Q()[j>>>0],outputPadding:q?Array.from(R().subarray(Number(q)>>>0,Number(ee)>>>0)):[],outputShape:fe?Array.from(R().subarray(Number(fe)>>>0,Number(Fe)>>>0)):[],activation:Xe(jt)})},1326623:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>{r.hc("ConvTranspose",l,{format:N?"NHWC":"NCHW",autoPad:f,dilations:Array.from(R().subarray(Number(m)>>>0,2+(Number(m)>>>0)>>>0)),group:v,kernelShape:Array.from(R().subarray(Number(_)>>>0,2+(Number(_)>>>0)>>>0)),pads:Array.from(R().subarray(Number(E)>>>0,4+(Number(E)>>>0)>>>0)),strides:Array.from(R().subarray(Number(D)>>>0,2+(Number(D)>>>0)>>>0)),wIsConst:()=>!!Q()[A>>>0],outputPadding:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],outputShape:ee?Array.from(R().subarray(Number(ee)>>>0,Number(fe)>>>0)):[],activation:Xe(Fe)})},1327284:(l,f)=>{r.hc("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},1327375:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>{r.hc("AveragePool",l,{format:Fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:m,count_include_pad:v,storage_order:_,dilations:E?Array.from(R().subarray(Number(E)>>>0,Number(D)>>>0)):[],kernel_shape:N?Array.from(R().subarray(Number(N)>>>0,Number(A)>>>0)):[],pads:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],strides:ee?Array.from(R().subarray(Number(ee)>>>0,Number(fe)>>>0)):[]})},1327854:(l,f)=>{r.hc("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},1327945:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>{r.hc("AveragePool",l,{format:Fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:m,count_include_pad:v,storage_order:_,dilations:E?Array.from(R().subarray(Number(E)>>>0,Number(D)>>>0)):[],kernel_shape:N?Array.from(R().subarray(Number(N)>>>0,Number(A)>>>0)):[],pads:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],strides:ee?Array.from(R().subarray(Number(ee)>>>0,Number(fe)>>>0)):[]})},1328424:(l,f)=>{r.hc("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},1328511:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>{r.hc("MaxPool",l,{format:Fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:m,count_include_pad:v,storage_order:_,dilations:E?Array.from(R().subarray(Number(E)>>>0,Number(D)>>>0)):[],kernel_shape:N?Array.from(R().subarray(Number(N)>>>0,Number(A)>>>0)):[],pads:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],strides:ee?Array.from(R().subarray(Number(ee)>>>0,Number(fe)>>>0)):[]})},1328986:(l,f)=>{r.hc("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},1329073:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>{r.hc("MaxPool",l,{format:Fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:m,count_include_pad:v,storage_order:_,dilations:E?Array.from(R().subarray(Number(E)>>>0,Number(D)>>>0)):[],kernel_shape:N?Array.from(R().subarray(Number(N)>>>0,Number(A)>>>0)):[],pads:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],strides:ee?Array.from(R().subarray(Number(ee)>>>0,Number(fe)>>>0)):[]})},1329548:(l,f,m,v,_)=>{r.hc("Gemm",l,{alpha:f,beta:m,transA:v,transB:_})},1329652:l=>{r.hc("MatMul",l,void 0)},1329706:(l,f,m,v)=>{r.hc("ArgMax",l,{keepDims:!!f,selectLastIndex:!!m,axis:v})},1329814:(l,f,m,v)=>{r.hc("ArgMin",l,{keepDims:!!f,selectLastIndex:!!m,axis:v})},1329922:(l,f)=>{r.hc("Softmax",l,{axis:f})},1329985:(l,f)=>{r.hc("Concat",l,{axis:f})},1330045:(l,f,m,v,_)=>{r.hc("Split",l,{axis:f,numOutputs:m,splitSizes:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1330201:l=>{r.hc("Expand",l,void 0)},1330255:(l,f)=>{r.hc("Gather",l,{axis:Number(f)})},1330326:(l,f)=>{r.hc("GatherElements",l,{axis:Number(f)})},1330405:(l,f)=>{r.hc("GatherND",l,{batch_dims:Number(f)})},1330484:(l,f,m,v,_,E,D,N,A,j,q)=>{r.hc("Resize",l,{antialias:f,axes:m?Array.from(R().subarray(Number(m)>>>0,Number(v)>>>0)):[],coordinateTransformMode:Xe(_),cubicCoeffA:E,excludeOutside:D,extrapolationValue:N,keepAspectRatioPolicy:Xe(A),mode:Xe(j),nearestMode:Xe(q)})},1330846:(l,f,m,v,_,E,D)=>{r.hc("Slice",l,{starts:f?Array.from(R().subarray(Number(f)>>>0,Number(m)>>>0)):[],ends:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[],axes:E?Array.from(R().subarray(Number(E)>>>0,Number(D)>>>0)):[]})},1331110:l=>{r.hc("Tile",l,void 0)},1331162:(l,f,m)=>{r.hc("InstanceNormalization",l,{epsilon:f,format:m?"NHWC":"NCHW"})},1331276:(l,f,m)=>{r.hc("InstanceNormalization",l,{epsilon:f,format:m?"NHWC":"NCHW"})},1331390:l=>{r.hc("Range",l,void 0)},1331443:(l,f)=>{r.hc("Einsum",l,{equation:Xe(f)})},1331524:(l,f,m,v,_)=>{r.hc("Pad",l,{mode:f,value:m,pads:v?Array.from(R().subarray(Number(v)>>>0,Number(_)>>>0)):[]})},1331667:(l,f,m,v,_,E)=>{r.hc("BatchNormalization",l,{epsilon:f,momentum:m,spatial:!!_,trainingMode:!!v,format:E?"NHWC":"NCHW"})},1331836:(l,f,m,v,_,E)=>{r.hc("BatchNormalization",l,{epsilon:f,momentum:m,spatial:!!_,trainingMode:!!v,format:E?"NHWC":"NCHW"})},1332005:(l,f,m)=>{r.hc("CumSum",l,{exclusive:Number(f),reverse:Number(m)})},1332102:(l,f,m)=>{r.hc("DequantizeLinear",l,{axis:f,blockSize:m})},1332192:(l,f,m,v,_)=>{r.hc("GridSample",l,{align_corners:f,mode:Xe(m),padding_mode:Xe(v),format:_?"NHWC":"NCHW"})},1332362:(l,f,m,v,_)=>{r.hc("GridSample",l,{align_corners:f,mode:Xe(m),padding_mode:Xe(v),format:_?"NHWC":"NCHW"})},1332532:(l,f)=>{r.hc("ScatterND",l,{reduction:Xe(f)})},1332617:(l,f,m,v,_,E,D,N,A)=>{r.hc("Attention",l,{numHeads:f,isUnidirectional:m,maskFilterValue:v,scale:_,doRotary:E,qkvHiddenSizes:D?Array.from(R().subarray(Number(N)>>>0,Number(N)+D>>>0)):[],pastPresentShareBuffer:!!A})},1332889:l=>{r.hc("BiasAdd",l,void 0)},1332944:l=>{r.hc("BiasSplitGelu",l,void 0)},1333005:l=>{r.hc("FastGelu",l,void 0)},1333061:(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe,jt,To)=>{r.hc("Conv",l,{format:ee?"NHWC":"NCHW",auto_pad:f,dilations:m?Array.from(R().subarray(Number(m)>>>0,Number(v)>>>0)):[],group:_,kernel_shape:E?Array.from(R().subarray(Number(E)>>>0,Number(D)>>>0)):[],pads:N?Array.from(R().subarray(Number(N)>>>0,Number(A)>>>0)):[],strides:j?Array.from(R().subarray(Number(j)>>>0,Number(q)>>>0)):[],w_is_const:()=>!!Q()[Number(fe)>>>0],activation:Xe(Fe),activation_params:jt?Array.from(Ze().subarray(Number(jt)>>>0,Number(To)>>>0)):[]})},1333645:l=>{r.hc("Gelu",l,void 0)},1333697:(l,f,m,v,_,E,D,N,A)=>{r.hc("GroupQueryAttention",l,{numHeads:f,kvNumHeads:m,scale:v,softcap:_,doRotary:E,rotaryInterleaved:D,smoothSoftmax:N,localWindowSize:A})},1333914:(l,f,m,v)=>{r.hc("LayerNormalization",l,{axis:f,epsilon:m,simplified:!!v})},1334025:(l,f,m,v)=>{r.hc("LayerNormalization",l,{axis:f,epsilon:m,simplified:!!v})},1334136:(l,f,m,v,_,E)=>{r.hc("MatMulNBits",l,{k:f,n:m,accuracyLevel:v,bits:_,blockSize:E})},1334263:(l,f,m,v,_,E)=>{r.hc("MultiHeadAttention",l,{numHeads:f,isUnidirectional:m,maskFilterValue:v,scale:_,doRotary:E})},1334422:(l,f)=>{r.hc("QuickGelu",l,{alpha:f})},1334486:(l,f,m,v,_)=>{r.hc("RotaryEmbedding",l,{interleaved:!!f,numHeads:m,rotaryEmbeddingDim:v,scale:_})},1334625:(l,f,m)=>{r.hc("SkipLayerNormalization",l,{epsilon:f,simplified:!!m})},1334727:(l,f,m)=>{r.hc("SkipLayerNormalization",l,{epsilon:f,simplified:!!m})},1334829:(l,f,m,v)=>{r.hc("GatherBlockQuantized",l,{gatherAxis:f,quantizeAxis:m,blockSize:v})},1334950:l=>{r.Wd(l)},1334984:(l,f)=>r.Zd(Number(l),Number(f),r.Cd.be,r.Cd.errors)};function Q2(l,f,m){return Qg(async()=>{await r.Ud(Number(l),Number(f),Number(m))})}function Z2(){return typeof wasmOffsetConverter<"u"}class rc{name="ExitStatus";constructor(f){this.message=`Program terminated with exit(${f})`,this.status=f}}var gg=l=>{l.terminate(),l.onmessage=()=>{}},ic=[],yg=l=>{Jn.length==0&&(xg(),Ig(Jn[0]));var f=Jn.pop();if(!f)return 6;Io.push(f),Er[l.xd]=f,f.xd=l.xd;var m={yd:"run",de:l.ce,Fd:l.Fd,xd:l.xd};return f.postMessage(m,l.Ld),0},Yn=0,ze=(l,f,...m)=>{for(var v=2*m.length,_=ce(),E=xc(8*v),D=E>>>3,N=0;N<m.length;N++){var A=m[N];typeof A=="bigint"?(B[D+2*N]=1n,B[D+2*N+1]=A):(B[D+2*N]=0n,kt()[D+2*N+1>>>0]=A)}return l=yy(l,0,v,E,f),ue(_),l};function oc(l){if(a)return ze(0,1,l);if(S=l,!(0<Yn)){for(var f of Io)gg(f);for(f of Jn)gg(f);Jn=[],Io=[],Er={},we=!0}g(0,new rc(l))}function vg(l){if(a)return ze(1,0,l);sc(l)}var sc=l=>{if(S=l,a)throw vg(l),"unwind";oc(l)},Jn=[],Io=[],_g=[],Er={},wg=l=>{var f=l.xd;delete Er[f],Jn.push(l),Io.splice(Io.indexOf(l),1),l.xd=0,vy(f)};function bg(){_g.forEach(l=>l())}var Ig=l=>new Promise(f=>{l.onmessage=_=>{var E=(_=_.data).yd;if(_.Ed&&_.Ed!=ca()){var D=Er[_.Ed];D?D.postMessage(_,_.Ld):b(`Internal error! Worker sent a message "${E}" to target pthread ${_.Ed}, but that thread no longer exists!`)}else E==="checkMailbox"?na():E==="spawnThread"?yg(_):E==="cleanupThread"?wg(Er[_.ee]):E==="loaded"?(l.loaded=!0,f(l)):E==="alert"?alert(`Thread ${_.fe}: ${_.text}`):_.target==="setimmediate"?l.postMessage(_):E==="callHandler"?r[_.Nd](..._.args):E&&b(`worker sent an unknown command ${E}`)},l.onerror=_=>{throw b(`worker sent an error! ${_.filename}:${_.lineno}: ${_.message}`),_};var m,v=[];for(m of[])r.propertyIsEnumerable(m)&&v.push(m);l.postMessage({yd:"load",Od:v,he:T,ie:C})});function xg(){var l=new Worker(import.meta.url.startsWith("file:")?new URL("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});Jn.push(l)}var Y2=l=>{Tt();var f=te()[l+52>>>2>>>0];l=te()[l+56>>>2>>>0],by(f,f-l),ue(f)},J2=(l,f)=>{Yn=0,l=Ec(l,f),0<Yn?S=l:Ic(l)},ta=[];function X2(l){var f=new ac(l>>>=0);if(Q()[f.wd+12>>>0]==0){var m=1;Q()[f.wd+12>>>0]=m}return m=0,Q()[f.wd+13>>>0]=m,ta.push(f),xy(l),Ty(l)}var fi=0,eM=()=>{de(0,0);var l=ta.pop();Iy(l.Gd),fi=0};class ac{constructor(f){this.Gd=f,this.wd=f-24}}function tM(l){throw fi||=l>>>0,fi}var uc=l=>{var f=fi;if(!f)return Eo(0),0;var m=new ac(f);te()[m.wd+16>>>2>>>0]=f;var v=te()[m.wd+4>>>2>>>0];if(!v)return Eo(0),f;for(var _ of l){if(_===0||_===v)break;if(Ey(_,v,m.wd+16))return Eo(_),f}return Eo(v),f};function nM(){return uc([])}function rM(l){return uc([l>>>0])}function iM(l,f){return uc([l>>>0,f>>>0])}var oM=()=>{var l=ta.pop();l||Ln("no exception to throw");var f=l.Gd;if(Q()[l.wd+13>>>0]==0){ta.push(l);var m=1;Q()[l.wd+13>>>0]=m,m=0,Q()[l.wd+12>>>0]=m}throw fi=f};function sM(l,f,m){var v=new ac(l>>>=0);throw f>>>=0,m>>>=0,te()[v.wd+16>>>2>>>0]=0,te()[v.wd+4>>>2>>>0]=f,te()[v.wd+8>>>2>>>0]=m,fi=l}function Eg(l,f,m,v){return a?ze(2,1,l,f,m,v):Tg(l,f,m,v)}function Tg(l,f,m,v){if(l>>>=0,m>>>=0,v>>>=0,u===void 0)return 6;var _=[];return a&&_.length===0?Eg(l,f>>>=0,m,v):(l={ce:m,xd:l,Fd:v,Ld:_},a?(l.yd="spawnThread",postMessage(l,_),0):yg(l))}var Cg=typeof TextDecoder<"u"?new TextDecoder:void 0,Dg=(l,f=0,m=NaN)=>{var v=(f>>>=0)+m;for(m=f;l[m]&&!(m>=v);)++m;if(16<m-f&&l.buffer&&Cg)return Cg.decode(l.buffer instanceof ArrayBuffer?l.subarray(f,m):l.slice(f,m));for(v="";f<m;){var _=l[f++];if(128&_){var E=63&l[f++];if((224&_)==192)v+=String.fromCharCode((31&_)<<6|E);else{var D=63&l[f++];65536>(_=(240&_)==224?(15&_)<<12|E<<6|D:(7&_)<<18|E<<12|D<<6|63&l[f++])?v+=String.fromCharCode(_):(_-=65536,v+=String.fromCharCode(55296|_>>10,56320|1023&_))}}else v+=String.fromCharCode(_)}return v},Xe=(l,f)=>(l>>>=0)?Dg(Te(),l,f):"";function Sg(l,f,m){return a?ze(3,1,l,f,m):0}function $g(l,f){if(a)return ze(4,1,l,f)}var Mg=l=>{for(var f=0,m=0;m<l.length;++m){var v=l.charCodeAt(m);127>=v?f++:2047>=v?f+=2:55296<=v&&57343>=v?(f+=4,++m):f+=3}return f},pi=(l,f,m)=>{var v=Te();if(f>>>=0,0<m){var _=f;m=f+m-1;for(var E=0;E<l.length;++E){var D=l.charCodeAt(E);if(55296<=D&&57343>=D&&(D=65536+((1023&D)<<10)|1023&l.charCodeAt(++E)),127>=D){if(f>=m)break;v[f++>>>0]=D}else{if(2047>=D){if(f+1>=m)break;v[f++>>>0]=192|D>>6}else{if(65535>=D){if(f+2>=m)break;v[f++>>>0]=224|D>>12}else{if(f+3>=m)break;v[f++>>>0]=240|D>>18,v[f++>>>0]=128|D>>12&63}v[f++>>>0]=128|D>>6&63}v[f++>>>0]=128|63&D}}v[f>>>0]=0,l=f-_}else l=0;return l};function Ng(l,f){if(a)return ze(5,1,l,f)}function kg(l,f,m){if(a)return ze(6,1,l,f,m)}function Ag(l,f,m){return a?ze(7,1,l,f,m):0}function Rg(l,f){if(a)return ze(8,1,l,f)}function Og(l,f,m){if(a)return ze(9,1,l,f,m)}function Pg(l,f,m,v){if(a)return ze(10,1,l,f,m,v)}function Lg(l,f,m,v){if(a)return ze(11,1,l,f,m,v)}function Fg(l,f,m,v){if(a)return ze(12,1,l,f,m,v)}function zg(l){if(a)return ze(13,1,l)}function Bg(l,f){if(a)return ze(14,1,l,f)}function jg(l,f,m){if(a)return ze(15,1,l,f,m)}var Vg,Xn,aM=()=>Ln(""),mn=l=>{for(var f="";Te()[l>>>0];)f+=Vg[Te()[l++>>>0]];return f},lc={},cc={},uM={};function Fn(l,f,m={}){return(function(v,_,E={}){var D=_.name;if(!v)throw new Xn(`type "${D}" must have a positive integer typeid pointer`);if(cc.hasOwnProperty(v)){if(E.Pd)return;throw new Xn(`Cannot register type '${D}' twice`)}cc[v]=_,delete uM[v],lc.hasOwnProperty(v)&&(_=lc[v],delete lc[v],_.forEach(N=>N()))})(l,f,m)}var Hg=(l,f,m)=>{switch(f){case 1:return m?v=>Q()[v>>>0]:v=>Te()[v>>>0];case 2:return m?v=>z()[v>>>1>>>0]:v=>W()[v>>>1>>>0];case 4:return m?v=>R()[v>>>2>>>0]:v=>te()[v>>>2>>>0];case 8:return m?v=>B[v>>>3]:v=>ye[v>>>3];default:throw new TypeError(`invalid integer width (${f}): ${l}`)}};function lM(l,f,m){m>>>=0,Fn(l>>>=0,{name:f=mn(f>>>0),fromWireType:v=>v,toWireType:function(v,_){if(typeof _!="bigint"&&typeof _!="number")throw _=_===null?"null":(v=typeof _)=="object"||v==="array"||v==="function"?_.toString():""+_,new TypeError(`Cannot convert "${_}" to ${this.name}`);return typeof _=="number"&&(_=BigInt(_)),_},zd:er,readValueFromPointer:Hg(f,m,f.indexOf("u")==-1),Ad:null})}var er=8;function cM(l,f,m,v){Fn(l>>>=0,{name:f=mn(f>>>0),fromWireType:function(_){return!!_},toWireType:function(_,E){return E?m:v},zd:er,readValueFromPointer:function(_){return this.fromWireType(Te()[_>>>0])},Ad:null})}var dc=[],zn=[];function fc(l){9<(l>>>=0)&&--zn[l+1]==0&&(zn[l]=void 0,dc.push(l))}var At=l=>{if(!l)throw new Xn("Cannot use deleted val. handle = "+l);return zn[l]},Bt=l=>{switch(l){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let f=dc.pop()||zn.length;return zn[f]=l,zn[f+1]=1,f}};function pc(l){return this.fromWireType(te()[l>>>2>>>0])}var dM={name:"emscripten::val",fromWireType:l=>{var f=At(l);return fc(l),f},toWireType:(l,f)=>Bt(f),zd:er,readValueFromPointer:pc,Ad:null};function fM(l){return Fn(l>>>0,dM)}var pM=(l,f)=>{switch(f){case 4:return function(m){return this.fromWireType(Ze()[m>>>2>>>0])};case 8:return function(m){return this.fromWireType(kt()[m>>>3>>>0])};default:throw new TypeError(`invalid float width (${f}): ${l}`)}};function hM(l,f,m){m>>>=0,Fn(l>>>=0,{name:f=mn(f>>>0),fromWireType:v=>v,toWireType:(v,_)=>_,zd:er,readValueFromPointer:pM(f,m),Ad:null})}function mM(l,f,m,v,_){if(l>>>=0,m>>>=0,f=mn(f>>>0),_===-1&&(_=4294967295),_=N=>N,v===0){var E=32-8*m;_=N=>N<<E>>>E}var D=f.includes("unsigned")?function(N,A){return A>>>0}:function(N,A){return A};Fn(l,{name:f,fromWireType:_,toWireType:D,zd:er,readValueFromPointer:Hg(f,m,v!==0),Ad:null})}function gM(l,f,m){function v(E){var D=te()[E>>>2>>>0];return E=te()[E+4>>>2>>>0],new _(Q().buffer,E,D)}var _=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][f];Fn(l>>>=0,{name:m=mn(m>>>0),fromWireType:v,zd:er,readValueFromPointer:v},{Pd:!0})}function yM(l,f){Fn(l>>>=0,{name:f=mn(f>>>0),fromWireType:function(m){for(var v,_=te()[m>>>2>>>0],E=m+4,D=E,N=0;N<=_;++N){var A=E+N;N!=_&&Te()[A>>>0]!=0||(D=Xe(D,A-D),v===void 0?v=D:(v+="\0",v+=D),D=A+1)}return yn(m),v},toWireType:function(m,v){v instanceof ArrayBuffer&&(v=new Uint8Array(v));var _=typeof v=="string";if(!(_||v instanceof Uint8Array||v instanceof Uint8ClampedArray||v instanceof Int8Array))throw new Xn("Cannot pass non-string to std::string");var E=_?Mg(v):v.length,D=da(4+E+1),N=D+4;if(te()[D>>>2>>>0]=E,_)pi(v,N,E+1);else if(_)for(_=0;_<E;++_){var A=v.charCodeAt(_);if(255<A)throw yn(D),new Xn("String has UTF-16 code units that do not fit in 8 bits");Te()[N+_>>>0]=A}else for(_=0;_<E;++_)Te()[N+_>>>0]=v[_];return m!==null&&m.push(yn,D),D},zd:er,readValueFromPointer:pc,Ad(m){yn(m)}})}var Ug=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,vM=(l,f)=>{for(var m=l>>1,v=m+f/2;!(m>=v)&&W()[m>>>0];)++m;if(32<(m<<=1)-l&&Ug)return Ug.decode(Te().slice(l,m));for(m="",v=0;!(v>=f/2);++v){var _=z()[l+2*v>>>1>>>0];if(_==0)break;m+=String.fromCharCode(_)}return m},_M=(l,f,m)=>{if(m??=2147483647,2>m)return 0;var v=f;m=(m-=2)<2*l.length?m/2:l.length;for(var _=0;_<m;++_){var E=l.charCodeAt(_);z()[f>>>1>>>0]=E,f+=2}return z()[f>>>1>>>0]=0,f-v},wM=l=>2*l.length,bM=(l,f)=>{for(var m=0,v="";!(m>=f/4);){var _=R()[l+4*m>>>2>>>0];if(_==0)break;++m,65536<=_?(_-=65536,v+=String.fromCharCode(55296|_>>10,56320|1023&_)):v+=String.fromCharCode(_)}return v},IM=(l,f,m)=>{if(f>>>=0,m??=2147483647,4>m)return 0;var v=f;m=v+m-4;for(var _=0;_<l.length;++_){var E=l.charCodeAt(_);if(55296<=E&&57343>=E&&(E=65536+((1023&E)<<10)|1023&l.charCodeAt(++_)),R()[f>>>2>>>0]=E,(f+=4)+4>m)break}return R()[f>>>2>>>0]=0,f-v},xM=l=>{for(var f=0,m=0;m<l.length;++m){var v=l.charCodeAt(m);55296<=v&&57343>=v&&++m,f+=4}return f};function EM(l,f,m){if(l>>>=0,f>>>=0,m=mn(m>>>=0),f===2)var v=vM,_=_M,E=wM,D=N=>W()[N>>>1>>>0];else f===4&&(v=bM,_=IM,E=xM,D=N=>te()[N>>>2>>>0]);Fn(l,{name:m,fromWireType:N=>{for(var A,j=te()[N>>>2>>>0],q=N+4,ee=0;ee<=j;++ee){var fe=N+4+ee*f;ee!=j&&D(fe)!=0||(q=v(q,fe-q),A===void 0?A=q:(A+="\0",A+=q),q=fe+f)}return yn(N),A},toWireType:(N,A)=>{if(typeof A!="string")throw new Xn(`Cannot pass non-string to C++ string type ${m}`);var j=E(A),q=da(4+j+f);return te()[q>>>2>>>0]=j/f,_(A,q+4,j+f),N!==null&&N.push(yn,q),q},zd:er,readValueFromPointer:pc,Ad(N){yn(N)}})}function TM(l,f){Fn(l>>>=0,{Qd:!0,name:f=mn(f>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function CM(l){bc(l>>>0,!s,1,!o,131072,!1),bg()}var hc=l=>{if(!we)try{if(l(),!(0<Yn))try{a?Ic(S):sc(S)}catch(f){f instanceof rc||f=="unwind"||g(0,f)}}catch(f){f instanceof rc||f=="unwind"||g(0,f)}};function mc(l){l>>>=0,typeof Atomics.ge=="function"&&(Atomics.ge(R(),l>>>2,l).value.then(na),l+=128,Atomics.store(R(),l>>>2,1))}var na=()=>{var l=ca();l&&(mc(l),hc(wy))};function DM(l,f){(l>>>=0)==f>>>0?setTimeout(na):a?postMessage({Ed:l,yd:"checkMailbox"}):(l=Er[l])&&l.postMessage({yd:"checkMailbox"})}var gc=[];function SM(l,f,m,v,_){for(f>>>=0,v/=2,gc.length=v,m=_>>>0>>>3,_=0;_<v;_++)gc[_]=B[m+2*_]?B[m+2*_+1]:kt()[m+2*_+1>>>0];return(f?nc[f]:bN[l])(...gc)}var $M=()=>{Yn=0};function MM(l){l>>>=0,a?postMessage({yd:"cleanupThread",ee:l}):wg(Er[l])}function NM(l){}var ra=(l,f)=>{var m=cc[l];if(m===void 0)throw l=hy(l),m=mn(l),yn(l),new Xn(`${f} has unknown type ${m}`);return m},Wg=(l,f,m)=>{var v=[];return l=l.toWireType(v,m),v.length&&(te()[f>>>2>>>0]=Bt(v)),l};function kM(l,f,m){return f>>>=0,m>>>=0,l=At(l>>>0),f=ra(f,"emval::as"),Wg(f,m,l)}function AM(l,f){return f>>>=0,l=At(l>>>0),(f=ra(f,"emval::as")).toWireType(null,l)}var ia=l=>{try{l()}catch(f){Ln(f)}},tr=0,gn=null,qg=0,oa=[],Gg={},Kg={},RM=0,yc=null,OM=[];function Qg(l){return(function(f){if(!we){if(tr===0){var m=!1,v=!1;f((_=0)=>{if(!we&&(qg=_,m=!0,v)){tr=2,ia(()=>vv(gn)),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.resume(),_=!1;try{var E=(function(){var A=R()[gn+8>>>2>>>0];return A=F[Kg[A]],--Yn,A()})()}catch(A){E=A,_=!0}var D=!1;if(!gn){var N=yc;N&&(yc=null,(_?N.reject:N.resolve)(E),D=!0)}if(_&&!D)throw E}}),v=!0,m||(tr=1,gn=(function(){var _=da(65548),E=_+12;te()[_>>>2>>>0]=E,te()[_+4>>>2>>>0]=E+65536,E=oa[0];var D=Gg[E];return D===void 0&&(D=RM++,Gg[E]=D,Kg[D]=E),E=D,R()[_+8>>>2>>>0]=E,_})(),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.pause(),ia(()=>gv(gn)))}else tr===2?(tr=0,ia(_v),yn(gn),gn=null,OM.forEach(hc)):Ln(`invalid state: ${tr}`);return qg}})(f=>{l().then(f)})}function PM(l){return l>>>=0,Qg(async()=>{var f=await At(l);return Bt(f)})}var sa=[];function LM(l,f,m,v){return m>>>=0,v>>>=0,(l=sa[l>>>0])(null,f=At(f>>>0),m,v)}var FM={},aa=l=>{var f=FM[l];return f===void 0?mn(l):f};function zM(l,f,m,v,_){return m>>>=0,v>>>=0,_>>>=0,(l=sa[l>>>0])(f=At(f>>>0),f[m=aa(m)],v,_)}var Zg=()=>typeof globalThis=="object"?globalThis:Function("return this")();function BM(l){return(l>>>=0)==0?Bt(Zg()):(l=aa(l),Bt(Zg()[l]))}var jM=l=>{var f=sa.length;return sa.push(l),f},VM=(l,f)=>{for(var m=Array(l),v=0;v<l;++v)m[v]=ra(te()[f+4*v>>>2>>>0],"parameter "+v);return m},Yg=(l,f)=>Object.defineProperty(f,"name",{value:l});function HM(l,f,m){var v=(f=VM(l,f>>>0)).shift();l--;var _=`return function (obj, func, destructorsRef, args) {
`,E=0,D=[];m===0&&D.push("obj");for(var N=["retType"],A=[v],j=0;j<l;++j)D.push("arg"+j),N.push("argType"+j),A.push(f[j]),_+=`  var arg${j} = argType${j}.readValueFromPointer(args${E?"+"+E:""});
`,E+=f[j].zd;return _+=`  var rv = ${m===1?"new func":"func.call"}(${D.join(", ")});
`,v.Qd||(N.push("emval_returnValue"),A.push(Wg),_+=`  return emval_returnValue(retType, destructorsRef, rv);
`),N.push(_+`};
`),l=(function(q){var ee=Function;if(!(ee instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof ee} which is not a function`);var fe=Yg(ee.name||"unknownFunctionName",function(){});return fe.prototype=ee.prototype,fe=new fe,(q=ee.apply(fe,q))instanceof Object?q:fe})(N)(...A),m=`methodCaller<(${f.map(q=>q.name).join(", ")}) => ${v.name}>`,jM(Yg(m,l))}function UM(l){return l=aa(l>>>0),Bt(r[l])}function WM(l,f){return f>>>=0,l=At(l>>>0),f=At(f),Bt(l[f])}function qM(l){9<(l>>>=0)&&(zn[l+1]+=1)}function GM(){return Bt([])}function KM(l){l=At(l>>>0);for(var f=Array(l.length),m=0;m<l.length;m++)f[m]=l[m];return Bt(f)}function QM(l){return Bt(aa(l>>>0))}function ZM(){return Bt({})}function YM(l){for(var f=At(l>>>=0);f.length;){var m=f.pop();f.pop()(m)}fc(l)}function JM(l,f,m){f>>>=0,m>>>=0,l=At(l>>>0),f=At(f),m=At(m),l[f]=m}function XM(l,f){return f>>>=0,l=(l=ra(l>>>0,"_emval_take_value")).readValueFromPointer(f),Bt(l)}function eN(l,f){l=-9007199254740992>l||9007199254740992<l?NaN:Number(l),f>>>=0,l=new Date(1e3*l),R()[f>>>2>>>0]=l.getUTCSeconds(),R()[f+4>>>2>>>0]=l.getUTCMinutes(),R()[f+8>>>2>>>0]=l.getUTCHours(),R()[f+12>>>2>>>0]=l.getUTCDate(),R()[f+16>>>2>>>0]=l.getUTCMonth(),R()[f+20>>>2>>>0]=l.getUTCFullYear()-1900,R()[f+24>>>2>>>0]=l.getUTCDay(),l=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,R()[f+28>>>2>>>0]=l}var Jg=l=>l%4==0&&(l%100!=0||l%400==0),Xg=[0,31,60,91,121,152,182,213,244,274,305,335],ey=[0,31,59,90,120,151,181,212,243,273,304,334];function tN(l,f){l=-9007199254740992>l||9007199254740992<l?NaN:Number(l),f>>>=0,l=new Date(1e3*l),R()[f>>>2>>>0]=l.getSeconds(),R()[f+4>>>2>>>0]=l.getMinutes(),R()[f+8>>>2>>>0]=l.getHours(),R()[f+12>>>2>>>0]=l.getDate(),R()[f+16>>>2>>>0]=l.getMonth(),R()[f+20>>>2>>>0]=l.getFullYear()-1900,R()[f+24>>>2>>>0]=l.getDay();var m=(Jg(l.getFullYear())?Xg:ey)[l.getMonth()]+l.getDate()-1|0;R()[f+28>>>2>>>0]=m,R()[f+36>>>2>>>0]=-60*l.getTimezoneOffset(),m=new Date(l.getFullYear(),6,1).getTimezoneOffset();var v=new Date(l.getFullYear(),0,1).getTimezoneOffset();l=0|(m!=v&&l.getTimezoneOffset()==Math.min(v,m)),R()[f+32>>>2>>>0]=l}function nN(l){l>>>=0;var f=new Date(R()[l+20>>>2>>>0]+1900,R()[l+16>>>2>>>0],R()[l+12>>>2>>>0],R()[l+8>>>2>>>0],R()[l+4>>>2>>>0],R()[l>>>2>>>0],0),m=R()[l+32>>>2>>>0],v=f.getTimezoneOffset(),_=new Date(f.getFullYear(),6,1).getTimezoneOffset(),E=new Date(f.getFullYear(),0,1).getTimezoneOffset(),D=Math.min(E,_);return 0>m?R()[l+32>>>2>>>0]=+(_!=E&&D==v):0<m!=(D==v)&&(_=Math.max(E,_),f.setTime(f.getTime()+6e4*((0<m?D:_)-v))),R()[l+24>>>2>>>0]=f.getDay(),m=(Jg(f.getFullYear())?Xg:ey)[f.getMonth()]+f.getDate()-1|0,R()[l+28>>>2>>>0]=m,R()[l>>>2>>>0]=f.getSeconds(),R()[l+4>>>2>>>0]=f.getMinutes(),R()[l+8>>>2>>>0]=f.getHours(),R()[l+12>>>2>>>0]=f.getDate(),R()[l+16>>>2>>>0]=f.getMonth(),R()[l+20>>>2>>>0]=f.getYear(),l=f.getTime(),BigInt(isNaN(l)?-1:l/1e3)}function ty(l,f,m,v,_,E,D){return a?ze(16,1,l,f,m,v,_,E,D):-52}function ny(l,f,m,v,_,E){if(a)return ze(17,1,l,f,m,v,_,E)}var xo={},rN=()=>performance.timeOrigin+performance.now();function ry(l,f){if(a)return ze(18,1,l,f);if(xo[l]&&(clearTimeout(xo[l].id),delete xo[l]),!f)return 0;var m=setTimeout(()=>{delete xo[l],hc(()=>_y(l,performance.timeOrigin+performance.now()))},f);return xo[l]={id:m,ke:f},0}function iN(l,f,m,v){l>>>=0,f>>>=0,m>>>=0,v>>>=0;var _=new Date().getFullYear(),E=new Date(_,0,1).getTimezoneOffset();_=new Date(_,6,1).getTimezoneOffset();var D=Math.max(E,_);te()[l>>>2>>>0]=60*D,R()[f>>>2>>>0]=+(E!=_),l=(f=N=>{var A=Math.abs(N);return`UTC${0<=N?"-":"+"}${String(Math.floor(A/60)).padStart(2,"0")}${String(A%60).padStart(2,"0")}`})(E),f=f(_),_<E?(pi(l,m,17),pi(f,v,17)):(pi(l,v,17),pi(f,m,17))}var oN=()=>Date.now(),sN=1;function aN(l,f,m){if(!(0<=l&&3>=l))return 28;if(l===0)l=Date.now();else{if(!sN)return 52;l=performance.timeOrigin+performance.now()}return B[m>>>0>>>3]=BigInt(Math.round(1e6*l)),0}var vc=[],iy=(l,f)=>{vc.length=0;for(var m;m=Te()[l++>>>0];){var v=m!=105;f+=(v&=m!=112)&&f%8?4:0,vc.push(m==112?te()[f>>>2>>>0]:m==106?B[f>>>3]:m==105?R()[f>>>2>>>0]:kt()[f>>>3>>>0]),f+=v?8:4}return vc};function uN(l,f,m){return l>>>=0,f=iy(f>>>0,m>>>0),nc[l](...f)}function lN(l,f,m){return l>>>=0,f=iy(f>>>0,m>>>0),nc[l](...f)}var cN=()=>{};function dN(l,f){return b(Xe(l>>>0,f>>>0))}var fN=()=>{throw Yn+=1,"unwind"};function pN(){return 4294901760}var hN=()=>navigator.hardwareConcurrency;function mN(){return Ln("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function gN(l){l>>>=0;var f=Te().length;if(l<=f||4294901760<l)return!1;for(var m=1;4>=m;m*=2){var v=f*(1+.2/m);v=Math.min(v,l+100663296);e:{v=(Math.min(4294901760,65536*Math.ceil(Math.max(l,v)/65536))-T.buffer.byteLength+65535)/65536|0;try{T.grow(v),Tt();var _=1;break e}catch{}_=void 0}if(_)return!0}return!1}var ua=()=>(Ln("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),hi={},oy=l=>{l.forEach(f=>{var m=ua();m&&(hi[m]=f)})};function yN(){var l=Error().stack.toString().split(`
`);return l[0]=="Error"&&l.shift(),oy(l),hi.Kd=ua(),hi.ae=l,hi.Kd}function vN(l,f,m){if(l>>>=0,f>>>=0,hi.Kd==l)var v=hi.ae;else(v=Error().stack.toString().split(`
`))[0]=="Error"&&v.shift(),oy(v);for(var _=3;v[_]&&ua()!=l;)++_;for(l=0;l<m&&v[l+_];++l)R()[f+4*l>>>2>>>0]=ua();return l}var _c,wc={},sy=()=>{if(!_c){var l,f={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(l in wc)wc[l]===void 0?delete f[l]:f[l]=wc[l];var m=[];for(l in f)m.push(`${l}=${f[l]}`);_c=m}return _c};function ay(l,f){if(a)return ze(19,1,l,f);l>>>=0,f>>>=0;var m=0;return sy().forEach((v,_)=>{var E=f+m;for(_=te()[l+4*_>>>2>>>0]=E,E=0;E<v.length;++E)Q()[_++>>>0]=v.charCodeAt(E);Q()[_>>>0]=0,m+=v.length+1}),0}function uy(l,f){if(a)return ze(20,1,l,f);l>>>=0,f>>>=0;var m=sy();te()[l>>>2>>>0]=m.length;var v=0;return m.forEach(_=>v+=_.length+1),te()[f>>>2>>>0]=v,0}function ly(l){return a?ze(21,1,l):52}function cy(l,f,m,v){return a?ze(22,1,l,f,m,v):52}function dy(l,f,m,v){return a?ze(23,1,l,f,m,v):70}var _N=[null,[],[]];function fy(l,f,m,v){if(a)return ze(24,1,l,f,m,v);f>>>=0,m>>>=0,v>>>=0;for(var _=0,E=0;E<m;E++){var D=te()[f>>>2>>>0],N=te()[f+4>>>2>>>0];f+=8;for(var A=0;A<N;A++){var j=Te()[D+A>>>0],q=_N[l];j===0||j===10?((l===1?I:b)(Dg(q)),q.length=0):q.push(j)}_+=N}return te()[v>>>2>>>0]=_,0}function wN(l){return l>>>0}a||(function(){for(var l=r.numThreads-1;l--;)xg();ic.unshift(()=>{wo++,(function(f){a?f():Promise.all(Jn.map(Ig)).then(f)})(()=>hg())})})();for(var py=Array(256),la=0;256>la;++la)py[la]=String.fromCharCode(la);Vg=py,Xn=r.BindingError=class extends Error{constructor(l){super(l),this.name="BindingError"}},r.InternalError=class extends Error{constructor(l){super(l),this.name="InternalError"}},zn.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>zn.length/2-5-dc.length;var F,bN=[oc,vg,Eg,Sg,$g,Ng,kg,Ag,Rg,Og,Pg,Lg,Fg,zg,Bg,jg,ty,ny,ry,ay,uy,ly,cy,dy,fy];(async function(){function l(v,_){return F=v.exports,F=(function(){var E=F,D={};for(let[N,A]of Object.entries(E))D[N]=typeof A=="function"?(...j)=>{oa.push(N);try{return A(...j)}finally{we||(oa.pop(),gn&&tr===1&&oa.length===0&&(tr=0,Yn+=1,ia(yv),typeof Fibers<"u"&&Fibers.le()))}}:A;return D})(),F=(function(){var E=F,D=A=>j=>A(j)>>>0,N=A=>()=>A()>>>0;return(E=Object.assign({},E)).Cb=D(E.Cb),E.fc=N(E.fc),E.ic=D(E.ic),E.vc=D(E.vc),E.wc=N(E.wc),E.Ac=D(E.Ac),E})(),_g.push(F.jc),C=_,hg(),F}wo++;var f=mg();if(r.instantiateWasm)return new Promise(v=>{r.instantiateWasm(f,(_,E)=>{l(_,E),v(_.exports)})});if(a)return new Promise(v=>{Je=_=>{var E=new WebAssembly.Instance(_,mg());v(l(E,_))}});tc??=r.locateFile?r.locateFile?r.locateFile("ort-wasm-simd-threaded.jsep.wasm",y):y+"ort-wasm-simd-threaded.jsep.wasm":new URL("ort-wasm-simd-threaded.jsep.wasm",import.meta.url).href;try{var m=await(async function(v){var _=tc;if(!K&&typeof WebAssembly.instantiateStreaming=="function"&&!Ee(_))try{var E=fetch(_,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(E,v)}catch(D){b(`wasm streaming compile failed: ${D}`),b("falling back to ArrayBuffer instantiation")}return(async function(D,N){try{var A=await(async function(j){if(!K)try{var q=await d(j);return new Uint8Array(q)}catch{}if(j==tc&&K)j=new Uint8Array(K);else{if(!p)throw"both async and sync fetching of the wasm failed";j=p(j)}return j})(D);return await WebAssembly.instantiate(A,N)}catch(j){b(`failed to asynchronously prepare wasm: ${j}`),Ln(j)}})(_,v)})(f);return l(m.instance,m.module)}catch(v){return n(v),Promise.reject(v)}})();var hy=l=>(hy=F.Cb)(l),my=()=>(my=F.Db)();r._OrtInit=(l,f)=>(r._OrtInit=F.Eb)(l,f),r._OrtGetLastError=(l,f)=>(r._OrtGetLastError=F.Fb)(l,f),r._OrtCreateSessionOptions=(l,f,m,v,_,E,D,N,A,j)=>(r._OrtCreateSessionOptions=F.Gb)(l,f,m,v,_,E,D,N,A,j),r._OrtAppendExecutionProvider=(l,f)=>(r._OrtAppendExecutionProvider=F.Hb)(l,f),r._OrtAddFreeDimensionOverride=(l,f,m)=>(r._OrtAddFreeDimensionOverride=F.Ib)(l,f,m),r._OrtAddSessionConfigEntry=(l,f,m)=>(r._OrtAddSessionConfigEntry=F.Jb)(l,f,m),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=F.Kb)(l),r._OrtCreateSession=(l,f,m)=>(r._OrtCreateSession=F.Lb)(l,f,m),r._OrtReleaseSession=l=>(r._OrtReleaseSession=F.Mb)(l),r._OrtGetInputOutputCount=(l,f,m)=>(r._OrtGetInputOutputCount=F.Nb)(l,f,m),r._OrtGetInputName=(l,f)=>(r._OrtGetInputName=F.Ob)(l,f),r._OrtGetOutputName=(l,f)=>(r._OrtGetOutputName=F.Pb)(l,f),r._OrtFree=l=>(r._OrtFree=F.Qb)(l),r._OrtCreateTensor=(l,f,m,v,_,E)=>(r._OrtCreateTensor=F.Rb)(l,f,m,v,_,E),r._OrtGetTensorData=(l,f,m,v,_)=>(r._OrtGetTensorData=F.Sb)(l,f,m,v,_),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=F.Tb)(l),r._OrtCreateRunOptions=(l,f,m,v)=>(r._OrtCreateRunOptions=F.Ub)(l,f,m,v),r._OrtAddRunConfigEntry=(l,f,m)=>(r._OrtAddRunConfigEntry=F.Vb)(l,f,m),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=F.Wb)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=F.Xb)(l),r._OrtBindInput=(l,f,m)=>(r._OrtBindInput=F.Yb)(l,f,m),r._OrtBindOutput=(l,f,m,v)=>(r._OrtBindOutput=F.Zb)(l,f,m,v),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=F._b)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=F.$b)(l),r._OrtRunWithBinding=(l,f,m,v,_)=>(r._OrtRunWithBinding=F.ac)(l,f,m,v,_),r._OrtRun=(l,f,m,v,_,E,D,N)=>(r._OrtRun=F.bc)(l,f,m,v,_,E,D,N),r._OrtEndProfiling=l=>(r._OrtEndProfiling=F.cc)(l),r._JsepOutput=(l,f,m)=>(r._JsepOutput=F.dc)(l,f,m),r._JsepGetNodeName=l=>(r._JsepGetNodeName=F.ec)(l);var ca=()=>(ca=F.fc)(),yn=r._free=l=>(yn=r._free=F.gc)(l),da=r._malloc=l=>(da=r._malloc=F.ic)(l),bc=(l,f,m,v,_,E)=>(bc=F.kc)(l,f,m,v,_,E),gy=()=>(gy=F.lc)(),yy=(l,f,m,v,_)=>(yy=F.mc)(l,f,m,v,_),vy=l=>(vy=F.nc)(l),Ic=l=>(Ic=F.oc)(l),_y=(l,f)=>(_y=F.pc)(l,f),wy=()=>(wy=F.qc)(),de=(l,f)=>(de=F.rc)(l,f),Eo=l=>(Eo=F.sc)(l),by=(l,f)=>(by=F.tc)(l,f),ue=l=>(ue=F.uc)(l),xc=l=>(xc=F.vc)(l),ce=()=>(ce=F.wc)(),Iy=l=>(Iy=F.xc)(l),xy=l=>(xy=F.yc)(l),Ey=(l,f,m)=>(Ey=F.zc)(l,f,m),Ty=l=>(Ty=F.Ac)(l),Cy=r.dynCall_iii=(l,f,m)=>(Cy=r.dynCall_iii=F.Bc)(l,f,m),Dy=r.dynCall_vi=(l,f)=>(Dy=r.dynCall_vi=F.Cc)(l,f),Ec=r.dynCall_ii=(l,f)=>(Ec=r.dynCall_ii=F.Dc)(l,f),Sy=r.dynCall_vii=(l,f,m)=>(Sy=r.dynCall_vii=F.Ec)(l,f,m),$y=r.dynCall_iiii=(l,f,m,v)=>($y=r.dynCall_iiii=F.Fc)(l,f,m,v),My=r.dynCall_viii=(l,f,m,v)=>(My=r.dynCall_viii=F.Gc)(l,f,m,v),Ny=r.dynCall_iiiii=(l,f,m,v,_)=>(Ny=r.dynCall_iiiii=F.Hc)(l,f,m,v,_),ky=r.dynCall_viiii=(l,f,m,v,_)=>(ky=r.dynCall_viiii=F.Ic)(l,f,m,v,_),Ay=r.dynCall_viiiiii=(l,f,m,v,_,E,D)=>(Ay=r.dynCall_viiiiii=F.Jc)(l,f,m,v,_,E,D),Ry=r.dynCall_viiiiiii=(l,f,m,v,_,E,D,N)=>(Ry=r.dynCall_viiiiiii=F.Kc)(l,f,m,v,_,E,D,N),Oy=r.dynCall_ji=(l,f)=>(Oy=r.dynCall_ji=F.Lc)(l,f),Py=r.dynCall_v=l=>(Py=r.dynCall_v=F.Mc)(l),Ly=r.dynCall_viiiii=(l,f,m,v,_,E)=>(Ly=r.dynCall_viiiii=F.Nc)(l,f,m,v,_,E),Fy=r.dynCall_i=l=>(Fy=r.dynCall_i=F.Oc)(l),zy=r.dynCall_fii=(l,f,m)=>(zy=r.dynCall_fii=F.Pc)(l,f,m),By=r.dynCall_viiiiiiii=(l,f,m,v,_,E,D,N,A)=>(By=r.dynCall_viiiiiiii=F.Qc)(l,f,m,v,_,E,D,N,A),jy=r.dynCall_viiiiiiiiii=(l,f,m,v,_,E,D,N,A,j,q)=>(jy=r.dynCall_viiiiiiiiii=F.Rc)(l,f,m,v,_,E,D,N,A,j,q),Vy=r.dynCall_jiii=(l,f,m,v)=>(Vy=r.dynCall_jiii=F.Sc)(l,f,m,v),Hy=r.dynCall_dii=(l,f,m)=>(Hy=r.dynCall_dii=F.Tc)(l,f,m),Uy=r.dynCall_viiiiiiiii=(l,f,m,v,_,E,D,N,A,j)=>(Uy=r.dynCall_viiiiiiiii=F.Uc)(l,f,m,v,_,E,D,N,A,j),Wy=r.dynCall_viiiiiiiiiii=(l,f,m,v,_,E,D,N,A,j,q,ee)=>(Wy=r.dynCall_viiiiiiiiiii=F.Vc)(l,f,m,v,_,E,D,N,A,j,q,ee),qy=r.dynCall_iiiiii=(l,f,m,v,_,E)=>(qy=r.dynCall_iiiiii=F.Wc)(l,f,m,v,_,E),Gy=r.dynCall_iij=(l,f,m)=>(Gy=r.dynCall_iij=F.Xc)(l,f,m),Ky=r.dynCall_iiiiiiiiii=(l,f,m,v,_,E,D,N,A,j)=>(Ky=r.dynCall_iiiiiiiiii=F.Yc)(l,f,m,v,_,E,D,N,A,j),Qy=r.dynCall_iiiiiiiiiii=(l,f,m,v,_,E,D,N,A,j,q)=>(Qy=r.dynCall_iiiiiiiiiii=F.Zc)(l,f,m,v,_,E,D,N,A,j,q),Zy=r.dynCall_vij=(l,f,m)=>(Zy=r.dynCall_vij=F._c)(l,f,m),Yy=r.dynCall_iiif=(l,f,m,v)=>(Yy=r.dynCall_iiif=F.$c)(l,f,m,v),Jy=r.dynCall_iiij=(l,f,m,v)=>(Jy=r.dynCall_iiij=F.ad)(l,f,m,v),Xy=r.dynCall_fiii=(l,f,m,v)=>(Xy=r.dynCall_fiii=F.bd)(l,f,m,v),ev=r.dynCall_viiiiiiiiiiiii=(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)=>(ev=r.dynCall_viiiiiiiiiiiii=F.cd)(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe),tv=r.dynCall_vjiii=(l,f,m,v,_)=>(tv=r.dynCall_vjiii=F.dd)(l,f,m,v,_),nv=r.dynCall_vif=(l,f,m)=>(nv=r.dynCall_vif=F.ed)(l,f,m),rv=r.dynCall_iiiiiii=(l,f,m,v,_,E,D)=>(rv=r.dynCall_iiiiiii=F.fd)(l,f,m,v,_,E,D),iv=r.dynCall_iiiij=(l,f,m,v,_)=>(iv=r.dynCall_iiiij=F.gd)(l,f,m,v,_),ov=r.dynCall_iiiiiiii=(l,f,m,v,_,E,D,N)=>(ov=r.dynCall_iiiiiiii=F.hd)(l,f,m,v,_,E,D,N),sv=r.dynCall_viiiiiiiiiiii=(l,f,m,v,_,E,D,N,A,j,q,ee,fe)=>(sv=r.dynCall_viiiiiiiiiiii=F.id)(l,f,m,v,_,E,D,N,A,j,q,ee,fe),av=r.dynCall_diii=(l,f,m,v)=>(av=r.dynCall_diii=F.jd)(l,f,m,v),uv=r.dynCall_jiiii=(l,f,m,v,_)=>(uv=r.dynCall_jiiii=F.kd)(l,f,m,v,_),lv=r.dynCall_viiij=(l,f,m,v,_)=>(lv=r.dynCall_viiij=F.ld)(l,f,m,v,_),cv=r.dynCall_fiiii=(l,f,m,v,_)=>(cv=r.dynCall_fiiii=F.md)(l,f,m,v,_),dv=r.dynCall_viiif=(l,f,m,v,_)=>(dv=r.dynCall_viiif=F.nd)(l,f,m,v,_),fv=r.dynCall_diiii=(l,f,m,v,_)=>(fv=r.dynCall_diiii=F.od)(l,f,m,v,_),pv=r.dynCall_viiid=(l,f,m,v,_)=>(pv=r.dynCall_viiid=F.pd)(l,f,m,v,_),hv=r.dynCall_iiiijii=(l,f,m,v,_,E,D)=>(hv=r.dynCall_iiiijii=F.qd)(l,f,m,v,_,E,D),mv=r.dynCall_iiiiiij=(l,f,m,v,_,E,D)=>(mv=r.dynCall_iiiiiij=F.rd)(l,f,m,v,_,E,D),gv=l=>(gv=F.sd)(l),yv=()=>(yv=F.td)(),vv=l=>(vv=F.ud)(l),_v=()=>(_v=F.vd)();function IN(l,f,m){var v=ce();try{Sy(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function xN(l,f,m){var v=ce();try{return Cy(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function EN(l,f){var m=ce();try{Dy(l,f)}catch(v){if(ue(m),v!==v+0)throw v;de(1,0)}}function TN(l,f){var m=ce();try{return Ec(l,f)}catch(v){if(ue(m),v!==v+0)throw v;de(1,0)}}function CN(l,f,m,v){var _=ce();try{return $y(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;de(1,0)}}function DN(l,f,m,v,_){var E=ce();try{ky(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function SN(l,f,m,v,_){var E=ce();try{return Ny(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function $N(l,f,m,v){var _=ce();try{My(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;de(1,0)}}function MN(l,f,m,v,_,E,D){var N=ce();try{return rv(l,f,m,v,_,E,D)}catch(A){if(ue(N),A!==A+0)throw A;de(1,0)}}function NN(l){var f=ce();try{Py(l)}catch(m){if(ue(f),m!==m+0)throw m;de(1,0)}}function kN(l,f,m){var v=ce();try{return Gy(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function AN(l,f,m,v,_,E){var D=ce();try{Ly(l,f,m,v,_,E)}catch(N){if(ue(D),N!==N+0)throw N;de(1,0)}}function RN(l,f,m){var v=ce();try{Zy(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function ON(l,f,m,v,_,E,D){var N=ce();try{Ay(l,f,m,v,_,E,D)}catch(A){if(ue(N),A!==A+0)throw A;de(1,0)}}function PN(l,f,m,v,_,E,D,N){var A=ce();try{Ry(l,f,m,v,_,E,D,N)}catch(j){if(ue(A),j!==j+0)throw j;de(1,0)}}function LN(l,f,m,v,_,E){var D=ce();try{return qy(l,f,m,v,_,E)}catch(N){if(ue(D),N!==N+0)throw N;de(1,0)}}function FN(l,f,m,v,_,E,D,N){var A=ce();try{return ov(l,f,m,v,_,E,D,N)}catch(j){if(ue(A),j!==j+0)throw j;de(1,0)}}function zN(l,f,m,v,_,E,D,N,A,j){var q=ce();try{Uy(l,f,m,v,_,E,D,N,A,j)}catch(ee){if(ue(q),ee!==ee+0)throw ee;de(1,0)}}function BN(l,f,m,v,_,E,D,N,A){var j=ce();try{By(l,f,m,v,_,E,D,N,A)}catch(q){if(ue(j),q!==q+0)throw q;de(1,0)}}function jN(l){var f=ce();try{return Fy(l)}catch(m){if(ue(f),m!==m+0)throw m;de(1,0)}}function VN(l,f,m,v,_,E,D,N,A,j){var q=ce();try{return Ky(l,f,m,v,_,E,D,N,A,j)}catch(ee){if(ue(q),ee!==ee+0)throw ee;de(1,0)}}function HN(l,f,m){var v=ce();try{return zy(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function UN(l,f,m,v){var _=ce();try{return Vy(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;return de(1,0),0n}}function WN(l,f,m){var v=ce();try{return Hy(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function qN(l,f,m,v,_,E,D,N,A,j,q,ee){var fe=ce();try{Wy(l,f,m,v,_,E,D,N,A,j,q,ee)}catch(Fe){if(ue(fe),Fe!==Fe+0)throw Fe;de(1,0)}}function GN(l,f,m,v,_,E,D,N,A,j,q){var ee=ce();try{jy(l,f,m,v,_,E,D,N,A,j,q)}catch(fe){if(ue(ee),fe!==fe+0)throw fe;de(1,0)}}function KN(l,f,m,v,_,E,D,N,A,j,q){var ee=ce();try{return Qy(l,f,m,v,_,E,D,N,A,j,q)}catch(fe){if(ue(ee),fe!==fe+0)throw fe;de(1,0)}}function QN(l,f,m,v){var _=ce();try{return Yy(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;de(1,0)}}function ZN(l,f,m,v){var _=ce();try{return Jy(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;de(1,0)}}function YN(l,f,m,v){var _=ce();try{return Xy(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;de(1,0)}}function JN(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe){var jt=ce();try{ev(l,f,m,v,_,E,D,N,A,j,q,ee,fe,Fe)}catch(To){if(ue(jt),To!==To+0)throw To;de(1,0)}}function XN(l,f,m,v,_){var E=ce();try{tv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function ek(l,f,m){var v=ce();try{nv(l,f,m)}catch(_){if(ue(v),_!==_+0)throw _;de(1,0)}}function tk(l,f){var m=ce();try{return Oy(l,f)}catch(v){if(ue(m),v!==v+0)throw v;return de(1,0),0n}}function nk(l,f,m,v,_){var E=ce();try{return iv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function rk(l,f,m,v,_,E,D,N,A,j,q,ee,fe){var Fe=ce();try{sv(l,f,m,v,_,E,D,N,A,j,q,ee,fe)}catch(jt){if(ue(Fe),jt!==jt+0)throw jt;de(1,0)}}function ik(l,f,m,v){var _=ce();try{return av(l,f,m,v)}catch(E){if(ue(_),E!==E+0)throw E;de(1,0)}}function ok(l,f,m,v,_){var E=ce();try{return uv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;return de(1,0),0n}}function sk(l,f,m,v,_){var E=ce();try{lv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function ak(l,f,m,v,_){var E=ce();try{return cv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function uk(l,f,m,v,_){var E=ce();try{dv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function lk(l,f,m,v,_){var E=ce();try{return fv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function ck(l,f,m,v,_){var E=ce();try{pv(l,f,m,v,_)}catch(D){if(ue(E),D!==D+0)throw D;de(1,0)}}function dk(l,f,m,v,_,E,D){var N=ce();try{return hv(l,f,m,v,_,E,D)}catch(A){if(ue(N),A!==A+0)throw A;de(1,0)}}function fk(l,f,m,v,_,E,D){var N=ce();try{return mv(l,f,m,v,_,E,D)}catch(A){if(ue(N),A!==A+0)throw A;de(1,0)}}return r.stackSave=()=>ce(),r.stackRestore=l=>ue(l),r.stackAlloc=l=>xc(l),r.setValue=function(l,f,m="i8"){switch(m.endsWith("*")&&(m="*"),m){case"i1":case"i8":Q()[l>>>0]=f;break;case"i16":z()[l>>>1>>>0]=f;break;case"i32":R()[l>>>2>>>0]=f;break;case"i64":B[l>>>3]=BigInt(f);break;case"float":Ze()[l>>>2>>>0]=f;break;case"double":kt()[l>>>3>>>0]=f;break;case"*":te()[l>>>2>>>0]=f;break;default:Ln(`invalid type for setValue: ${m}`)}},r.getValue=function(l,f="i8"){switch(f.endsWith("*")&&(f="*"),f){case"i1":case"i8":return Q()[l>>>0];case"i16":return z()[l>>>1>>>0];case"i32":return R()[l>>>2>>>0];case"i64":return B[l>>>3];case"float":return Ze()[l>>>2>>>0];case"double":return kt()[l>>>3>>>0];case"*":return te()[l>>>2>>>0];default:Ln(`invalid type for getValue: ${f}`)}},r.UTF8ToString=Xe,r.stringToUTF8=pi,r.lengthBytesUTF8=Mg,(function l(){if(0<wo)bo=l;else if(a)t(r),ea();else{for(;0<ic.length;)ic.shift()(r);0<wo?bo=l:(r.calledRun=!0,we||(ea(),t(r)))}})(),r.PTR_SIZE=4,i}),RD=Rh,PE=globalThis.self?.name?.startsWith("em-pthread"),PE&&Rh()}),Oh,LE,Lt,OD,Ml,FE,zE,Ph,BE,Lh,PD,Fh,LD,Bm=H(()=>{"use strict";zm(),Oh=typeof location>"u"?void 0:location.origin,LE=()=>import.meta.url?.startsWith("file:")?new URL(new URL("ort.bundle.min.mjs",import.meta.url).href,Oh).href:import.meta.url,Lt=LE(),OD=()=>{if(Lt&&!Lt.startsWith("blob:"))return Lt.substring(0,Lt.lastIndexOf("/")+1)},Ml=(e,t)=>{try{let n=t??Lt;return(n?new URL(e,n):new URL(e)).origin===Oh}catch{return!1}},FE=(e,t)=>{let n=t??Lt;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},zE=(e,t)=>`${t??"./"}${e}`,Ph=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},BE=async e=>(await import(e)).default,Lh=(Pj(),Wl(ND)).default,PD=async()=>{if(!Lt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ml(Lt))return[void 0,Lh()];let e=await Ph(Lt);return[e,Lh(e)]},Fh=(Lj(),Wl(AD)).default,LD=async(e,t,n)=>{if(!e&&!t&&Fh&&Lt&&Ml(Lt))return[void 0,Fh];{let r="ort-wasm-simd-threaded.jsep.mjs",i=e??FE(r,t),o=n&&i&&!Ml(i,t),s=o?await Ph(i):i??zE(r,t);return[o?s:void 0,await BE(s)]}}}),zh,Nl,zs,Bh,jE,VE,jm,nt,ci=H(()=>{"use strict";Bm(),Nl=!1,zs=!1,Bh=!1,jE=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},VE=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},jm=async e=>{if(Nl)return Promise.resolve();if(zs)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Bh)throw new Error("previous call to 'initializeWebAssembly()' failed.");zs=!0;let t=e.initTimeout,n=e.numThreads;if(!VE())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=jE();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let i=e.wasmPaths,o=typeof i=="string"?i:void 0,s=i?.mjs,a=s?.href??s,u=i?.wasm,c=u?.href??u,d=e.wasmBinary,[p,h]=await LD(a,o,n>1),g=!1,y=[];if(t>0&&y.push(new Promise(w=>{setTimeout(()=>{g=!0,w()},t)})),y.push(new Promise((w,x)=>{let I={numThreads:n};if(d)I.wasmBinary=d;else if(c||o)I.locateFile=b=>c??o+b;else if(a&&a.indexOf("blob:")!==0)I.locateFile=b=>new URL(b,a).href;else if(p){let b=OD();b&&(I.locateFile=T=>b+T)}h(I).then(b=>{zs=!1,Nl=!0,zh=b,w(),p&&URL.revokeObjectURL(p)},b=>{zs=!1,Bh=!0,x(b)})})),await Promise.race(y),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},nt=()=>{if(Nl&&zh)return zh;throw new Error("WebAssembly is not initialized yet.")}}),pt,Gl,$e,Vm=H(()=>{"use strict";ci(),pt=(e,t)=>{let n=nt(),r=n.lengthBytesUTF8(e)+1,i=n._malloc(r);return n.stringToUTF8(e,i,r),t.push(i),i},Gl=(e,t,n,r)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([i,o])=>{let s=t?t+i:i;if(typeof o=="object")Gl(o,s+".",n,r);else if(typeof o=="string"||typeof o=="number")r(s,o.toString());else if(typeof o=="boolean")r(s,o?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof o}`)})},$e=e=>{let t=nt(),n=t.stackSave();try{let r=t.PTR_SIZE,i=t.stackAlloc(2*r);t._OrtGetLastError(i,i+r);let o=Number(t.getValue(i,r===4?"i32":"i64")),s=t.getValue(i+r,"*"),a=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}}),FD,Fj=H(()=>{"use strict";ci(),Vm(),FD=e=>{let t=nt(),n=0,r=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let o=0;return e?.tag!==void 0&&(o=pt(e.tag,r)),n=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,o),n===0&&$e("Can't create run options."),e?.extra!==void 0&&Gl(e.extra,"",new WeakSet,(s,a)=>{let u=pt(s,r),c=pt(a,r);t._OrtAddRunConfigEntry(n,u,c)!==0&&$e(`Can't set a run config entry: ${s} - ${a}.`)}),[n,r]}catch(o){throw n!==0&&t._OrtReleaseRunOptions(n),r.forEach(s=>t._free(s)),o}}}),HE,UE,WE,qE,zD,zj=H(()=>{"use strict";ci(),Vm(),HE=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},UE=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},WE=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},qE=(e,t,n)=>{for(let r of t){let i=typeof r=="string"?r:r.name;switch(i){case"webnn":if(i="WEBNN",typeof r!="string"){let s=r?.deviceType;if(s){let a=pt("deviceType",n),u=pt(s,n);nt()._OrtAddSessionConfigEntry(e,a,u)!==0&&$e(`Can't set a session config entry: 'deviceType' - ${s}.`)}}break;case"webgpu":if(i="JS",typeof r!="string"){let s=r;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let a=pt("preferredLayout",n),u=pt(s.preferredLayout,n);nt()._OrtAddSessionConfigEntry(e,a,u)!==0&&$e(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let o=pt(i,n);nt()._OrtAppendExecutionProvider(e,o)!==0&&$e(`Can't append execution provider: ${i}.`)}},zD=e=>{let t=nt(),n=0,r=[],i=e||{};WE(i);try{let o=HE(i.graphOptimizationLevel??"all"),s=UE(i.executionMode??"sequential"),a=typeof i.logId=="string"?pt(i.logId,r):0,u=i.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let c=i.logVerbosityLevel??0;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log verbosity level is not valid: ${c}`);let d=typeof i.optimizedModelFilePath=="string"?pt(i.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(o,!!i.enableCpuMemArena,!!i.enableMemPattern,s,!!i.enableProfiling,0,a,u,c,d),n===0&&$e("Can't create session options."),i.executionProviders&&qE(n,i.executionProviders,r),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);let p=pt("enableGraphCapture",r),h=pt(i.enableGraphCapture.toString(),r);t._OrtAddSessionConfigEntry(n,p,h)!==0&&$e(`Can't set a session config entry: 'enableGraphCapture' - ${i.enableGraphCapture}.`)}if(i.freeDimensionOverrides)for(let[p,h]of Object.entries(i.freeDimensionOverrides)){if(typeof p!="string")throw new Error(`free dimension override name must be a string: ${p}`);if(typeof h!="number"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let g=pt(p,r);t._OrtAddFreeDimensionOverride(n,g,h)!==0&&$e(`Can't set a free dimension override: ${p} - ${h}.`)}return i.extra!==void 0&&Gl(i.extra,"",new WeakSet,(p,h)=>{let g=pt(p,r),y=pt(h,r);t._OrtAddSessionConfigEntry(n,g,y)!==0&&$e(`Can't set a session config entry: ${p} - ${h}.`)}),[n,r]}catch(o){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&$e("Can't release session options."),r.forEach(s=>t._free(s)),o}}}),mo,oi,si,Hm,Kl,Um,Wm,xm,se=H(()=>{"use strict";mo=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},oi=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},si=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r=typeof t=="number"?t:t.reduce((i,o)=>i*o,1);return n>0?Math.ceil(r*n):void 0},Hm=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Kl=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Um=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Wm=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",xm=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),qm,BD=H(()=>{"use strict";zm(),qm=async e=>{if(typeof e=="string"){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=t.body.getReader(),o;try{o=new ArrayBuffer(r)}catch(a){if(a instanceof RangeError){let u=Math.ceil(r/65536);o=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw a}let s=0;for(;;){let{done:a,value:u}=await i.read();if(a)break;let c=u.byteLength;new Uint8Array(o,s,c).set(u),s+=c}return new Uint8Array(o,0,r)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),GE,KE,QE,ZE,Gm,YE,Ce,Zn=H(()=>{"use strict";se(),GE=["V","I","W","E","F"],KE=(e,t)=>{console.log(`[${GE[e]},${new Date().toISOString()}]${t}`)},Gm=(e,t)=>{QE=e,ZE=t},YE=(e,t)=>{let n=Kl(e),r=Kl(QE);n>=r&&KE(n,typeof t=="function"?t():t)},Ce=(...e)=>{ZE&&YE(...e)}}),Km,jD=H(()=>{"use strict";se(),Km=(e,t)=>new(Hm(t))(e)}),Qm=H(()=>{"use strict"}),jh,kl,Al,JE,XE,Vh,Em,e1,VD,Bj=H(()=>{"use strict";Zn(),Qm(),jh=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),kl=[],Al=e=>Math.ceil(Number(e)/16)*16,JE=e=>{for(let t=0;t<kl.length;t++){let n=kl[t];if(e<=n)return n}return Math.ceil(e/16)*16},XE=1,Vh=()=>XE++,Em=async(e,t,n,r)=>{let i=Al(n),o=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,o,0,i),e.flush(),await o.mapAsync(GPUMapMode.READ);let a=o.getMappedRange();if(r){let u=r();return u.set(new Uint8Array(a,0,n)),u}else return new Uint8Array(a.slice(0,n))}finally{o.destroy()}},e1=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[t]of jh)kl.push(t),this.freeBuffers.set(t,[]),this.freeUniformBuffers.set(t,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,i=t.byteLength,o=Al(i),s=this.storageCache.get(e);if(!s)throw new Error("gpu data for uploading does not exist");if(Number(s.originalSize)!==i)throw new Error(`inconsistent data size. gpu data size=${s.originalSize}, data size=${i}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:o,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=a.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,r,i)),a.unmap();let c=this.backend.device.createCommandEncoder();c.copyBufferToBuffer(a,0,s.gpuData.buffer,0,o),this.backend.device.queue.submit([c.finish()]),a.destroy(),Ce("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let i=Al(n.originalSize),o=this.backend.getCommandEncoder();this.backend.endComputePass(),o.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,i)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return Ce("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else r=Vh();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),Ce("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`),r}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),Ce("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=JE(e),r,i=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,o=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||o){let a=(i?this.freeBuffers:this.freeUniformBuffers).get(n);a?a.length>0?r=a.pop():r=this.backend.device.createBuffer({size:n,usage:t}):r=this.backend.device.createBuffer({size:n,usage:t})}else r=this.backend.device.createBuffer({size:n,usage:t});let s={id:Vh(),type:0,buffer:r};return this.storageCache.set(s.id,{gpuData:s,originalSize:Number(e)}),Ce("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${s.id}`),s}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t=typeof e=="bigint"?Number(e):e,n=this.storageCache.get(t);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return Ce("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Em(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let t=jh.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,this.sessionCount===0&&(Ce("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},VD=(...e)=>new e1(...e)}),t1,ke,Qe=H(()=>{"use strict";t1=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},ke=e=>new t1(e)}),n1,vo,k,Ql,HD,UD,WD,pe=H(()=>{"use strict";n1=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},vo=class{static calcShape(e,t,n=!1){let r=e.length,i=t.length;if(r===0)return t;if(i===0)return e;let o=Math.max(e.length,t.length),s=new Array(o);if(n){if(r<2||i<2)return;let a=n1.calcMatMulShape([e[r-2],e[r-1]],[t[i-2],t[i-1]]);if(a===void 0)return;[s[o-2],s[o-1]]=a}for(let a=n?3:1;a<=o;a++){let u=r-a<0?1:e[r-a],c=i-a<0?1:t[i-a];if(u!==c&&u>1&&c>1)return;let d=Math.max(u,c);if(u&&c)s[o-a]=Math.max(u,c);else{if(d>1)return;s[o-a]=0}}return s}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let i=1;i<=n;i++)if(e[n-i]!==1&&e[n-i]!==t[r-i])return!1;return!0}},k=class Hl{static size(t){return Hl.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let r=t.length;if(r===0)return[];let i=new Array(r),o=r-1;for(;o>=0;){if(t[o]%n===0){i[o]=t[o]/n;break}if(n%t[o]!==0)throw new Error("cannot convert shape");i[o]=1,n/=t[o],o--}for(o--;o>=0;o--)i[o]=t[o];return i}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return Hl.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return Hl.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,r){let i=1;for(let o=n;o<r;o++){if(t[o]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=Number(t[o])}return i}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=t[n-1];for(let i=n-3;i>=0;--i)r[i]=r[i+1]*t[i+1];return r}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error("unsupported axis for this operation.");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(r=>this.normalizeAxis(r,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(r=>t[r]):t.slice().reverse()}static padShape(t,n){let r=t.length;return t.map((i,o)=>i+n[o]+n[o+r])}static areEqual(t,n){return t.length!==n.length?!1:t.every((r,i)=>r===n[i])}},Ql=class Ks{static adjustPoolAttributes(t,n,r,i,o,s){if(!t&&r.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let a=0;a<n.length-2;a++)a>=r.length?r.push(n[a+2]):r[a]=n[a+2];for(let a=0;a<r.length;a++)if(a<i.length){if(i[a]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let a=0;a<r.length;a++)if(a<o.length){if(o[a]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let a=0;a<r.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<r.length;a++){if(r[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=r[a]||s[a+r.length]>=r[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,i,o,s,a){if(a){if(o.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)Ks.adjustPadAndReturnShape(t[u+(s?1:2)],n[u],r[u],i[u],o,u,u+t.length-2,a)}}static computePoolOutputShape(t,n,r,i,o,s,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return Ks.computeShapeHelper(t,n,u,r,i,o,s,a),u}static computeConvOutputShape(t,n,r,i,o,s,a){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return Ks.computeShapeHelper(!1,t,u,r,i,o,s,a),u}static computeShapeHelper(t,n,r,i,o,s,a,u){if(t)for(let c=0;c<n.length-2;c++)r.push(1);else for(let c=0;c<n.length-2;c++)r.push(Ks.adjustPadAndReturnShape(n[c+2],i[c],o[c],s[c],a,c,c+n.length-2,u))}static adjustPadAndReturnShape(t,n,r,i,o,s,a,u){let c=r*(i-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return o[s]=0,o[a]=0,Math.floor((t-c)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(r!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let d=((t+n-1)/n-1)*n+i-t;return o[s]=Math.floor(u==="SAME_LOWER"?(d+1)/2:d/2),o[a]=d-o[s],Math.floor((t+d-i)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+o[s]+o[a]-c)/n+1)}},HD=class{static getShapeOfGemmResult(e,t,n,r,i){if(e.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let o,s,a;t?(o=e[1],s=e[0]):(o=e[0],s=e[1]);let u=-1;if(r?(a=n[0],u=1):(a=n[1],u=0),n[u]!==s)throw new Error("dimension mismatch");if(o<=0||a<=0||s<=0)throw new Error("invalid shape specified");if(i&&!vo.isValidBroadcast(i,[o,a]))throw new Error("gemm: invalid bias shape for broadcast");return[o,a,s]}},UD=-34028234663852886e22,WD=34028234663852886e22}),_o,Rl,rt,vt,J,We,Tm,yo,Ir,Y,Bs,O,Z,qD,Zm,r1,GD,_e=H(()=>{"use strict";se(),pe(),_o=64,Rl=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},rt=(e,t=1)=>{let n=Rl(e,t);return typeof n=="string"?n:n[0]},vt=(e,t=1)=>{let n=Rl(e,t);return typeof n=="string"?n:n[1]},J=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:k.computeStrides(n)})}),t},We=e=>e%4===0?4:e%2===0?2:1,Tm=(e="f32",t,n="0")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,yo=(e,t,n)=>e==="f32"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,Ir=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Y=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?typeof t=="string"?r==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:r==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Bs=(e,t,n,r,i)=>{let o=typeof n=="number",s=o?n:n.length,a=[...new Array(s).keys()],u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,c=Rl(t,i),d=typeof c=="string"?c:c[1],p=typeof c=="string"?c:c[0],h={indices:u,value:d,storage:p,tensor:t},g=z=>typeof z=="string"?z:`${z}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=o?"uniforms.":"",x=`${w}${e}_shape`,I=`${w}${e}_strides`,b="";for(let z=0;z<s-1;z++)b+=`
    let dim${z} = current / ${Y(I,z,s)};
    let rest${z} = current % ${Y(I,z,s)};
    indices[${z}] = dim${z};
    current = rest${z};
    `;b+=`indices[${s-1}] = current;`;let T=s<2?"":`
  fn o2i_${e}(offset: u32) -> ${h.indices} {
    var indices: ${h.indices};
    var current = offset;
    ${b}
    return indices;
  }`,C=z=>(y.offsetToIndices=!0,s<2?z:`o2i_${e}(${z})`),S=[];if(s>=2)for(let z=s-1;z>=0;z--)S.push(`${Y(I,z,s)} * (indices[${z}])`);let $=s<2?"":`
  fn i2o_${e}(indices: ${h.indices}) -> u32 {
    return ${S.join("+")};
  }`,M=z=>(y.indicesToOffset=!0,s<2?z:`i2o_${e}(${z})`),L=(...z)=>s===0?"0u":`${h.indices}(${z.map(g).join(",")})`,V=(z,W)=>s<2?`${z}`:`${Y(z,W,s)}`,G=(z,W,R)=>s<2?`${z}=${R};`:`${Y(z,W,s)}=${R};`,X={},oe=(z,W)=>{y.broadcastedIndicesToOffset=!0;let R=`${W.name}broadcastedIndicesTo${e}Offset`;if(R in X)return`${R}(${z})`;let te=[];for(let Ze=s-1;Ze>=0;Ze--){let kt=W.indicesGet("outputIndices",Ze+W.rank-s);te.push(`${V(I,Ze)} * (${kt} % ${V(x,Ze)})`)}return X[R]=`fn ${R}(outputIndices: ${W.type.indices}) -> u32 {
             return ${te.length>0?te.join("+"):"0u"};
           }`,`${R}(${z})`},B=(z,W)=>(()=>{if(h.storage===h.value)return`${e}[${z}]=${W};`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`${e}[${z}]=vec2<u32>(u32(${W}), select(0u, 0xFFFFFFFFu, ${W} < 0));`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`${e}[${z}]=vec2<u32>(u32(${W}), 0u);`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`${e}[${z}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${W}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),ye=z=>(()=>{if(h.storage===h.value)return`${e}[${z}]`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`i32(${e}[${z}].x)`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`u32(${e}[${z}].x)`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${z}] & 0xFFu), bool(${e}[${z}] & 0xFF00u), bool(${e}[${z}] & 0xFF0000u), bool(${e}[${z}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),xe=s<2?"":`
  fn get_${e}ByIndices(indices: ${h.indices}) -> ${d} {
    return ${ye(`i2o_${e}(indices)`)};
  }`,K=s<2?"":(()=>{let z=a.map(R=>`d${R}: u32`).join(", "),W=a.map(R=>`d${R}`).join(", ");return`
  fn get_${e}(${z}) -> ${d} {
    return get_${e}ByIndices(${L(W)});
  }`})(),we=(...z)=>{if(z.length!==s)throw new Error(`indices length must be ${s}`);let W=z.map(g).join(",");return s===0?ye("0u"):s===1?ye(W[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${W})`)},Ee=z=>s<2?ye(z):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${z})`),Q=s<2?"":`
  fn set_${e}ByIndices(indices: ${h.indices}, value: ${d}) {
    ${B(`i2o_${e}(indices)`,"value")}
  }`,Te=s<2?"":(()=>{let z=a.map(R=>`d${R}: u32`).join(", "),W=a.map(R=>`d${R}`).join(", ");return`
  fn set_${e}(${z}, value: ${d}) {
    set_${e}ByIndices(${L(W)}, value);
  }`})();return{impl:()=>{let z=[],W=!1;return y.offsetToIndices&&(z.push(T),W=!0),y.indicesToOffset&&(z.push($),W=!0),y.broadcastedIndicesToOffset&&(Object.values(X).forEach(R=>z.push(R)),W=!0),y.set&&(z.push(Te),W=!0),y.setByIndices&&(z.push(Q),W=!0),y.get&&(z.push(K),W=!0),y.getByIndices&&(z.push(xe),W=!0),!o&&W&&z.unshift(`const ${x} = ${h.indices}(${n.join(",")});`,`const ${I} = ${h.indices}(${k.computeStrides(n).join(",")});`),z.join(`
`)},type:h,offsetToIndices:C,indicesToOffset:M,broadcastedIndicesToOffset:oe,indices:L,indicesGet:V,indicesSet:G,set:(...z)=>{if(z.length!==s+1)throw new Error(`indices length must be ${s}`);let W=z[s];if(typeof W!="string")throw new Error("value must be string");let R=z.slice(0,s).map(g).join(",");return s===0?B("0u",W):s===1?B(R[0],W):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${R}, ${W})`)},setByOffset:B,setByIndices:(z,W)=>s<2?B(z,W):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${z}, ${W});`),get:we,getByOffset:ye,getByIndices:Ee,usage:r,name:e,strides:I,shape:x,rank:s}},O=(e,t,n,r=1)=>Bs(e,t,n,"input",r),Z=(e,t,n,r=1)=>Bs(e,t,n,"output",r),qD=(e,t,n)=>Bs(e,t,n,"atomicOutput",1),Zm=(e,t,n,r=1)=>Bs(e,t,n,"internal",r),r1=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=_o){let t=typeof e=="number"?e:e[0],n=typeof e=="number"?1:e[1],r=typeof e=="number"?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,o=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,s=i?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`;return`@compute @workgroup_size(${t}, ${n}, ${r})
  fn main(${o}) {
    ${s}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n=e.usage==="input"?"read":"read_write",r=e.usage==="atomicOutput"?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map(t=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)n==="f16"?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let i=r==null||r===1?n:`vec${r}<${n}>`;e.push(`${t}:${i}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=t=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(t)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},GD=(e,t)=>new r1(e,t)}),i1,Hh,o1,s1,a1,u1,zt,KD,QD,xr=H(()=>{"use strict";se(),pe(),Qe(),_e(),i1=(e,t)=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},Hh=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),o1=(e,t)=>k.sortBasedOnPerm(e,Hh(e.length,t)),s1=(e,t,n,r)=>{let i=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let o=0;o<t;++o)i+=`a[${e[o]}]=i[${o}];`;return i+="return a;}"},a1=(e,t)=>{let n=[],r=[];for(let i=0;i<e.length;++i)e[i]!==1&&n.push(e[i]),e[t[i]]!==1&&r.push(t[i]);return{newShape:n,newPerm:r}},u1=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(t[e[r]]!==1){if(e[r]<n)return!1;n=e[r]}return!0},zt=(e,t)=>{let n=e.dataType,r=e.dims.length,i=Hh(r,t),o=o1(e.dims,i),s=e.dims,a=o,u=r<2||u1(i,e.dims),c;if(u)return c=y=>{let w=O("input",n,s,4),x=Z("output",n,a,4);return`
  ${y.registerUniform("output_size","u32").declareVariables(w,x)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=k.size(o);return{outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64/4)},programUniforms:[{type:12,data:Math.ceil(y/4)}]}},getShaderSource:c};let{newShape:d,newPerm:p}=a1(e.dims,i),h=k.areEqual(p,[2,3,1]),g=k.areEqual(p,[3,1,2]);if(d.length===2||h||g){s=h?[d[0],d[1]*d[2]]:g?[d[0]*d[1],d[2]]:d,a=[s[1],s[0]];let y=16;return c=w=>{let x=O("a",n,s.length),I=Z("output",n,a.length);return`
  ${w.registerUniform("output_size","u32").declareVariables(x,I)}
  var<workgroup> tile : array<array<${I.type.value}, ${y+1}>, ${y}>;
  ${w.mainStart([y,y,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${y} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${y}u + local_id.x;
    let input_row = workgroup_id_x * ${y}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${x.getByIndices(`${x.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${y}u + local_id.x;
    let output_row = workgroup_id_y * ${y}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${I.setByIndices(`${I.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let w=k.size(o);return{outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(a[1]/y),y:Math.ceil(a[0]/y)},programUniforms:[{type:12,data:w},...J(s,a)]}},getShaderSource:c}}return c=y=>{let w=O("a",n,s.length),x=Z("output",n,a.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(w,x)}

  ${s1(i,r,w,x)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${x.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${x.setByOffset("global_idx",w.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let y=k.size(o);return{outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...J(s,a)]}},getShaderSource:c}},KD=(e,t)=>{i1(e.inputs,t.perm),e.compute(zt(e.inputs[0],t.perm))},QD=e=>ke({perm:e.perm})}),l1,c1,d1,f1,p1,h1,m1,g1,y1,v1,un,ZD,YD,JD,XD,eS,tS,nS,rS,iS,oS,jj=H(()=>{"use strict";se(),pe(),_e(),Ym(),xr(),l1={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},c1={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},d1={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},f1={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},p1=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},h1=(e,t)=>{let n=[],r=e.length;for(let o=0;o<r;o++)t.indexOf(o)===-1&&n.push(e[o]);let i=t.map(o=>e[o]);return[n,i]},m1=(e,t)=>{let n=e.length+t.length,r=[],i=0;for(let o=0;o<n;o++)t.indexOf(o)===-1?r.push(e[i++]):r.push(1);return r},g1=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},y1=(e,t)=>{let n=[];if(!g1(e,t)){for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);e.forEach(r=>n.push(r))}return n},v1=(e,t,n,r,i,o,s)=>{let a=n[0].dims,u=k.size(o),c=k.size(s),d=O("_A",n[0].dataType,a),p=Z("output",i,o),h=64;u===1&&(h=256);let g=`
          var<workgroup> aBestValues : array<f32, ${h}>;
       `,y=w=>`
        ${w.registerUniform("reduceSize","u32").declareVariables(d,p)}
        ${g}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${w.mainStart(h)}

          let outputIndex = global_idx / ${h};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${d1[r]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${h}) {
           let candidate = f32(${d.getByOffset("offset + k")});
           bestValue = ${l1[r]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${h}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${c1[r]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${p.setByOffset("outputIndex",`${r==="mean"?`${p.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${p.type.storage}(${f1[r]})`}`)};
         }
        }`;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:["type"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:o,dataType:i}],dispatchGroup:{x:u},programUniforms:[{type:12,data:c}]})}},un=(e,t,n,r)=>{let i=e.inputs.length===1?n:Cm(e.inputs,n),o=i.axes;o.length===0&&!i.noopWithEmptyAxes&&(o=e.inputs[0].dims.map((g,y)=>y));let s=k.normalizeAxes(o,e.inputs[0].dims.length),a=s,u=e.inputs[0],c=y1(a,e.inputs[0].dims.length);c.length>0&&(u=e.compute(zt(e.inputs[0],c),{inputs:[0],outputs:[-1]})[0],a=p1(a.length,u.dims.length));let[d,p]=h1(u.dims,a),h=d;i.keepDims&&(h=m1(d,s)),e.compute(v1(t,i.cacheKey,[u],r,e.inputs[0].dataType,h,p),{inputs:[u]})},ZD=(e,t)=>{un(e,"ReduceMeanShared",t,"mean")},YD=(e,t)=>{un(e,"ReduceL1Shared",t,"l1")},JD=(e,t)=>{un(e,"ReduceL2Shared",t,"l2")},XD=(e,t)=>{un(e,"ReduceLogSumExpShared",t,"logSumExp")},eS=(e,t)=>{un(e,"ReduceMaxShared",t,"max")},tS=(e,t)=>{un(e,"ReduceMinShared",t,"min")},nS=(e,t)=>{un(e,"ReduceProdShared",t,"prod")},rS=(e,t)=>{un(e,"ReduceSumShared",t,"sum")},iS=(e,t)=>{un(e,"ReduceSumSquareShared",t,"sumSquare")},oS=(e,t)=>{un(e,"ReduceLogSumShared",t,"logSum")}}),ln,_1,Zl,Cm,cn,w1,b1,I1,x1,E1,T1,C1,D1,S1,$1,dn,sS,aS,uS,lS,cS,dS,fS,pS,hS,mS,Ym=H(()=>{"use strict";se(),pe(),Qe(),_e(),jj(),ln=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},_1=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Zl=(e,t,n,r,i,o,s=!1,a=!1)=>{let u=[],c=n[0].dims,d=c.length,p=k.normalizeAxes(i,d),h=!a&&p.length===0;c.forEach((w,x)=>{h||p.indexOf(x)>=0?s&&u.push(1):u.push(w)});let g=u.length,y=k.size(u);return{name:e,shaderCache:t,getShaderSource:w=>{let x=[],I=O("_A",n[0].dataType,d),b=Z("output",o,g),T=r(I,b,p),C=T[2];for(let S=0,$=0;S<d;S++)h||p.indexOf(S)>=0?(s&&$++,C=`for(var j${S}: u32 = 0; j${S} < ${c[S]}; j${S}++) {
                  ${T[2].includes("last_index")?`let last_index = j${S};`:""}
                  ${I.indicesSet("input_indices",S,`j${S}`)}
                  ${C}
                }`):(x.push(`${I.indicesSet("input_indices",S,b.indicesGet("output_indices",$))};`),$++);return`

        ${w.registerUniform("output_size","u32").declareVariables(I,b)}

        ${w.mainStart()}
          ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${I.type.indices};
          let output_indices = ${b.offsetToIndices("global_idx")};

          ${x.join(`
`)}
          ${T[0]}       // init ops for reduce max/min
          ${T[1]}
          ${C}
          ${T[3]}
          ${T.length===4?b.setByOffset("global_idx","value"):T.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...J(c,u)]})}},Cm=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),ke({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},cn=(e,t,n,r)=>{let i=e.inputs,o=i.length===1?n:Cm(i,n);e.compute(Zl(t,{hint:o.cacheKey,inputDependencies:["rank"]},[i[0]],o.noopWithEmptyAxes&&o.axes.length===0?_1:r,o.axes,i[0].dataType,o.keepDims,o.noopWithEmptyAxes),{inputs:[0]})},w1=(e,t)=>{ln(e.inputs),cn(e,"ReduceLogSum",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},b1=(e,t)=>{ln(e.inputs),cn(e,"ReduceL1",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},I1=(e,t)=>{ln(e.inputs),cn(e,"ReduceL2",t,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},x1=(e,t)=>{ln(e.inputs),cn(e,"ReduceLogSumExp",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},E1=(e,t)=>{ln(e.inputs),cn(e,"ReduceMax",t,(n,r,i)=>{let o=[];for(let s=0;s<n.rank;s++)(i.indexOf(s)>=0||i.length===0)&&o.push(n.indicesSet("input_indices",s,0));return[`${o.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},T1=(e,t)=>{ln(e.inputs),cn(e,"ReduceMean",t,(n,r,i)=>{let o=1;for(let s=0;s<n.rank;s++)(i.indexOf(s)>=0||i.length===0)&&(o*=e.inputs[0].dims[s]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${r.type.value}(sum / ${o});`]})},C1=(e,t)=>{ln(e.inputs),cn(e,"ReduceMin",t,(n,r,i)=>{let o=[];for(let s=0;s<n.rank;s++)(i.indexOf(s)>=0||i.length===0)&&o.push(`input_indices[${s}] = 0;`);return[`${o.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},D1=(e,t)=>{ln(e.inputs),cn(e,"ReduceProd",t,(n,r)=>[`var value = ${r.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},S1=(e,t)=>{ln(e.inputs),cn(e,"ReduceSum",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},$1=(e,t)=>{ln(e.inputs),cn(e,"ReduceSumSquare",t,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},dn=(e,t,n)=>{if(t.length===0)return n;let r=1,i=1;for(let o=0;o<t.length;o++)t.indexOf(o)===-1?r*=e[o]:i*=e[o];return i<32&&r>1024},sS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?T1(e,t):ZD(e,t)},aS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?b1(e,t):YD(e,t)},uS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?I1(e,t):JD(e,t)},lS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?x1(e,t):XD(e,t)},cS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?E1(e,t):eS(e,t)},dS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?C1(e,t):tS(e,t)},fS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?D1(e,t):nS(e,t)},pS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?S1(e,t):rS(e,t)},hS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$1(e,t):iS(e,t)},mS=(e,t)=>{dn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?w1(e,t):oS(e,t)}}),Uh,gS,yS,Dm,Vj=H(()=>{"use strict";se(),Qe(),Ym(),Uh=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},gS=(e,t)=>{Uh(e.inputs);let n=(r,i,o)=>{let s=[];for(let a=0;a<r.rank;a++)(o.indexOf(a)>=0||o.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Zl("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},yS=(e,t)=>{Uh(e.inputs);let n=(r,i,o)=>{let s=[];for(let a=0;a<r.rank;a++)(o.indexOf(a)>=0||o.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Zl("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},Dm=e=>ke(e)}),M1,Ol,N1,k1,A1,Js,R1,vS,Jm=H(()=>{"use strict";se(),pe(),Qm(),_e(),M1=(e,t)=>{let n=e[0],r=e[1],i=e[2],o=e[3],s=e[4],a=e[5];if(s&&a)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let u=n.dims[0],c=n.dims[1],d=n.dims[2];if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let p=i.dims[0]/3,h=p,g=h;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let T of t.qkvHiddenSizes)if(T%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");p=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],g=t.qkvHiddenSizes[2]}let y=c;if(p!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==p+h+g)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let w=0;if(s){if(h!==g)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(s.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(s.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(s.dims[1]!==u)throw new Error('Input "past" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(s.dims[4]!==h/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(w=s.dims[3])}let x=y+w,I=-1,b=0;if(o)throw new Error("Mask not supported");if(s)throw new Error("past is not supported");if(a){if(a.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(a.dims[0]!==u||a.dims[1]!==t.numHeads||a.dims[2]!==c||a.dims[3]!==x)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:u,sequenceLength:c,pastSequenceLength:w,kvSequenceLength:y,totalSequenceLength:x,maxSequenceLength:I,inputHiddenSize:d,hiddenSize:p,vHiddenSize:g,headSize:Math.floor(p/t.numHeads),vHeadSize:Math.floor(g/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:b,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Ol=(e,t,n)=>t&&e?`
      let total_sequence_length_input = u32(${t.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,N1=(e,t,n,r,i,o,s,a)=>{let u=We(s?1:o),c=64,d=o/u;d<c&&(c=32);let p=Math.ceil(o/u/c),h=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:i},{type:12,data:d},{type:12,data:p}],g=rt(e.dataType,u),y=vt(1,u),w=["type"];s&&w.push("type"),a&&w.push("type");let x=I=>{let b=Z("x",e.dataType,e.dims,u),T=[b],C=s?O("seq_lens",s.dataType,s.dims):void 0;C&&T.push(C);let S=a?O("total_sequence_length_input",a.dataType,a.dims):void 0;S&&T.push(S);let $=vt(e.dataType),M=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${c}>;
  var<workgroup> thread_sum: array<f32, ${c}>;
  ${I.registerUniforms(M).declareVariables(...T)}
  ${I.mainStart([c,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Ol(C,S,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${c}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${s?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${y}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(u){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${u}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${c}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${y}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${y}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(u){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${u}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${c}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${b.type.value}(${$}(1.0) / ${$}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${y}(x[offset + i]);
        x[offset + i] = ${b.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${s?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${b.type.value}(${$}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${c};${g};${u}`,inputDependencies:w},getShaderSource:x,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(o/c),y:i,z:t*n},programUniforms:h})}},k1=(e,t,n,r,i,o,s,a,u)=>{let c=s+o.kvSequenceLength,d=[o.batchSize,o.numHeads,o.sequenceLength,c],p=e>1&&r,h=o.kvNumHeads?o.kvNumHeads:o.numHeads,g=p?[o.batchSize,h,c,o.headSize]:void 0,y=o.nReps?o.nReps:1,w=o.scale===0?1/Math.sqrt(o.headSize):o.scale,x=We(o.headSize),I=o.headSize/x,b=12,T={x:Math.ceil(c/b),y:Math.ceil(o.sequenceLength/b),z:o.batchSize*o.numHeads},C=[{type:12,data:o.sequenceLength},{type:12,data:I},{type:12,data:c},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:1,data:w},{type:12,data:s},{type:12,data:o.kvSequenceLength},{type:12,data:y}],S=p&&r&&k.size(r.dims)>0,$=["type","type"];S&&$.push("type"),i&&$.push("type"),a&&$.push("type"),u&&$.push("type");let M=[{dims:d,dataType:t.dataType,gpuDataType:0}];p&&M.push({dims:g,dataType:t.dataType,gpuDataType:0});let L=V=>{let G=O("q",t.dataType,t.dims,x),X=O("key",n.dataType,n.dims,x),oe=[G,X];if(S){let Q=O("past_key",r.dataType,r.dims,x);oe.push(Q)}i&&oe.push(O("attention_bias",i.dataType,i.dims));let B=a?O("seq_lens",a.dataType,a.dims):void 0;B&&oe.push(B);let ye=u?O("total_sequence_length_input",u.dataType,u.dims):void 0;ye&&oe.push(ye);let xe=Z("output",t.dataType,d),K=[xe];p&&K.push(Z("present_key",t.dataType,g,x));let we=vt(1,x),Ee=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${b}u;

  var<workgroup> tileQ: array<${G.type.storage}, ${b*b}>;
  var<workgroup> tileK: array<${G.type.storage}, ${b*b}>;
  ${V.registerUniforms(Ee).declareVariables(...oe,...K)}
  ${V.mainStart([b,b,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${y===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${y===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Ol(B,ye,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${S&&p?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${p?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${we}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${S&&p?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${p?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${we}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(x){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${x}`)}})()};
        output[outputIdx] = ${xe.type.value} (sum * uniforms.alpha) + ${i?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${x};${i!==void 0};${r!==void 0};${e}`,inputDependencies:$},getRunData:()=>({outputs:M,dispatchGroup:T,programUniforms:C}),getShaderSource:L}},A1=(e,t,n,r,i,o,s=void 0,a=void 0)=>{let u=o+i.kvSequenceLength,c=i.nReps?i.nReps:1,d=i.vHiddenSize*c,p=e>1&&r,h=i.kvNumHeads?i.kvNumHeads:i.numHeads,g=p?[i.batchSize,h,u,i.headSize]:void 0,y=[i.batchSize,i.sequenceLength,d],w=12,x={x:Math.ceil(i.vHeadSize/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},I=[{type:12,data:i.sequenceLength},{type:12,data:u},{type:12,data:i.vHeadSize},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:12,data:d},{type:12,data:o},{type:12,data:i.kvSequenceLength},{type:12,data:c}],b=p&&r&&k.size(r.dims)>0,T=["type","type"];b&&T.push("type"),s&&T.push("type"),a&&T.push("type");let C=[{dims:y,dataType:t.dataType,gpuDataType:0}];p&&C.push({dims:g,dataType:t.dataType,gpuDataType:0});let S=$=>{let M=O("probs",t.dataType,t.dims),L=O("v",n.dataType,n.dims),V=[M,L];b&&V.push(O("past_value",r.dataType,r.dims));let G=s?O("seq_lens",s.dataType,s.dims):void 0;s&&V.push(G);let X=a?O("total_sequence_length_input",a.dataType,a.dims):void 0;a&&V.push(X);let oe=[Z("output",t.dataType,y)];p&&oe.push(Z("present_value",t.dataType,g));let B=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${w}u;
  var<workgroup> tileQ: array<${M.type.value}, ${w*w}>;
  var<workgroup> tileV: array<${M.type.value}, ${w*w}>;
  ${$.registerUniforms(B).declareVariables(...V,...oe)}
  ${$.mainStart([w,w,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${c===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${c===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Ol(G,X,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${b&&p?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${p?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${M.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${b&&p?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${p?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${r!==void 0};${e}`,inputDependencies:T},getRunData:()=>({outputs:C,dispatchGroup:x,programUniforms:I}),getShaderSource:S}},Js=(e,t,n,r,i,o,s,a,u,c,d=void 0,p=void 0)=>{let h=Math.min(e.outputCount,1+(s?1:0)+(a?1:0)),g=h>1?c.pastSequenceLength:0,y=g+c.kvSequenceLength,w=u&&k.size(u.dims)>0?u:void 0,x=[t,n];h>1&&s&&k.size(s.dims)>0&&x.push(s),w&&x.push(w),d&&x.push(d),p&&x.push(p);let I=e.compute(k1(h,t,n,s,w,c,g,d,p),{inputs:x,outputs:h>1?[-1,1]:[-1]})[0];e.compute(N1(I,c.batchSize,c.numHeads,g,c.sequenceLength,y,d,p),{inputs:d&&p?[I,d,p]:[I],outputs:[]});let b=[I,r];h>1&&a&&k.size(a.dims)>0&&b.push(a),d&&b.push(d),p&&b.push(p),e.compute(A1(h,I,r,a,c,g,d,p),{inputs:b,outputs:h>1?[0,2]:[0]})},R1=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,i=t.inputHiddenSize,o=t.headSize,s=12,a={x:Math.ceil(t.headSize/s),y:Math.ceil(t.sequenceLength/s),z:t.batchSize*t.numHeads},u=[e.inputs[0],e.inputs[1],e.inputs[2]],c=[{type:12,data:r},{type:12,data:i},{type:12,data:o},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],d=p=>{let h=Z("output_q",u[0].dataType,n),g=Z("output_k",u[0].dataType,n),y=Z("output_v",u[0].dataType,n),w=O("input",u[0].dataType,u[0].dims),x=O("weight",u[1].dataType,u[1].dims),I=O("bias",u[2].dataType,u[2].dims),b=w.type.storage,T=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${s}u;
  var<workgroup> tileInput: array<${b}, ${s*s}>;
  var<workgroup> tileWeightQ: array<${b}, ${s*s}>;
  var<workgroup> tileWeightK: array<${b}, ${s*s}>;
  var<workgroup> tileWeightV: array<${b}, ${s*s}>;
  ${p.registerUniforms(T).declareVariables(w,x,I,h,g,y)}
  ${p.mainStart([s,s,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${b}(0);
    var valueK = ${b}(0);
    var valueV = ${b}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a,programUniforms:c}),getShaderSource:d},{inputs:u,outputs:[-1,-1,-1]})},vS=(e,t)=>{let n=M1(e.inputs,t),[r,i,o]=R1(e,n);return Js(e,r,i,o,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),O1,P1,L1,_S,Hj=H(()=>{"use strict";hn(),se(),pe(),Qe(),_e(),O1=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(r,i,o)=>{let s=i.length;if(s!==r.length)throw new Error(`${o}: num dimensions != ${s}`);i.forEach((a,u)=>{if(a!==r[u])throw new Error(`${o}: dim[${u}] do not match`)})};if(e[0].dims.length>1){let r=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},P1=(e,t)=>{let{epsilon:n,spatial:r,format:i}=t,o=e[0].dims,s=r?We(o[o.length-1]):1,a=i==="NHWC"&&o.length>1?s:1,u=k.size(o)/s,c=r,d=c?o.length:o,p=O("x",e[0].dataType,e[0].dims,s),h=O("scale",e[1].dataType,e[1].dims,a),g=O("bias",e[2].dataType,e[2].dims,a),y=O("inputMean",e[3].dataType,e[3].dims,a),w=O("inputVar",e[4].dataType,e[4].dims,a),x=Z("y",e[0].dataType,d,s),I=()=>{let T="";if(r)T=`let cOffset = ${o.length===1?"0u":i==="NHWC"?`outputIndices[${o.length-1}] / ${s}`:"outputIndices[1]"};`;else if(i==="NCHW")T=`
            ${x.indicesSet("outputIndices","0","0")}
            let cOffset = ${x.indicesToOffset("outputIndices")};`;else{T=`var cIndices = ${h.type.indices}(0);
                       cIndices[0] = outputIndices[${o.length-1}];`;for(let C=1;C<h.rank;C++)T+=`cIndices[${C}] = outputIndices[${C}];`;T+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return T},b=T=>`
  const epsilon = ${n};
  ${T.registerUniform("outputSize","u32").declareVariables(p,h,g,y,w,x)}
  ${T.mainStart()}
  ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${x.offsetToIndices(`global_idx * ${s}`)};
    ${I()}
    let scale = ${h.getByOffset("cOffset")};
    let bias = ${g.getByOffset("cOffset")};
    let inputMean = ${y.getByOffset("cOffset")};
    let inputVar = ${w.getByOffset("cOffset")};
    let x = ${p.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${x.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${s}`,inputDependencies:c?["rank","type","type","type","type"]:void 0},getShaderSource:b,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c?[{type:12,data:u},...J(o)]:[{type:12,data:u}]})}},L1=e=>ke(e),_S=(e,t)=>{let{inputs:n,outputCount:r}=e,i=L1({...t,outputCount:r});if(Le.webgpu.validateInputContent&&O1(n,i),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(P1(n,i))}}),F1,z1,wS,Uj=H(()=>{"use strict";pe(),_e(),F1=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},z1=e=>{let t=e[0].dims,n=e[0].dims[2],r=k.size(t)/4,i=e[0].dataType,o=O("input",i,t,4),s=O("bias",i,[n],4),a=O("residual",i,t,4),u=Z("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:c=>`
  const channels = ${n}u / 4;
  ${c.declareVariables(o,s,a,u)}

  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes(r)}
    let value = ${o.getByOffset("global_idx")}
      + ${s.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${u.setByOffset("global_idx","value")}
  }`}},wS=e=>{F1(e.inputs),e.compute(z1(e.inputs))}}),B1,De,bS,IS,xS,ES,TS,CS,DS,SS,$S,j1,MS,NS,kS,AS,Qs,RS,Ul,OS,PS,LS,FS,zS,BS,jS,VS,HS,US,WS,qS,GS,KS,QS,ZS,Wh,YS,Sm,$m,JS,XS,e$,V1,H1,t$,Xm=H(()=>{"use strict";se(),pe(),Qe(),_e(),B1=(e,t,n,r,i,o,s)=>{let a=Math.ceil(t/4),u="";typeof i=="string"?u=`${i}(a)`:u=i("a");let c=O("inputData",n,[a],4),d=Z("outputData",r,[a],4),p=[{name:"vec_size",type:"u32"}];return s&&p.push(...s),`
      ${e.registerUniforms(p).declareVariables(c,d)}

  ${o??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${c.getByOffset("global_idx")};
    ${d.setByOffset("global_idx",u)}
  }`},De=(e,t,n,r,i,o=e.dataType,s,a)=>{let u=[{type:12,data:Math.ceil(k.size(e.dims)/4)}];return s&&u.push(...s),{name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:c=>B1(c,k.size(e.dims),e.dataType,o,n,r,a),getRunData:c=>({outputs:[{dims:e.dims,dataType:o}],dispatchGroup:{x:Math.ceil(k.size(c[0].dims)/64/4)},programUniforms:u})}},bS=e=>{e.compute(De(e.inputs[0],"Abs","abs"))},IS=e=>{e.compute(De(e.inputs[0],"Acos","acos"))},xS=e=>{e.compute(De(e.inputs[0],"Acosh","acosh"))},ES=e=>{e.compute(De(e.inputs[0],"Asin","asin"))},TS=e=>{e.compute(De(e.inputs[0],"Asinh","asinh"))},CS=e=>{e.compute(De(e.inputs[0],"Atan","atan"))},DS=e=>{e.compute(De(e.inputs[0],"Atanh","atanh"))},SS=e=>ke(e),$S=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(De(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},j1=e=>{let t,n,r=e.length>=2&&e[1].data!==0,i=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=i?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=i?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return ke({min:t,max:n})},MS=(e,t)=>{let n=t||j1(e.inputs),r=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"Clip",i=>`clamp(${i}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},NS=e=>{e.compute(De(e.inputs[0],"Ceil","ceil"))},kS=e=>{e.compute(De(e.inputs[0],"Cos","cos"))},AS=e=>{e.compute(De(e.inputs[0],"Cosh","cosh"))},Qs=e=>ke(e),RS=(e,t)=>{let n=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_ = ${n}(${t.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},Ul=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,OS=e=>{let t=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"Erf",n=>`erf_vf32(${n})`,Ul(t)))},PS=e=>{e.compute(De(e.inputs[0],"Exp","exp"))},LS=e=>{e.compute(De(e.inputs[0],"Floor","floor"))},FS=e=>{let t=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Ul(t)))},zS=(e,t)=>{let n=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},BS=e=>{e.compute(De(e.inputs[0],"Not",t=>`!${t}`))},jS=e=>{e.compute(De(e.inputs[0],"Neg",t=>`-${t}`))},VS=e=>{e.compute(De(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},HS=e=>{let t=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"Relu",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},US=e=>{e.compute(De(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},WS=e=>ke(e),qS=(e,t)=>{let n=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"HardSigmoid",r=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${r} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},GS=e=>{e.compute(De(e.inputs[0],"Sin","sin"))},KS=e=>{e.compute(De(e.inputs[0],"Sinh","sinh"))},QS=e=>{e.compute(De(e.inputs[0],"Sqrt","sqrt"))},ZS=e=>{e.compute(De(e.inputs[0],"Tan","tan"))},Wh=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,YS=e=>{e.compute(De(e.inputs[0],"Tanh",Wh))},Sm=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${Wh("v")};
}
`,$m=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,JS=e=>{let t=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"FastGelu",$m,Sm(t),void 0,e.inputs[0].dataType))},XS=(e,t)=>{let n=vt(e.inputs[0].dataType);return e.compute(De(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},e$=e=>{e.compute(De(e.inputs[0],"Log","log"))},V1=(e,t)=>`
const alpha = vec4<${e}>(${t});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,H1=e=>`quick_gelu_impl(${e})`,t$=(e,t)=>{let n=vt(e.inputs[0].dataType);e.compute(De(e.inputs[0],"QuickGelu",H1,V1(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),U1,W1,n$,Wj=H(()=>{"use strict";pe(),_e(),Xm(),U1=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},W1=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=O("input",e[0].dataType,e[0].dims,4),r=O("bias",e[0].dataType,[e[0].dims[2]],4),i=Z("output",e[0].dataType,t,4),o=k.size(t)/4,s=rt(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${a.declareVariables(n,r,i)}

  ${Ul(s)}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${i.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},n$=e=>{U1(e.inputs),e.compute(W1(e.inputs))}}),q1,G1,fn,r$,i$,o$,s$,a$,u$,l$,c$,d$,f$,qj=H(()=>{"use strict";se(),pe(),_e(),q1=(e,t,n,r,i,o,s,a,u,c,d,p)=>{let h,g;typeof a=="string"?h=g=(b,T)=>`${a}((${b}),(${T}))`:typeof a=="function"?h=g=a:(h=a.scalar,g=a.vector);let y=Z("outputData",d,r.length,4),w=O("aData",u,t.length,4),x=O("bData",c,n.length,4),I;if(i)if(o){let b=k.size(t)===1,T=k.size(n)===1,C=t.length>0&&t[t.length-1]%4===0,S=n.length>0&&n[n.length-1]%4===0;b||T?I=y.setByOffset("global_idx",g(b?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"),T?`${x.type.value}(${x.getByOffset("0")}.x)`:x.getByOffset("global_idx"))):I=`
            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};
            let offsetA = ${w.broadcastedIndicesToOffset("outputIndices",y)};
            let offsetB = ${x.broadcastedIndicesToOffset("outputIndices",y)};
            ${y.setByOffset("global_idx",g(s||C?w.getByOffset("offsetA / 4u"):`${w.type.value}(${w.getByOffset("offsetA / 4u")}[offsetA % 4u])`,s||S?x.getByOffset("offsetB / 4u"):`${x.type.value}(${x.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else I=y.setByOffset("global_idx",g(w.getByOffset("global_idx"),x.getByOffset("global_idx")));else{if(!o)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let b=(T,C,S="")=>{let $=`aData[indexA${C}][componentA${C}]`,M=`bData[indexB${C}][componentB${C}]`;return`
            let outputIndices${C} = ${y.offsetToIndices(`global_idx * 4u + ${C}u`)};
            let offsetA${C} = ${w.broadcastedIndicesToOffset(`outputIndices${C}`,y)};
            let offsetB${C} = ${x.broadcastedIndicesToOffset(`outputIndices${C}`,y)};
            let indexA${C} = offsetA${C} / 4u;
            let indexB${C} = offsetB${C} / 4u;
            let componentA${C} = offsetA${C} % 4u;
            let componentB${C} = offsetB${C} % 4u;
            ${T}[${C}] = ${S}(${h($,M)});
          `};d===9?I=`
            var data = vec4<u32>(0);
            ${b("data",0,"u32")}
            ${b("data",1,"u32")}
            ${b("data",2,"u32")}
            ${b("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:I=`
            ${b("outputData[global_idx]",0)}
            ${b("outputData[global_idx]",1)}
            ${b("outputData[global_idx]",2)}
            ${b("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(w,x,y)}

        ${p??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${I}
      }`},G1=(e,t,n,r,i,o,s=n.dataType)=>{let a=n.dims.map(w=>Number(w)??1),u=r.dims.map(w=>Number(w)??1),c=!k.areEqual(a,u),d=a,p=k.size(a),h=!1,g=!1,y=[c];if(c){let w=vo.calcShape(a,u,!1);if(!w)throw new Error("Can't perform binary op on the given tensors");d=w.slice(),p=k.size(d);let x=k.size(a)===1,I=k.size(u)===1,b=a.length>0&&a[a.length-1]%4===0,T=u.length>0&&u[u.length-1]%4===0;y.push(x),y.push(I),y.push(b),y.push(T);let C=1;for(let S=1;S<d.length;S++){let $=a[a.length-S],M=u[u.length-S];if($===M)C*=$;else break}C%4===0?(g=!0,h=!0):(x||I||b||T)&&(h=!0)}else h=!0;return y.push(h),{name:e,shaderCache:{hint:t+y.map(w=>w.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:w=>q1(w,a,u,d,h,c,g,i,n.dataType,r.dataType,s,o),getRunData:()=>({outputs:[{dims:d,dataType:s}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:Math.ceil(k.size(d)/4)},...J(a,u,d)]})}},fn=(e,t,n,r,i,o)=>{e.compute(G1(t,i??"",e.inputs[0],e.inputs[1],n,r,o))},r$=e=>{fn(e,"Add",(t,n)=>`${t}+${n}`)},i$=e=>{fn(e,"Div",(t,n)=>`${t}/${n}`)},o$=e=>{fn(e,"Equal",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},s$=e=>{fn(e,"Mul",(t,n)=>`${t}*${n}`)},a$=e=>{let t=O("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;fn(e,"Pow",{scalar:(n,r)=>`pow_custom(${n},${r})`,vector:(n,r)=>`pow_vector_custom(${n},${r})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},u$=e=>{fn(e,"Sub",(t,n)=>`${t}-${n}`)},l$=e=>{fn(e,"Greater",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},c$=e=>{fn(e,"Less",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},d$=e=>{fn(e,"GreaterOrEqual",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},f$=e=>{fn(e,"LessOrEqual",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}}),K1,Q1,Z1,Y1,p$,h$,Gj=H(()=>{"use strict";se(),pe(),Qe(),_e(),K1=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=0,r=e[n],i=r.dataType,o=r.dims.length;e.forEach((s,a)=>{if(a!==n){if(s.dataType!==i)throw new Error("input tensors should be one type");if(s.dims.length!==o)throw new Error("input tensors should have the same shape");s.dims.forEach((u,c)=>{if(c!==t&&u!==r.dims[c])throw new Error("non concat dimensions must match")})}})},Q1=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,Z1=(e,t)=>{let n=e.length,r=[];for(let i=0;i<n;++i){let o=t.setByOffset("global_idx",e[i].getByIndices("indices"));n===1?r.push(o):i===0?r.push(`if (inputIndex == ${i}u) { ${o} }`):i===n-1?r.push(`else { ${o} }`):r.push(`else if (inputIndex == ${i}) { ${o} }`)}return r.join(`
`)},Y1=(e,t,n,r)=>{let i=k.size(n),o=new Array(e.length),s=new Array(e.length),a=0,u=[],c=[],d=[{type:12,data:i}];for(let w=0;w<e.length;++w)a+=e[w].dims[t],o[w]=a,c.push(e[w].dims.length),s[w]=O(`input${w}`,r,c[w]),u.push("rank"),d.push({type:12,data:o[w]});for(let w=0;w<e.length;++w)d.push(...J(e[w].dims));d.push(...J(n));let p=Z("output",r,n.length),h=p.indicesGet("indices",t),g=Array.from(Array(o.length).keys()).map(w=>`uniforms.sizeInConcatAxis${w}`).join(","),y=w=>`

  ${(()=>{w.registerUniform("outputSize","u32");for(let x=0;x<e.length;x++)w.registerUniform(`sizeInConcatAxis${x}`,"u32");return w.declareVariables(...s,p)})()}

  ${Q1(o.length,g)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${p.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${h});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${o.length}u>(${g});
      ${h} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Z1(s,p)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d}),getShaderSource:y}},p$=(e,t)=>{let n=e.inputs,r=n[0].dims,i=k.normalizeAxis(t.axis,r.length);K1(n,i);let o=r.slice();o[i]=n.reduce((a,u)=>a+(u.dims.length>i?u.dims[i]:0),0);let s=n.filter(a=>k.size(a.dims)>0);e.compute(Y1(s,i,o,n[0].dataType),{inputs:s})},h$=e=>ke({axis:e.axis})}),ai,ui,li,eg,di=H(()=>{"use strict";se(),pe(),ai=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},ui=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},li=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},eg=e=>{let t=e?.activation||"";if(t==="HardSigmoid"){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}else if(t==="Clip"){let[n,r]=e?.activation_params||[UD,WD];return{activation:t,clipMax:r,clipMin:n}}else if(t==="LeakyRelu"){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}}),st,m$,tg=H(()=>{"use strict";st=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},m$=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),g$,Kj=H(()=>{"use strict";g$=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),Ys,ng,rg=H(()=>{"use strict";se(),pe(),_e(),di(),Ys=(e,t,n,r,i)=>{let o=r-n;return`
      ${Array.from({length:n}).map((s,a)=>`
      if (${Y(t.shape,a,t.rank)} != 1) {
        ${t.indicesSet(e,a,Y(i,a+o,r))}
      } else {
        ${t.indicesSet(e,a,0)}
      }`).join("")}
`},ng=(e,t,n,r,i=!1,o)=>{let s=e[0].dims,a=e[1].dims,u=s[s.length-2],c=a[a.length-1],d=s[s.length-1],p=We(c),h=We(d),g=We(u),y=k.size(n)/p/g,w=e.length>2,x=r?r.slice(0,-2):n.slice(0,-2),I=[k.size(x),u,c],b=[{type:12,data:y},{type:12,data:u},{type:12,data:c},{type:12,data:d}];ui(t,b),b.push(...J(x,s,a)),w&&b.push(...J(e[2].dims)),b.push(...J(I));let T=C=>{let S=Zm("batch_dims",e[0].dataType,x.length),$=O("a",e[0].dataType,s.length,h),M=O("b",e[1].dataType,a.length,p),L=Z("output",e[0].dataType,I.length,p),V=rt(L.type.tensor),G=ai(t,L.type.value,V),X=[$,M],oe="";if(w){let xe=i?p:1;X.push(O("bias",e[2].dataType,e[2].dims.length,xe)),oe=`${i?`value += bias[col / ${xe}];`:`value += ${L.type.value}(bias[row + i]);`}`}let B=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];li(t,B);let ye=()=>{let xe=`var a_data: ${$.type.value};`;for(let K=0;K<h;K++)xe+=`
              let b_data${K} = b[(b_offset + (k + ${K}) * uniforms.N + col) / ${p}];`;for(let K=0;K<g;K++){xe+=`a_data = a[(a_offset + (row + ${K}) * uniforms.K + k) / ${h}];`;for(let we=0;we<h;we++)xe+=`
            values[${K}] = fma(${M.type.value}(a_data${h===1?"":`[${we}]`}), b_data${we}, values[${K}]);
`}return xe};return`
  ${C.registerUniforms(B).registerInternalVariables(S).declareVariables(...X,L)}
  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${p})) * ${p};
    var index1 = global_idx / (uniforms.N / ${p});
    let stride1 = uniforms.M / ${g};
    let row = (index1 % stride1) * ${g};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${S.offsetToIndices("batch")};`}

    var a_indices: ${$.type.indices};
    ${Ys("a_indices",$,$.rank-2,S.rank,"batch_indices")}
    ${$.indicesSet("a_indices",$.rank-2,0)}
    ${$.indicesSet("a_indices",$.rank-1,0)}
    let a_offset = ${$.indicesToOffset("a_indices")};

    var b_indices: ${M.type.indices};
    ${Ys("b_indices",M,M.rank-2,S.rank,"batch_indices")}
    ${M.indicesSet("b_indices",M.rank-2,0)}
    ${M.indicesSet("b_indices",M.rank-1,0)}
    let b_offset = ${M.indicesToOffset("b_indices")};
    var values: array<${L.type.value}, ${g}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {
      ${ye()}
    }
    for (var i = 0u; i < ${g}u; i++) {
      var value = values[i];
      ${oe}
      ${G}
      let cur_indices = ${L.type.indices}(batch, row + i, col);
      let offset = ${L.indicesToOffset("cur_indices")};
      ${L.setByOffset(`offset / ${p}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${p};${h};${g};${i}`,inputDependencies:w?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o?o(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:b}),getShaderSource:T}}}),J1,X1,Mm,qh,eT,Nm,tT,Yl,ig=H(()=>{"use strict";se(),pe(),_e(),di(),rg(),tg(),J1=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,X1=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Mm=(e,t,n="f32",r,i=!1,o=32,s=!1,a=32)=>{let u=t[1]*e[1],c=t[0]*e[0],d=i?u:o,p=i?o:u,h=d/t[0],g=o/t[1];if(!((i&&h===4&&e[1]===4||!i&&(h===3||h===4))&&d%t[0]===0&&o%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${h} must be 3 or 4.
  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${o} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${h}<${n}>, ${d/h}>, ${p}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${c/e[0]}>, ${o}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${h};
const tileInner = ${o};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${s?"0":"i32(globalId.z)"};
  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${u};

  let num_tiles = ${s?`${Math.ceil(a/o)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${g};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${J1(i,r)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${h===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${X1(i,h)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},qh=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,eT=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Nm=(e,t,n="f32",r,i=!1,o=32,s=!1,a=32,u=!1)=>{let c=e[1]*t[1],d=e[0]*t[0],p=i?c:o,h=i?o:c;if(!(h%t[1]===0&&p%t[0]===0&&o%t[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${t[0]}, tileInner ${o} must be divisible by workgroupSize[1]${t[1]}`);let g=h/t[1],y=p/t[0],w=o/t[1],x=u?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${c};
    let globalColStart = i32(workgroupId.x) * ${d};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${t[0]}) {
          ${qh(i,r)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${r?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${c};

let tileRowA = i32(localId.y) * ${g};
let tileColA = i32(localId.x) * ${y};
let tileRowB = i32(localId.y) * ${w};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${qh(i,r)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${r?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${eT(i)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${p}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${o}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${o};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${s?"0":"i32(globalId.z)"};
    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${s?`${Math.ceil(a/o)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${x}
  }
`},tT=(e,t,n,r,i=!1)=>{let[o,s,a,u]=r,c=rt(r[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${o.type.indices}) -> ${st(e,c)} {
      var value = ${st(e,c)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${s.type.indices};
        ${Ys("aIndices",s,s.rank-2,o.rank,"batchIndices")}
        ${s.indicesSet("aIndices",s.rank-2,"u32(row)")}
        ${s.indicesSet("aIndices",s.rank-1,"u32(colIn)")}
        value = ${s.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${o.type.indices}) -> ${st(e,c)} {
      var value = ${st(e,c)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${a.type.indices};
        ${Ys("bIndices",a,a.rank-2,o.rank,"batchIndices")}
        ${a.indicesSet("bIndices",a.rank-2,"u32(row)")}
        ${a.indicesSet("bIndices",a.rank-1,"u32(colIn)")}
        value = ${a.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${st(e,c)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${i?"bias[colIn]":`${st(e,c)}(bias[row])`};`:""}
        ${n}
        ${u.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Yl=(e,t,n,r,i=!1,o)=>{let s=e[0].dims,a=e[1].dims,u=s.slice(0,-2),c=a.slice(0,-2),d=r?r.slice(0,-2):n.slice(0,-2),p=k.size(d),h=s[s.length-2],g=s[s.length-1],y=a[a.length-1],w=g%4===0&&y%4===0,x=h<=8?[4,1,1]:[4,4,1],I=[8,8,1],b=[Math.ceil(y/I[0]/x[0]),Math.ceil(h/I[1]/x[1]),Math.ceil(p/I[2]/x[2])],T=w?4:1,C=[...u,h,g/T],S=C.length,$=[...c,g,y/T],M=$.length,L=[p,h,y/T],V=[{type:6,data:h},{type:6,data:y},{type:6,data:g}];ui(t,V),V.push(...J(d,C,$));let G=["rank","rank"],X=e.length>2;X&&(V.push(...J(e[2].dims)),G.push("rank")),V.push(...J(L));let oe=B=>{let ye=d.length,xe=Zm("batchDims",e[0].dataType,ye,1),K=rt(e[0].dataType),we=O("a",e[0].dataType,S,T),Ee=O("b",e[1].dataType,M,T),Q=Z("result",e[0].dataType,L.length,T),Te=[we,Ee];if(X){let Ze=i?T:1;Te.push(O("bias",e[2].dataType,e[2].dims.length,Ze))}let z=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];li(t,z);let W=rt(Q.type.tensor),R=ai(t,Q.type.value,W),te=tT(T,X,R,[xe,we,Ee,Q],i);return`
  ${B.registerUniforms(z).registerInternalVariables(xe).declareVariables(...Te,Q)}
  ${te}
  ${w?Mm(x,I,K,xe):Nm(x,I,K,xe)}
                   `};return{name:"MatMul",shaderCache:{hint:`${x};${t.activation};${w};${i}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:o?o(n):n,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:V}),getShaderSource:oe}}}),nT,y$,Qj=H(()=>{"use strict";se(),Zn(),_e(),di(),tg(),Kj(),ig(),nT=(e,t,n,r,i=!1,o,s=4,a=4,u=4,c="f32")=>{let d=V=>{switch(V){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${c}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${V} is not supported.`)}},p=V=>{switch(V){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${V} is not supported.`)}},h=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,g=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,y=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",w=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",x=e?"row":"col",I=e?"col":"row",b=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${x} / outWidth;
    let outCol = ${x} % outWidth;

    let WRow = ${I} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${I} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${I} % inChannels;
    var resData = ${st(s,c)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${w}) {
      ${h}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${d(s)}
    }
    return resData;`,T=e?t&&r?`
    let col = colIn * ${s};
    ${b}`:`
    let col = colIn * ${s};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${b}
    }
    return ${st(s,c)}(0.0);`:r&&n?`
    let col = colIn * ${s};
    ${b}`:`
    let col = colIn * ${s};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${b}
    }
    return ${st(s,c)}(0.0);`,C=e?r&&n?p(a):`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${p(a)}
    }
    return ${st(a,c)}(0.0);`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${p(a)}
    }
    return ${st(a,c)}(0.0);`,S=st(u,c),$=st(e?s:a,c),M=st(e?a:s,c),L=ai(o,S,c);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$} {
      ${e?T:C}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${M} {
      ${e?C:T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${S}) {
      let col = colIn * ${u};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${g}
      ${m$(i)}
      ${L}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},y$=(e,t,n,r,i,o,s,a,u)=>{let c=t.format==="NHWC",d=c?e[0].dims[3]:e[0].dims[1],p=n[0],h=c?n[2]:n[3],g=c?n[1]:n[2],y=c?n[3]:n[1],w=c&&(d%4===0||d%3===0)&&y%4===0,x=c?y:h*g,I=c?h*g:y,b=[8,8,1],T=r<=8?[4,1,1]:[4,4,1],C=[Math.ceil(x/b[0]/T[0]),Math.ceil(I/b[1]/T[1]),Math.ceil(p/b[2]/T[2])];Ce("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let S=w?c&&d%4!==0?3:4:1,$=b[1]*T[1],M=b[0]*T[0],L=Math.max(b[0]*S,b[1]),V=r%$===0,G=i%M===0,X=o%L===0,oe=w?[S,4,4]:[1,1,1],B=[{type:6,data:r},{type:6,data:i},{type:6,data:o},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];ui(t,B),B.push(...J(e[0].dims,e[1].dims));let ye=["rank","rank"];s&&(B.push(...J(e[2].dims)),ye.push("rank")),B.push(...J(n));let xe=K=>{let we=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];li(t,we);let Ee=w?4:1,Q=rt(e[0].dataType),Te=`
      fn setOutputAtIndex(flatIndex : i32, value : ${w?`vec4<${Q}>`:Q}) {
        result[flatIndex] = ${w?`vec4<${Q}>`:Q}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w?`vec4<${Q}>`:Q}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${w?"/ 4":""}, value);
      }`,z=O("x",e[0].dataType,e[0].dims.length,S===3?1:S),W=O("w",e[1].dataType,e[1].dims.length,Ee),R=[z,W],te=Z("result",e[0].dataType,n.length,Ee);if(s){let Ze=O("bias",e[2].dataType,e[2].dims.length,Ee);R.push(Ze),Te+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?`vec4<${Q}>`:Q} {
          return bias[coords.${c?"w":"y"}${w?"/ 4":""}];
        }`}return`
        ${g$("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${K.registerUniforms(we).declareVariables(...R,te)}
        ${Te}
        ${nT(c,V,G,X,s,t,oe[0],oe[1],oe[2],Q)}
        ${w?Mm(T,b,Q,void 0,!c,L):Nm(T,b,Q,void 0,!c,L,!1,void 0,a)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${S};${w};${V};${G};${X};${$};${M};${L}`,inputDependencies:ye},getRunData:()=>({outputs:[{dims:u?u(n):n,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:B}),getShaderSource:xe}}}),rT,Gh,js,iT,Kh,oT,v$,_$,Zj=H(()=>{"use strict";se(),Zn(),pe(),_e(),di(),tg(),rT=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Gh=e=>typeof e=="number"?[e,e,e]:e,js=(e,t)=>t<=1?e:e+(e-1)*(t-1),iT=(e,t,n,r=1)=>{let i=js(t,r);return Math.floor((e[0]*(n-1)-n+i)/2)},Kh=(e,t,n,r,i)=>{i==null&&(i=iT(e,t[0],r[0]));let o=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*i>=t[s]&&(o[s]=Math.trunc((e[s]-t[s]+2*i)/r[s]+1));return o},oT=(e,t,n,r,i,o,s,a,u,c)=>{let d,p,h,g;if(e==="VALID"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e};let y=Kh([t,n,r,1],[a,u,c],1,[i,o,s],e);p=y[0],h=y[1],g=y[2]}else if(Array.isArray(e)){if(!e.every((w,x,I)=>w===I[0]))throw Error(`Unsupported padding parameter: ${e}`);d={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let y=Kh([t,n,r,1],[a,u,c],1,[i,o,s],e[0]);p=y[0],h=y[1],g=y[2]}else if(e==="SAME_UPPER"){p=Math.ceil(t/i),h=Math.ceil(n/o),g=Math.ceil(r/s);let y=(p-1)*i+a-t,w=(h-1)*o+u-n,x=(g-1)*s+c-r,I=Math.floor(y/2),b=y-I,T=Math.floor(w/2),C=w-T,S=Math.floor(x/2),$=x-S;d={top:T,bottom:C,left:S,right:$,front:I,back:b}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:p,outHeight:h,outWidth:g}},v$=(e,t,n,r,i,o=!1,s="channelsLast")=>{let a,u,c,d,p;if(s==="channelsLast")[a,u,c,d,p]=e;else if(s==="channelsFirst")[a,p,u,c,d]=e;else throw new Error(`Unknown dataFormat ${s}`);let[h,,g,y,w]=t,[x,I,b]=Gh(n),[T,C,S]=Gh(r),$=js(g,T),M=js(y,C),L=js(w,S),{padInfo:V,outDepth:G,outHeight:X,outWidth:oe}=oT(i,u,c,d,x,I,b,$,M,L),B=o?h*p:h,ye=[0,0,0,0,0];return s==="channelsFirst"?ye=[a,B,G,X,oe]:s==="channelsLast"&&(ye=[a,G,X,oe,B]),{batchSize:a,dataFormat:s,inDepth:u,inHeight:c,inWidth:d,inChannels:p,outDepth:G,outHeight:X,outWidth:oe,outChannels:B,padInfo:V,strideDepth:x,strideHeight:I,strideWidth:b,filterDepth:g,filterHeight:y,filterWidth:w,effectiveFilterDepth:$,effectiveFilterHeight:M,effectiveFilterWidth:L,dilationDepth:T,dilationHeight:C,dilationWidth:S,inShape:e,outShape:ye,filterShape:t}},_$=(e,t,n,r,i,o)=>{let s=o==="channelsLast",a=s?e[0].dims[3]:e[0].dims[1],u=!1,c=[64,1,1],d={x:n.map((b,T)=>T)},p=[Math.ceil(rT(d.x.map(b=>n[b]))/c[0]),1,1];Ce("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${p}`);let h=u?s&&a%4!==0?3:4:1,g=k.size(n),y=[{type:12,data:g},{type:12,data:r},{type:12,data:i},{type:12,data:t.strides},{type:12,data:t.dilations}];ui(t,y),y.push(...J(e[0].dims,e[1].dims));let w=["rank","rank"],x=e.length===3;x&&(y.push(...J(e[2].dims)),w.push("rank")),y.push(...J(n));let I=b=>{let T=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:i.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];li(t,T);let C=u?4:1,S=rt(e[0].dataType),$=O("x",e[0].dataType,e[0].dims.length,h===3?1:h),M=O("W",e[1].dataType,e[1].dims.length,C),L=[$,M],V=Z("result",e[0].dataType,n.length,C),G="";if(x){let B=O("bias",e[2].dataType,e[2].dims.length,C);L.push(B),G+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${u?`vec4<${S}>`:S} {
          return bias[${s?Y("coords",4,5):Y("coords",1,5)}${u?"/ 4":""}];
        }`}let X=st(h,S),oe=ai(t,X,S);return`
            ${G}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${$.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${M.getByIndices("aIndices")};
            }
          ${b.registerUniforms(T).declareVariables(...L,V)}
          ${b.mainStart()}
          ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${V.offsetToIndices("global_idx")};
              let batch = ${Y("coords",0,$.rank)};
              let d2 = ${s?Y("coords",$.rank-1,$.rank):Y("coords",1,$.rank)};
              let xFRCCorner = vec3<u32>(${s?Y("coords",1,$.rank):Y("coords",2,$.rank)},
              ${s?Y("coords",2,$.rank):Y("coords",3,$.rank)},
              ${s?Y("coords",3,$.rank):Y("coords",4,$.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${s?Y("uniforms.x_shape",1,$.rank):Y("uniforms.x_shape",2,$.rank)};
              let xShapeZ = ${s?Y("uniforms.x_shape",2,$.rank):Y("uniforms.x_shape",3,$.rank)};
              let xShapeW = ${s?Y("uniforms.x_shape",3,$.rank):Y("uniforms.x_shape",4,$.rank)};
              let xShapeU = ${s?Y("uniforms.x_shape",4,$.rank):Y("uniforms.x_shape",1,$.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${s?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${s?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${s?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${s?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${x?"value = value + getBiasByOutputCoords(coords)":""};
              ${oe}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${s};${h};${x}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:p[0],y:p[1],z:p[2]},programUniforms:y}),getShaderSource:I}}}),w$,b$,Yj=H(()=>{"use strict";se(),pe(),_e(),di(),w$=(e,t,n,r)=>{let i=e.length>2,o=i?"value += b[output_channel];":"",s=e[0].dims,a=e[1].dims,u=t.format==="NHWC",c=u?n[3]:n[1],d=c/t.group,p=u&&d>=4?We(c):1,h=k.size(n)/p,g=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:d}];ui(t,g),g.push(...J(s,[a[0],a[1],a[2],a[3]/p]));let y=i?["rank","rank","rank"]:["rank","rank"];g.push(...J([n[0],n[1],n[2],n[3]/p]));let w=x=>{let I=Z("output",e[0].dataType,n.length,p),b=rt(I.type.tensor),T=ai(t,I.type.value,b),C=O("x",e[0].dataType,s.length),S=O("w",e[1].dataType,a.length,p),$=[C,S];i&&$.push(O("b",e[2].dataType,e[2].dims,p));let M=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];li(t,M);let L=u?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${C.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${S.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${C.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${x.registerUniforms(M).declareVariables(...$,I)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${I.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${u?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${p} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${u?2:1}];

    var value: ${I.type.value} = ${I.type.value}(0);
    ${L}
    ${o}
    ${T}
    ${I.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:g}),getShaderSource:w}},b$=(e,t,n,r)=>{let i=e.length>2,o=We(n[3]),s=We(n[2]),a=k.size(n)/o/s,u=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/o],c=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/o],d=[n[0],n[1],n[2],n[3]/o],p=[{type:12,data:a},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];ui(t,p),p.push(...J(u,c,d));let h=(s-1)*t.strides[1]+c[1],g=y=>{let w=Z("output",e[0].dataType,d.length,o),x=rt(w.type.tensor),I=ai(t,w.type.value,x),b=O("x",e[0].dataType,u.length,o),T=O("w",e[1].dataType,c.length,o),C=[b,T];i&&C.push(O("b",e[2].dataType,e[2].dims,o));let S=i?"value += b[output_channel];":"",$=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return li(t,$),`
  ${y.registerUniforms($).declareVariables(...C,w)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${s}u;
    let col = (index1 % width1) * ${s}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${b.type.value}, ${h}>;
    var values: array<${w.type.value}, ${s}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${c[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${h}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${b.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${b.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${c[1]}; w_width++) {
          let w_val = ${T.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${s}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${s}u; i++) {
      var value = values[i];
      ${S}
      ${I}
      ${w.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${o};${s};${h};${c[0]};${c[1]}`,inputDependencies:i?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:g}}}),sT,Pl,aT,Ll,km,Qh,uT,lT,Am,Jj=H(()=>{"use strict";pe(),Qj(),Zj(),ig(),Yj(),di(),rg(),xr(),sT=(e,t,n,r,i,o)=>{let s=e[0],a=e.slice(o?1:2,o?3:4),u=a.length,c=t[0],d=t.slice(2).map((h,g)=>h+(h-1)*(n[g]-1)),p=a.map((h,g)=>h+r[g]+r[g+u]).map((h,g)=>Math.floor((h-d[g]+i[g])/i[g]));return p.splice(0,0,s),p.splice(o?3:1,0,c),p},Pl=[2,3,1,0],aT=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],r=e[1].dims[1]*t.group;if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Ll=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let o=2;o<t[1].dims.length;++o)n[o-2]===0&&(n[o-2]=t[1].dims[o]);let r=e.pads.slice();Ql.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:r}),i},km=e=>{let t=eg(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,o=e.group,s=e.kernel_shape,a=e.pads,u=e.strides,c=e.w_is_const();return{autoPad:r,format:n,dilations:i,group:o,kernelShape:s,pads:a,strides:u,wIsConst:c,...t,cacheKey:`${e.format};${t.activation};`}},Qh=(e,t,n,r)=>{let i=n.format==="NHWC",o=sT(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,i);if(n.group!==1){let $=[t[0]];if(i){let M=e.kernelCustomData.wT??e.compute(zt(t[1],Pl),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),$.push(M)}else $.push(t[1]);t.length===3&&$.push(t[2]),!e.adapterInfo.isArchitecture("ampere")&&i&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(b$($,n,o,r),{inputs:$}):e.compute(w$($,n,o,r),{inputs:$});return}let s=t.length===3,a=t[0].dims[i?1:2],u=t[0].dims[i?2:3],c=t[0].dims[i?3:1],d=t[1].dims[2],p=t[1].dims[3],h=o[i?1:2],g=o[i?2:3],y=o[i?3:1],w=i&&d===a&&p===u&&n.pads[0]===0&&n.pads[1]===0;if(w||d===1&&p===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let $=o[0],M,L,V,G=[];if(i){let B=e.kernelCustomData.wT??e.compute(zt(t[1],Pl),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=B),w){let ye=a*u*c;M=t[0].reshape([1,$,ye]),L=B.reshape([1,ye,y]),V=[1,$,y]}else M=t[0].reshape([$,a*u,c]),L=B.reshape([1,c,y]),V=[$,h*g,y];G.push(M),G.push(L)}else M=t[0].reshape([$,c,a*u]),L=t[1].reshape([1,y,c]),V=[$,y,h*g],G.push(L),G.push(M);s&&G.push(t[2]);let X=V[2],oe=G[0].dims[G[0].dims.length-1];X<8&&oe<8?e.compute(ng(G,n,o,V,i,r),{inputs:G}):e.compute(Yl(G,n,o,V,i,r),{inputs:G});return}let x=!0,I=e.kernelCustomData.wT??e.compute(zt(t[1],Pl),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let b=[t[0],I];s&&b.push(t[2]);let T=i?h*g:y,C=i?y:h*g,S=d*p*c;e.compute(y$(b,n,o,T,C,S,s,x,r),{inputs:b})},uT=(e,t)=>{let n=t.format==="NHWC",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],o=[1].concat(t.strides),s=[1].concat(t.dilations),a=[1].concat(t.kernelShape),u=Ll({...t,pads:i,strides:o,dilations:s,kernelShape:a},r);Qh(e,r,u,c=>n?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},lT=(e,t,n)=>{let r=n.format==="NHWC"?"channelsLast":"channelsFirst",i=Ll(n,t),o=n.autoPad==="NOTSET"?n.pads:n.autoPad,s=v$(t[0].dims,t[1].dims,n.strides,n.dilations,o,!1,r);e.compute(_$(t,i,s.outShape,[s.filterDepth,s.filterHeight,s.filterWidth],[s.padInfo.front,s.padInfo.top,s.padInfo.left],r))},Am=(e,t)=>{if(aT(e.inputs,t),e.inputs[0].dims.length===3)uT(e,t);else if(e.inputs[0].dims.length===5)lT(e,e.inputs,t);else{let n=Ll(t,e.inputs);Qh(e,e.inputs,n)}}}),I$,Xj=H(()=>{"use strict";se(),Zn(),pe(),_e(),I$=(e,t,n)=>{let r=e.length>2,i=t.outputShape,o=t.format==="NHWC",s=t.group,a=e[1].dims,u=a[2]/s,c=a[3],d=o?We(u):1,p=o?We(c):1,h=o?c===1?d:p:1,g=k.size(i)/p,y=[Math.ceil(g/64),1,1];Ce("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let w=["rank","rank"],x=[t.strides[0],t.strides[1]],I=[t.kernelShape[o?1:2],t.kernelShape[o?2:3]],b=[t.dilations[0],t.dilations[1]],T=[I[0]+(t.dilations[0]<=1?0:(t.kernelShape[o?1:2]-1)*(t.dilations[0]-1)),I[1]+(t.dilations[1]<=1?0:(t.kernelShape[o?2:3]-1)*(t.dilations[1]-1))],C=[T[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),T[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],S=[{type:12,data:g},{type:12,data:x},{type:12,data:I},{type:12,data:b},{type:12,data:T},{type:6,data:C},{type:12,data:u},{type:12,data:c},...J(e[0].dims,e[1].dims)];r&&(S.push(...J(e[2].dims)),w.push("rank")),S.push(...J(i));let $=M=>{let L=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:x.length},{name:"filter_dims",type:"u32",length:I.length},{name:"dilations",type:"u32",length:I.length},{name:"effective_filter_dims",type:"u32",length:T.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],V=rt(e[0].dataType),G=o?1:2,X=o?2:3,oe=o?3:1,B=O("W",e[1].dataType,e[1].dims.length,h),ye=O("Dy",e[0].dataType,e[0].dims.length,d),xe=[ye,B];r&&xe.push(O("bias",e[2].dataType,[i[oe]].length,p));let K=Z("result",e[0].dataType,i.length,p),we=()=>{let Q="";if(d===1)Q+=`
        let w_offset = ${B.indicesToOffset(`${B.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
        let wValue = ${B.getByOffset(`w_offset / ${h}`)};
        dotProd = dotProd + xValue * wValue;`;else if(c===1)Q+=`
          let wValue = ${B.getByOffset(`${B.indicesToOffset(`${B.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${h}`)};
          dotProd = dotProd + dot(xValue, wValue);`;else for(let Te=0;Te<d;Te++)Q+=`
            let wValue${Te} = ${B.getByOffset(`${B.indicesToOffset(`${B.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${Te}, wOutChannel)`)} / ${h}`)};
            dotProd = dotProd + xValue[${Te}] * wValue${Te};`;return Q},Ee=`
            let outputIndices = ${K.offsetToIndices(`global_idx * ${p}`)};
            let batch = ${K.indicesGet("outputIndices",0)};
            let d1 = ${K.indicesGet("outputIndices",oe)};
            let r = ${K.indicesGet("outputIndices",G)};
            let c = ${K.indicesGet("outputIndices",X)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${K.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${V}(dyRCorner) + ${V}(wR)) / ${V}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${V}(uniforms.Dy_shape[${G}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }

              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${V}(dyCCorner) + ${V}(wC)) / ${V}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${V}(uniforms.Dy_shape[${X}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${d}) {
                  let xValue = ${o?ye.getByOffset(`${ye.indicesToOffset(`${ye.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${d}`):ye.get("batch","inputChannel","idyR","idyC")};
                  ${we()}
                  inputChannel = inputChannel + ${d};
                }
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${r?` + bias[d1 / ${p}]`:""};
            ${K.setByOffset("global_idx","value")};
          `;return`
    ${M.registerUniforms(L).declareVariables(...xe,K)}
      ${M.mainStart()}
      ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${Ee}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${d}${h}${p}${c===1}`,inputDependencies:w},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:n?n(i):i,dataType:e[0].dataType}],programUniforms:S}),getShaderSource:$}}}),cT,dT,fT,Zh,x$,pT,Yh,hT,E$,eV=H(()=>{"use strict";Xj(),di(),xr(),cT=(e,t,n,r,i,o)=>(e-1)*t+n+(r-1)*i+1-o,dT=(e,t,n,r,i)=>{let o=Math.floor(e/2);t==="SAME_UPPER"?(n[r]=o,n[i]=e-o):t==="SAME_LOWER"&&(n[r]=e-o,n[i]=o)},fT=(e,t,n,r,i,o,s,a,u,c)=>{let d=e.length-2,p=c.length===0;u.length<d&&u.push(...Array(d-u.length).fill(0));let h=e[0],g=t[a?3:1]*i;for(let y=0,w=e.length-d-(a?1:0);y<d;++y,++w){let x=e[w],I=p?x*s[y]:c[y],b=cT(x,s[y],o[y],t[w],n[y],I);dT(b,r,o,y,y+d),p&&c.push(s[y]*(x-1)+u[y]+(t[w]-1)*n[y]+1-o[y]-o[y+d])}c.splice(0,0,h),c.splice(a?3:1,0,g)},Zh=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((p,h)=>p*h,1)===0){n.length=0;for(let p=2;p<t[1].dims.length;++p)n.push(t[1].dims[p])}let r=e.format==="NHWC";n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let i=e.pads.slice(),o=e.outputShape.slice(),s=e.outputPadding.slice(),a=t[0].dims,u=e.dilations.slice();if(u.reduce((p,h)=>p+h,0)===0){let p=t[0].dims.length-2;u=new Array(p).fill(1)}let c=e.strides.slice();if(c.reduce((p,h)=>p+h,0)===0){let p=t[0].dims.length-2;c=new Array(p).fill(1)}fT(a,n,u,e.autoPad,e.group,i,c,r,s,o);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:i,outputPadding:s,outputShape:o,dilations:u,strides:c}),d},x$=e=>{let t=eg(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,o=e.group,s=e.kernelShape,a=e.pads,u=e.strides,c=e.wIsConst(),d=e.outputPadding,p=e.outputShape;return{autoPad:r,format:n,dilations:i,group:o,kernelShape:s,outputPadding:d,outputShape:p,pads:a,strides:u,wIsConst:c,...t,cacheKey:`${e.format};${t.activation};`}},pT=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],r=e[1].dims[0];if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let o=e[0].dims.length-2;if(t.dilations.reduce((s,a)=>s+a,0)>0&&t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.reduce((s,a)=>s+a,0)>0&&t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.reduce((s,a)=>s+a,0)>0&&t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.outputPadding.length!==o&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${o}D`);if(t.kernelShape.reduce((s,a)=>s+a,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Yh=(e,t,n,r)=>{let i=e.kernelCustomData.wT??e.compute(zt(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=i);let o=[t[0],i];t.length===3&&o.push(t[2]),e.compute(I$(o,n,r),{inputs:o})},hT=(e,t)=>{let n=t.format==="NHWC",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let o=t.dilations;(o.length===0||o[0]===0)&&(o=[1]);let s=t.strides;(s.length===0||s[0]===0)&&(s=[1]);let a=t.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],s=[1].concat(s),o=[1].concat(o),i=[1].concat(i);let u=t.outputPadding;u=[0].concat(u);let c=Zh({...t,pads:a,strides:s,dilations:o,kernelShape:i,outputPadding:u},r);Yh(e,r,c,d=>n?[d[0],d[2],d[3]]:[d[0],d[1],d[3]])},E$=(e,t)=>{if(pT(e.inputs,t),e.inputs[0].dims.length===3)hT(e,t);else{let n=Zh(t,e.inputs);Yh(e,e.inputs,n)}}}),mT,T$,C$,tV=H(()=>{"use strict";se(),pe(),Qe(),_e(),mT=(e,t,n,r)=>{let i=k.size(t),o=t.length,s=O("input",e,o),a=Z("output",e,o),u=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),c=k.normalizeAxis(u,o),d=p=>{let h=` i32(${s.indicesGet("inputIndices","uniforms.axis")}) `,g=Y("uniforms.input_shape","uniforms.axis",o),y=r.reverse?h+(r.exclusive?" + 1":""):"0",w=r.reverse?g:h+(r.exclusive?"":" + 1");return`
                ${p.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(s,a)}
                ${p.mainStart()}
                  ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${a.offsetToIndices("global_idx")};
                  var sum = ${a.type.value}(0);
                  let first : i32 = ${y};
                  let last : i32 = ${w};
                  for (var i : i32 = first; i < last; i++) {
                    ${s.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${s.getByIndices("inputIndices")};
                  }
                  ${a.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:c},...J(t,t)]}),getShaderSource:d}},T$=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,i=e.inputs[1];e.compute(mT(r,n,i,t),{inputs:[0]})},C$=e=>{let t=e.exclusive===1,n=e.reverse===1;return ke({exclusive:t,reverse:n})}}),gT,yT,vT,D$,S$,nV=H(()=>{"use strict";se(),pe(),Qe(),_e(),gT=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},yT=(e,t,n,r)=>{let i=[];i.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let o=0;o<t;++o)i.push(n.indicesSet("a",e[o],`i[${o}]`));return i.push("return a;}"),i.join(`
`)},vT=(e,t)=>{let n,r,i,o,s,a,u=t.format==="NHWC",c=t.blocksize,d=t.mode==="DCR";u?([n,r,i,o]=e.dims,s=d?[n,r,i,c,c,o/c**2]:[n,r,i,o/c**2,c,c],a=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,i,o]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=d?[n,c,c,o/c**2,r,i]:[n,o/c**2,c,c,r,i],a=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let p=e.reshape(s),h=p.dims.length,g=e.dataType,y=O("a",g,h),w=Z("output",g,h),x=I=>`
  ${I.registerUniform("output_size","u32").declareVariables(y,w)}

  ${yT(a,h,y,w)}

  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${w.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${w.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:I=>{let b=u?[n,r*c,i*c,o/c**2]:[n,o/c**2,r*c,i*c],T=k.size(b),C=p.dims,S=k.sortBasedOnPerm(C,a);return{outputs:[{dims:b,dataType:I[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...J(C,S)]}},getShaderSource:x}},D$=(e,t)=>{gT(e.inputs),e.compute(vT(e.inputs[0],t))},S$=e=>ke({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Fl,Vs,Jh,_T,wT,bT,IT,Xh,xT,$$,M$,rV=H(()=>{"use strict";se(),pe(),Qe(),_e(),Fl="[a-zA-Z]|\\.\\.\\.",Vs="("+Fl+")+",Jh="^"+Vs+"$",_T="("+Vs+",)*"+Vs,wT="^"+_T+"$",bT=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);n===void 0?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},IT=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(wT)))throw new Error("Invalid LHS term");if(n.split(",").forEach((i,o)=>{let s=e[o].dims.slice();if(!i.match(RegExp(Jh)))throw new Error("Invalid LHS term");let a=this.processTerm(i,!0,s,o);this.lhs.push(a)}),r==="")r+=[...this.symbolToInfo.entries()].filter(([i,o])=>o.count===1||i==="...").map(([i])=>i).join("");else if(!r.match(RegExp(Vs)))throw new Error("Invalid RHS");r.match(RegExp(Fl,"g"))?.forEach(i=>{if(i==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(i);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(r!==void 0){if(r.dimValue!==t&&r.count!==1)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let i=n.length,o=!1,s=[],a=0;if(!e.match(RegExp(Jh))&&!t&&e!=="")throw new Error("Invalid LHS term");let u=e.match(RegExp(Fl,"g")),c=new bT(r);return u?.forEach((d,p)=>{if(d==="..."){if(o)throw new Error("Only one ellipsis is allowed per input term");o=!0;let h=i-u.length+1;if(h<0)throw new Error("Ellipsis out of bounds");if(s=n.slice(a,a+h),this.hasEllipsis){if(this.ellipsisDims.length!==s.length||this.ellipsisDims.toString()!==s.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=s;else throw new Error("Ellipsis must be specified in the LHS");for(let g=0;g<s.length;g++){let y=String.fromCharCode(48+g);c.addSymbol(y,p+g),this.addSymbol(y,n[a++],r)}}else c.addSymbol(d,p+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(d,n[a++],r)}),c}},Xh=e=>e+"_max",xT=(e,t,n,r)=>{let i=e.map(c=>c.length).map((c,d)=>O(`input${d}`,t,c)),o=k.size(r),s=Z("output",t,r.length),a=[...n.symbolToInfo.keys()].filter(c=>!n.rhs.symbolToIndices.has(c)),u=c=>{let d=[],p="var prod = 1.0;",h="var sum = 0.0;",g="sum += prod;",y=[],w=[],x=[],I=[],b=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((C,S)=>{if(n.rhs.symbolToIndices.has(S)){let $=n.rhs.symbolToIndices.get(S)?.[0];$!==void 0&&n.lhs.forEach((M,L)=>{if(C.inputIndices.includes(L)){let V=M.symbolToIndices.get(S);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(G=>{d.push(`${i[L].indicesSet(`input${L}Indices`,G,s.indicesGet("outputIndices",$))}`)})}})}else n.lhs.forEach(($,M)=>{if(C.inputIndices.includes(M)){let L=$.symbolToIndices.get(S);if(L===void 0)throw new Error("Invalid symbol error");L.forEach(V=>{y.push(`${i[M].indicesSet(`input${M}Indices`,V,`${S}`)}`)}),I.push(`prod *= ${i[M].getByIndices(`input${M}Indices`)};`)}}),w.push(`for(var ${S}: u32 = 0; ${S} < uniforms.${Xh(S)}; ${S}++) {`),x.push("}")});let T=b?[...d,`let sum = ${i.map((C,S)=>C.getByIndices(`input${S}Indices`)).join(" * ")};`]:[...d,h,...w,...y,p,...I,g,...x];return`
            ${c.registerUniforms(a.map(C=>({name:`${Xh(C)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...i,s)}

            ${c.mainStart()}
            ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${s.offsetToIndices("global_idx")};
            ${i.map((C,S)=>`var input${S}Indices: ${i[S].type.indices};`).join(`
`)}
            ${T.join(`
`)};
            ${s.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let c=a.filter(p=>n.symbolToInfo.has(p)).map(p=>({type:12,data:n.symbolToInfo.get(p)?.dimValue||0}));c.push({type:12,data:o});let d=e.map((p,h)=>[...J(p)]).reduce((p,h)=>p.concat(h),c);return d.push(...J(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:d}},getShaderSource:u}},$$=(e,t)=>{let n=new IT(e.inputs,t.equation),r=n.outputDims,i=e.inputs.map((o,s)=>o.dims);e.compute(xT(i,e.inputs[0].dataType,n,r))},M$=e=>{let t=e.equation.replace(/\s+/g,"");return ke({equation:t})}}),ET,em,TT,CT,N$,iV=H(()=>{"use strict";se(),pe(),_e(),ET=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,i=t.length<n.length?0:t.length-n.length;for(;r<n.length&&i<t.length;++r,++i)if(n[r]!==t[i]&&n[r]!==1&&t[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},em=(e,t)=>{let n=e.length-t.length,r=[];for(let i=0;i<n;++i)r.push(e[i]);for(let i=0;i<t.length;++i)r.push(t[i]===1?e[i+n]:t[i]);return r},TT=(e,t)=>e.length>t.length?em(e,t):em(t,e),CT=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=TT(t,n),i=e[0].dataType,o=i===9||k.size(t)===1,s=i===9||t.length>0&&t[t.length-1]%4===0?4:1,a=o||r.length>0&&r[r.length-1]%4===0?4:1,u=Math.ceil(k.size(r)/a),c=p=>{let h=O("input",i,t.length,s),g=Z("output",i,r.length,a),y;if(i===9){let w=(x,I,b="")=>`
          let outputIndices${I} = ${g.offsetToIndices(`outputOffset + ${I}u`)};
          let offset${I} = ${h.broadcastedIndicesToOffset(`outputIndices${I}`,g)};
          let index${I} = offset${I} / 4u;
          let component${I} = offset${I} % 4u;
          ${x}[${I}] = ${b}(${h.getByOffset(`index${I}`)}[component${I}]);
        `;y=`
        let outputOffset = global_idx * ${a};
        var data = vec4<u32>(0);
        ${w("data",0,"u32")}
        ${w("data",1,"u32")}
        ${w("data",2,"u32")}
        ${w("data",3,"u32")}
        ${g.setByOffset("global_idx","data")}
      }`}else y=`
        let outputIndices = ${g.offsetToIndices(`global_idx * ${a}`)};
        let inputOffset = ${h.broadcastedIndicesToOffset("outputIndices",g)};
        let data = ${g.type.value}(${h.getByOffset(`inputOffset / ${s}`)});
        ${g.setByOffset("global_idx","data")}
      }`;return`
    ${p.registerUniform("vec_size","u32").declareVariables(h,g)}
    ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${y}`},d=[{type:12,data:u},...J(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${s}${a}`,inputDependencies:["rank"]},getShaderSource:c,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d})}},N$=e=>{ET(e.inputs),e.compute(CT(e.inputs),{inputs:[0]})}}),DT,k$,oV=H(()=>{"use strict";se(),pe(),_e(),Xm(),DT=e=>{let t=e[0].dataType,n=k.size(e[0].dims),r=k.size(e[1].dims),i=r%4===0,o=s=>{let a=O("x",t,[1],4),u=O("bias",t,[1],4),c=Z("y",t,[1],4),d=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],p=g=>`
      let bias${g}_offset: u32 = (global_idx * 4 + ${g}) % uniforms.bias_size;
      let bias${g} = ${u.getByOffset(`bias${g}_offset / 4`)}[bias${g}_offset % 4];`,h=i?`
      let bias = ${u.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${p(0)}${p(1)}${p(2)}${p(3)}
      let bias = ${a.type.value}(bias0, bias1, bias2, bias3);`;return`${s.registerUniforms(d).declareVariables(a,u,c)}

    ${Sm(vt(t))}

    ${s.mainStart(_o)}
      ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${a.getByOffset("global_idx")};
      ${h}
      let x_in = x + bias;
      ${c.setByOffset("global_idx",$m("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:o,getRunData:s=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/_o/4)}})}},k$=e=>{e.inputs.length<2||k.size(e.inputs[1].dims)===0?JS(e):e.compute(DT(e.inputs))}}),ST,$T,A$,R$,sV=H(()=>{"use strict";se(),pe(),Qe(),_e(),ST=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},$T=(e,t)=>{let n=e[0].dims,r=e[1].dims,i=n.length,o=k.normalizeAxis(t.axis,i),s=n.slice(0);s.splice(o,1,...r);let a=n[o],u=e[0].dataType===9?4:1,c=Math.ceil(k.size(s)/u),d=[{type:12,data:c},{type:6,data:a},{type:12,data:o},...J(e[0].dims,e[1].dims,s)],p=h=>{let g=O("data",e[0].dataType,e[0].dims.length,u),y=O("inputIndices",e[1].dataType,e[1].dims.length),w=Z("output",e[0].dataType,s.length,u),x=b=>{let T=r.length,C=`var indicesIndices${b}  = ${y.type.indices}(0);`;for(let S=0;S<T;S++)C+=`${T>1?`indicesIndices${b}[${S}]`:`indicesIndices${b}`} = ${s.length>1?`outputIndices${b}[uniforms.axis + ${S}]`:`outputIndices${b}`};`;C+=`
          var idx${b} = ${y.getByIndices(`indicesIndices${b}`)};
          if (idx${b} < 0) {
            idx${b} = idx${b} + uniforms.axisDimLimit;
          }
          var dataIndices${b} : ${g.type.indices};
        `;for(let S=0,$=0;S<i;S++)S===o?(C+=`${i>1?`dataIndices${b}[${S}]`:`dataIndices${b}`} = u32(idx${b});`,$+=T):(C+=`${i>1?`dataIndices${b}[${S}]`:`dataIndices${b}`} = ${s.length>1?`outputIndices${b}[${$}]`:`outputIndices${b}`};`,$++);return C},I;if(e[0].dataType===9){let b=(T,C,S="")=>`
          let outputIndices${C} = ${w.offsetToIndices(`outputOffset + ${C}u`)};
          ${x(C)};
          let offset${C} = ${g.indicesToOffset(`dataIndices${C}`)};
          let index${C} = offset${C} / 4u;
          let component${C} = offset${C} % 4u;
          ${T}[${C}] = ${S}(${g.getByOffset(`index${C}`)}[component${C}]);
        `;I=`
        let outputOffset = global_idx * ${u};
        var value = vec4<u32>(0);
        ${b("value",0,"u32")}
        ${b("value",1,"u32")}
        ${b("value",2,"u32")}
        ${b("value",3,"u32")}
        ${w.setByOffset("global_idx","value")}
      `}else I=`
      let outputIndices = ${w.offsetToIndices("global_idx")};
      ${x("")};
      let value = ${g.getByIndices("dataIndices")};
      ${w.setByOffset("global_idx","value")};
      `;return`
      ${h.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(g,y,w)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${I}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d}),getShaderSource:p}},A$=e=>ke({axis:e.axis}),R$=(e,t)=>{let n=e.inputs;ST(n),e.compute($T(e.inputs,t))}}),MT,O$,P$,aV=H(()=>{"use strict";se(),pe(),_e(),MT=(e,t,n,r,i,o,s,a,u)=>{let c=[{type:12,data:o},{type:12,data:r},{type:12,data:i},{type:12,data:n},{type:12,data:s},{type:12,data:a},{type:12,data:u}],d=[o];c.push(...J(t.dims,d));let p=h=>{let g=O("indices_data",t.dataType,t.dims.length),y=Z("input_slice_offsets_data",12,1,1),w=[g,y],x=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:i.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${h.registerUniforms(x).declareVariables(...w)}
  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${i.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${i.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:p},{inputs:[t],outputs:[-1]})[0]},O$=(e,t)=>{let n=e.inputs,r=n[0].dims,i=n[0].dataType,o=n[1].dims,s=o[o.length-1],a=k.sizeToDimension(o,o.length-1),u=k.sizeFromDimension(r,t.batchDims+s),c=k.sizeToDimension(r,t.batchDims),d=k.sizeFromDimension(r,t.batchDims),p=a/c,h=new Array(s),g=u;for(let C=0;C<s;++C)h[s-1-C]=g,g*=r[t.batchDims+s-1-C];let y=MT(e,n[1],h,t.batchDims,r,a,p,d,s),w=t.batchDims+s;if(w>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let x=o.slice(0,-1).concat(r.slice(w)),I=k.size(x),b=[{type:12,data:I},{type:12,data:u},...J(n[0].dims,y.dims,x)],T=C=>{let S=O("data",n[0].dataType,n[0].dims.length),$=O("slice_offsets",12,y.dims.length),M=Z("output",n[0].dataType,x.length);return`
          ${C.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(S,$,M)}
            ${C.mainStart()}
            ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:x,dataType:i}],dispatchGroup:{x:Math.ceil(I/64)},programUniforms:b}),getShaderSource:T},{inputs:[n[0],y]})},P$=e=>({batchDims:e.batch_dims,cacheKey:""})}),NT,kT,L$,F$,uV=H(()=>{"use strict";se(),pe(),Qe(),_e(),NT=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=k.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,i=e[0],o=e[2],s=e.length===4?e[3]:void 0;if(o.dims.length!==i.dims.length||!i.dims.map((a,u)=>u===n?Math.ceil(a/r)===o.dims[u]:a===o.dims[u]).reduce((a,u)=>a&&u,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(s){if(s.dataType!==i.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(s.dims.length!==o.dims.length||!s.dims.map((a,u)=>a===o.dims[u]).reduce((a,u)=>a&&u,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},kT=(e,t)=>{let n=e[0].dims,r=e[1].dims,i=n.length,o=k.normalizeAxis(t.gatherAxis,i),s=k.normalizeAxis(t.quantizeAxis,i),a=n.slice(0);a.splice(o,1,...r);let u=k.size(a),c=e[2].dataType,d=e[0].dataType===22,p=[{type:12,data:u},{type:12,data:s},{type:12,data:o},{type:12,data:t.blockSize},...J(...e.map((g,y)=>g.dims),a)],h=g=>{let y=O("data",e[0].dataType,e[0].dims.length),w=O("inputIndices",e[1].dataType,e[1].dims.length),x=O("scales",e[2].dataType,e[2].dims.length),I=e.length>3?O("zeroPoint",e[3].dataType,e[3].dims.length):void 0,b=Z("output",c,a.length),T=[y,w,x];I&&T.push(I);let C=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${g.registerUniforms(C).declareVariables(...T,b)}
        ${g.mainStart()}
        let output_indices = ${b.offsetToIndices("global_idx")};
        var indices_indices = ${w.type.indices}(0);
        ${r.length>1?`
          for (var i: u32 = 0; i < ${r.length}; i++) {
            let index = ${b.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${w.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${b.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${y.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${b.indicesGet("output_indices","i")};
          ${y.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${w.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[o]};
        }
        ${y.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${a.length}; i++) {
          let index = ${b.indicesGet("output_indices",`i + ${r.length} - 1`)};
          ${y.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${y.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${y.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${x.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${x.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${x.getByIndices("scale_indices")};
        ${I?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${I.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${I.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${vt(c)}(quantized_data - zero_point) * scale;
        ${b.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((g,y)=>y!==1).map(g=>g.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(g,y)=>"rank")},getRunData:()=>({outputs:[{dims:a,dataType:c}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:p}),getShaderSource:h}},L$=(e,t)=>{let n=e.inputs;NT(n,t),e.compute(kT(e.inputs,t))},F$=e=>ke({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),AT,RT,z$,B$,lV=H(()=>{"use strict";se(),pe(),Qe(),_e(),AT=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},RT=(e,t)=>{let n=e[0].dims,r=e[0].dataType,i=n.length,o=e[1].dims,s=e[1].dataType,a=k.normalizeAxis(t.axis,i),u=n[a],c=o.slice(0),d=k.size(c),p=O("input",r,i),h=O("indicesInput",s,o.length),g=Z("output",r,c.length),y=[{type:12,data:d},{type:6,data:u},{type:12,data:a}];return y.push(...J(n,o,c)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}),getShaderSource:w=>`
      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,h,g)}
      ${w.mainStart()}
      ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${g.offsetToIndices("global_idx")};

      var idx = ${h.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${p.type.indices}(outputIndices);
      ${p.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${p.getByIndices("inputIndices")};

      ${g.setByOffset("global_idx","value")};
  }`}},z$=e=>ke({axis:e.axis}),B$=(e,t)=>{let n=e.inputs;AT(n),e.compute(RT(e.inputs,t))}}),OT,PT,j$,V$,cV=H(()=>{"use strict";se(),pe(),_e(),OT=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},PT=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[i,o,s]=HD.getShapeOfGemmResult(n,t.transA,r,t.transB,e.length===3?e[2].dims:void 0),a=[i,o];if(!a)throw new Error("Can't use gemm on the given tensors");let u=16,c=Math.ceil(o/u),d=Math.ceil(i/u),p=!0,h=k.size(a),g=[{type:12,data:p?c:h},{type:12,data:i},{type:12,data:o},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}],y=["type","type"];e.length===3&&(g.push(...J(e[2].dims)),y.push("rank")),g.push(...J(a));let w=I=>{let b="";t.transA&&t.transB?b="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?b="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?b="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(b="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let T=t.alpha===1?"":"value *= uniforms.alpha;",C=O("a",e[0].dataType,e[0].dims),S=O("b",e[1].dataType,e[1].dims),$=C.type.value,M=null,L=[C,S];e.length===3&&(M=O("c",e[2].dataType,e[2].dims.length),L.push(M));let V=Z("output",e[0].dataType,a.length);L.push(V);let G=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${I.registerUniforms(G).declareVariables(...L)}

  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${$}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${b}
    }

    ${T}
    ${M!=null?`let cOffset = ${M.broadcastedIndicesToOffset("vec2(m, n)",V)}; value += ${$}(uniforms.beta) * ${M.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},x=I=>{let b=O("a",e[0].dataType,e[0].dims),T=O("b",e[1].dataType,e[1].dims),C=null,S=[b,T];e.length===3&&(C=O("c",e[2].dataType,e[2].dims.length),S.push(C));let $=Z("output",e[0].dataType,a.length);S.push($);let M=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],L="",V="";t.transA&&t.transB?(V=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,L="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(V=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,L="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(V=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,L="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(V=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,L="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let G=t.alpha===1?"":"value *= uniforms.alpha;";return`
  ${I.registerUniforms(M).declareVariables(...S)}
  var<workgroup> tile_a: array<array<${b.type.storage}, ${u}>, ${u}>;
  var<workgroup> tile_b: array<array<${T.type.storage}, ${u}>, ${u}>;
  ${I.mainStart([u,u,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${u};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${u};
    let num_tiles = (uniforms.K - 1) / ${u} + 1;
    var k_start = 0u;
    var value = ${$.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${V}
      k_start = k_start + ${u};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${u}; k++) {
        ${L}
      }
      workgroupBarrier();
    }

    ${G}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",$)}; value += ${$.type.value}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return p?{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:c*d},programUniforms:g}),getShaderSource:x}:{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:g}),getShaderSource:w}},j$=e=>{let t=e.transA,n=e.transB,r=e.alpha,i=e.beta;return{transA:t,transB:n,alpha:r,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},V$=(e,t)=>{OT(e.inputs),e.compute(PT(e.inputs,t))}}),Rn,Qn,ei,ti,LT,FT,zT,BT,jT,VT,HT,UT,H$,U$,dV=H(()=>{"use strict";se(),pe(),Qe(),_e(),[Rn,Qn,ei,ti]=[0,1,2,3],LT=e=>{if(e[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},FT=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,zT=e=>`
  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,BT=e=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${e.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,jT=e=>`
  ${e.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,VT=(e,t,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {
     var pixel = ${t}(0);
     var indices = vec4<u32>(0);
     indices[${Rn}] = batch;
     indices[${Qn}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${ei}] = u32(r);
            indices[${ti}] = u32(c);
          }
        `;case"border":return`
          indices[${ei}] = u32(clamp(r, 0, H - 1));
          indices[${ti}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${ei}] = gs_reflect(r, border[1], border[3]);
          indices[${ti}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${e.getByIndices("indices")};
  }
`,HT=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Rn}], indices[${Qn}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Rn}], indices[${Qn}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Rn}], indices[${Qn}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Rn}], indices[${Qn}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Rn}], indices[${Qn}], border);

          let dx2 = ${t}(f32(x2) - x);
          let dx1 = ${t}(x - f32(x1));
          let dy2 = ${t}(f32(y2) - y);
          let dy1 = ${t}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${t}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Rn}], indices[${Qn}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,UT=(e,t)=>{let n=O("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],i=O("grid",e[1].dataType,r.length,2),o=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format==="NHWC"&&(o=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Rn,Qn,ei,ti]=[0,3,1,2]);let s=Z("output",e[0].dataType,o.length),a=n.type.value,u=k.size(o),c=[{type:12,data:u},...J(e[0].dims,r,o)],d=p=>`
  ${p.registerUniform("output_size","u32").declareVariables(n,i,s)}
  ${FT}
  ${zT(a)}
  ${BT(t)}
  ${jT(t)}
  ${VT(n,a,t)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${ei}]);
      let W_in = i32(uniforms.x_shape[${ti}]);

      ${t.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${s.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${Rn}], indices[${ei}], indices[${ti}]);
      let nxy = ${i.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${HT(s,a,t)}
  }`;return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:p=>{let h=k.size(o);return{outputs:[{dims:o,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:c}},getShaderSource:d}},H$=(e,t)=>{LT(e.inputs),e.compute(UT(e.inputs,t))},U$=e=>ke({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),Et,WT,W$,tm,qT,Zs,q$,G$=H(()=>{"use strict";se(),pe(),Qe(),Qm(),Jm(),_e(),xr(),Et=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,WT=(e,t)=>{let n=e[0],r=Et(e,1),i=Et(e,2),o=Et(e,3),s=Et(e,4),a=Et(e,5),u=Et(e,6),c=Et(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=n.dims[0],p=n.dims[1],h=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],g=p,y=0,w=0,x=Math.floor(h/t.numHeads);if(u&&c&&k.size(u.dims)&&k.size(c.dims)){if(u.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(u.dims[0]!==d||u.dims[1]!==t.numHeads||u.dims[3]!==x)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(c.dims[0]!==d||c.dims[1]!==t.numHeads||c.dims[3]!==x)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[2]!==c.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(c.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');y=u.dims[2],w=u.dims[2]}else if(u&&k.size(u.dims)||c&&k.size(c.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let I;if(r&&k.size(r.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');I=2,g=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==x)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw new Error('Expect "value" be none when "key" has packed kv format.');I=5,g=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==x)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');I=0,g=r.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');I=3}if(o&&k.size(o.dims)>0){if(o.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(r&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let b=y+g,T=0;if(s&&k.size(s.dims)>0){T=8;let M=s.dims;throw M.length===1?M[0]===d?T=1:M[0]===3*d+2&&(T=3):M.length===2&&M[0]===d&&M[1]===b&&(T=5),T===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let C=!1,S=h;if(i&&k.size(i.dims)>0){if(i.dims.length!==3&&i.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(g!==i.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');S=i.dims[2]}else{if(g!==i.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');S=i.dims[1]*i.dims[3],C=!0}}let $=!1;if(s&&k.size(s.dims)>0)throw new Error("Key padding mask is not supported");if(a&&k.size(a.dims)>0){if(a.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(a.dims[0]!==d||a.dims[1]!==t.numHeads||a.dims[2]!==p||a.dims[3]!==b)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:d,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:g,totalSequenceLength:b,maxSequenceLength:w,inputHiddenSize:0,hiddenSize:h,vHiddenSize:S,headSize:x,vHeadSize:Math.floor(S/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:$,passPastInKv:C,qkvFormat:I}},W$=e=>ke({...e}),tm=ke({perm:[0,2,1,3]}),qT=(e,t,n,r,i,o,s)=>{let a=[r,i,o],u=k.size(a),c=[{type:12,data:u},{type:12,data:s},{type:12,data:o}],d=p=>{let h=Z("qkv_with_bias",t.dataType,a),g=O("qkv",t.dataType,a),y=O("bias",n.dataType,a),w=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${p.registerUniforms(w).declareVariables(g,y,h)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:d},{inputs:[t,n],outputs:[-1]})[0]},Zs=(e,t,n,r,i,o,s,a)=>{let u=o;if(s&&k.size(s.dims)>0){if(r===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return u=qT(e,o,s,t,r,n*i,a),u=u.reshape([t,r,n,i]),n===1||r===1?u:e.compute(zt(u,tm.perm),{inputs:[u],outputs:[-1]})[0]}else return o.dims.length===3&&(u=o.reshape([t,r,n,i])),n===1||r===1?u:e.compute(zt(u,tm.perm),{inputs:[u],outputs:[-1]})[0]},q$=(e,t)=>{let n=WT(e.inputs,t),r=e.inputs[0],i=Et(e.inputs,1),o=Et(e.inputs,2),s=Et(e.inputs,3),a=Et(e.inputs,4),u=Et(e.inputs,5),c=Et(e.inputs,6),d=Et(e.inputs,7);if(r.dims.length===5)throw new Error("Packed QKV is not implemented");if(i?.dims.length===5)throw new Error("Packed KV is not implemented");let p=i&&o&&i.dims.length===4&&o.dims.length===4,h=Zs(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,s,0);if(p)return Js(e,h,i,o,a,void 0,c,d,u,n);if(!i||!o)throw new Error("key and value must be provided");let g=Zs(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,i,s,n.hiddenSize),y=Zs(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,o,s,2*n.hiddenSize);Js(e,h,g,y,a,void 0,c,d,u,n)}}),GT,KT,QT,ZT,Rm,K$,Q$,Z$=H(()=>{"use strict";se(),pe(),Qe(),_e(),GT=e=>{if(!e||e.length<1)throw new Error("too few inputs")},KT=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>n.push(Number(i))),r=n.length),ke({numOutputs:r,axis:t.axis,splitSizes:n})},QT=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${Y("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,ZT=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let i=e[r].setByIndices("indices","input[global_idx]");t===1?n.push(i):r===0?n.push(`if (output_number == ${r}u) { ${i} }`):r===t-1?n.push(`else { ${i} }`):n.push(`else if (output_number == ${r}) { ${i} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},Rm=(e,t)=>{let n=e[0].dims,r=k.size(n),i=e[0].dataType,o=k.normalizeAxis(t.axis,n.length),s=new Array(t.numOutputs),a=O("input",i,n.length),u=new Array(t.numOutputs),c=[],d=[],p=0,h=[{type:12,data:r}];for(let y=0;y<t.numOutputs;y++){p+=t.splitSizes[y],u[y]=p;let w=n.slice();w[o]=t.splitSizes[y],d.push(w),s[y]=Z(`output${y}`,i,w.length),c.push({dims:d[y],dataType:e[0].dataType})}h.push({type:12,data:u},...J(n,...d));let g=y=>`
  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",u.length).declareVariables(a,...s)}
  ${QT(u.length)}
  ${ZT(s)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${a.offsetToIndices("global_idx")};
    var index = ${a.indicesGet("indices",o)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Y("uniforms.size_in_split_axis","output_number - 1u",u.length)};
      ${a.indicesSet("indices",o,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:c,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:h})}},K$=(e,t)=>{GT(e.inputs);let n=e.inputs.length===1?t:KT(e.inputs,t);e.compute(Rm(e.inputs,n),{inputs:[0]})},Q$=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ke({axis:t,numOutputs:r,splitSizes:n})}}),YT,JT,nm,Y$,fV=H(()=>{"use strict";Qe(),Jm(),G$(),Z$(),xr(),YT=(e,t)=>{if(t.doRotary)throw new Error("GroupQuerryAttention do_rotary attribute is not supported");if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],i=e[2],o=e[3],s=e[4];if(t.localWindowSize!==-1)throw new Error("Local attention is not supported");if(t.softcap!==0)throw new Error("Softcap is not supported");if(t.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let a=!1,u=n.dims[0],c=n.dims[1],d=n.dims.length===3?a?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],p=c,h=0,g=!r||r.dims.length===0,y=Math.floor(g?d/(t.numHeads+2*t.kvNumHeads):d/t.numHeads);g&&(d=y*t.numHeads);let w=o&&o.dims.length!==0,x=s&&s.dims.length!==0;if(w&&o.dims.length===4&&o.dims[0]===u&&o.dims[1]!==t.kvNumHeads&&o.dims[2]===t.kvNumHeads&&o.dims[3]===y)throw new Error("BSNH pastKey/pastValue is not supported");if(w&&x){if(o.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(s.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');h=o.dims[2]}else if(w||x)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let I=1;if(r&&r.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');p=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==y)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw new Error('Expect "value" be none when "key" has packed kv format.');p=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==y)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');p=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');I=3}let b=0,T=!1,C=t.kvNumHeads?y*t.kvNumHeads:d;if(i&&i.dims.length>0){if(i.dims.length!==3&&i.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(p!==i.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');C=i.dims[2]}else{if(p!==i.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');C=i.dims[1]*i.dims[3],T=!0}}let S=e.length>4?e[5]:void 0;if(S&&S.dims.length!==1&&S.dims[0]!==u)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:u,sequenceLength:c,pastSequenceLength:h,kvSequenceLength:p,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:d,vHiddenSize:C,headSize:y,vHeadSize:Math.floor(C/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:b,scale:t.scale,broadcastResPosBias:!1,passPastInKv:T,qkvFormat:I}},JT=ke({perm:[0,2,1,3]}),nm=(e,t,n)=>{let r=t,i=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(r=t.reshape([n.batchSize,n.kvSequenceLength,i,n.headSize]),r=e.compute(zt(r,JT.perm),{inputs:[r],outputs:[-1]})[0]),r},Y$=(e,t)=>{let n=YT(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let r=e.inputs[0],i=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,o=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,s=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,a=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,u=e.inputs.length>4?e.inputs[5]:void 0,c=e.inputs.length>5?e.inputs[6]:void 0,d=n.kvNumHeads?n.kvNumHeads:n.numHeads,p=ke({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,d*n.headSize,d*n.headSize]}),[h,g,y]=!i&&!o?e.compute(Rm([r],p),{inputs:[r],outputs:[-1,-1,-1]}):[r,i,o],w=Zs(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,h,void 0,0);Js(e,w,nm(e,g,n),nm(e,y,n),void 0,void 0,s,a,void 0,n,u,c)}}),rm,XT,eC,J$,pV=H(()=>{"use strict";se(),pe(),xr(),_e(),rm=(e,t,n,r,i,o,s,a)=>{let u=We(o),c=u===1?"f32":`vec${u}f`,d=u===1?"vec2f":`mat2x${u}f`,p=i*s,h=64;p===1&&(h=256);let g=[i,s,o/u],y=[i,s,2],w=["rank","type","type"],x=[];x.push(...J(g,y));let I=b=>{let T=O("x",t.dataType,3,u),C=O("scale",n.dataType,n.dims),S=O("bias",r.dataType,r.dims),$=Z("output",1,3,2),M=[T,C,S,$];return`
  var<workgroup> workgroup_shared : array<${d}, ${h}>;
  const workgroup_size = ${h}u;
  ${b.declareVariables(...M)}
  ${b.mainStart(h)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${c}(0);
    var squared_sum = ${c}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${c}(${T.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${d}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Ir("workgroup_shared[0][0]",u)} / f32(hight * ${u});
      let squared_sum_final = ${Ir("workgroup_shared[0][1]",u)} / f32(hight * ${u});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${a}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${u};${a};${h}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:y,dataType:1}],dispatchGroup:{x:p},programUniforms:x}),getShaderSource:I},{inputs:[t,n,r],outputs:[-1]})[0]},XT=(e,t,n)=>{let r=t[0].dims,i=r,o=2,s=r[0],a=r[1],u=k.sizeFromDimension(r,o),c=We(u),d=k.size(i)/c,p=rm(e,t[0],t[1],t[2],s,u,a,n.epsilon),h=[s,a,u/c],g=[s,a],y=["type","none"],w=x=>{let I=O("x",t[0].dataType,h.length,c),b=O("scale_shift",1,g.length,2),T=Z("output",t[0].dataType,h.length,c),C=[I,b,T];return`
  ${x.registerUniform("output_size","u32").declareVariables(...C)}
  ${x.mainStart()}
  ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${T.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${b.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${I.getByOffset("global_idx")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);
      ${T.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${c}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...J(h,g,h)]}),getShaderSource:w},{inputs:[t[0],p]})},eC=(e,t,n)=>{let r=t[0].dims,i=r,o=r[0],s=r[r.length-1],a=k.sizeFromDimension(r,1)/s,u=We(s),c=k.size(i)/u,d=[{type:12,data:a},{type:12,data:Math.floor(s/u)}],p=["type","type"],h=!1,g=[0,r.length-1];for(let I=0;I<r.length-2;I++)h=h||r[I+1]!==1,g.push(I+1);h=h&&r[r.length-1]!==1;let y=h?e.compute(zt(e.inputs[0],g),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},(I,b)=>r[g[b]])),w=rm(e,y,t[1],t[2],o,a,s,n.epsilon),x=I=>{let b=rt(t[0].dataType),T=u===1?"vec2f":`mat${u}x2f`,C=M=>{let L=M===0?"x":"y",V=u===1?"f32":`vec${u}f`;switch(u){case 1:return`${b}(${V}(scale.${L}))`;case 2:return`vec2<${b}>(${V}(scale[0].${L}, scale[1].${L}))`;case 4:return`vec4<${b}>(${V}(scale[0].${L}, scale[1].${L}, scale[2].${L}, scale[3].${L}))`;default:throw new Error(`Not supported compoents ${u}`)}},S=O("input",t[0].dataType,t[0].dims,u),$=Z("output",t[0].dataType,i,u);return`
  @group(0) @binding(0) var<storage, read> input : array<${S.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${$.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${I.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${C(0)}, ${C(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${u}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d}),getShaderSource:x},{inputs:[t[0],w]})},J$=(e,t)=>{t.format==="NHWC"?eC(e,e.inputs,t):XT(e,e.inputs,t)}}),tC,nC,X$,hV=H(()=>{"use strict";se(),pe(),_e(),tC=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},nC=(e,t,n)=>{let r=t.simplified,i=e[0].dims,o=e[1],s=!r&&e[2],a=i,u=k.normalizeAxis(t.axis,i.length),c=k.sizeToDimension(i,u),d=k.sizeFromDimension(i,u),p=k.size(o.dims),h=s?k.size(s.dims):0;if(p!==d||s&&h!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${p} and bias size of ${h}`);let g=[];for(let S=0;S<i.length;++S)S<u?g.push(i[S]):g.push(1);let y=We(d),w=["type","type"],x=[{type:12,data:c},{type:1,data:d},{type:12,data:Math.floor(d/y)},{type:1,data:t.epsilon}];s&&w.push("type");let I=n>1,b=n>2,T=S=>{let $=rt(e[0].dataType),M=[O("x",e[0].dataType,e[0].dims,y),O("scale",o.dataType,o.dims,y)];s&&M.push(O("bias",s.dataType,s.dims,y)),M.push(Z("output",e[0].dataType,a,y)),I&&M.push(Z("mean_data_output",1,g)),b&&M.push(Z("inv_std_output",1,g));let L=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${S.registerUniforms(L).declareVariables(...M)}
  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Tm("f32",y)};
    var mean_square_vector = ${Tm("f32",y)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${yo($,y,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Ir("mean_vector",y)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Ir("mean_square_vector",y)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${yo($,y,"x[j + offset]")};
      let f32scale = ${yo($,y,"scale[j]")};
      output[j + offset] = ${M[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale
        ${s?`+ ${yo($,y,"bias[j]")}`:""}
      );
    }

    ${I?"mean_data_output[global_idx] = mean":""};
    ${b?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},C=[{dims:a,dataType:e[0].dataType}];return I&&C.push({dims:g,dataType:1}),b&&C.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${y};${n};${r}`,inputDependencies:w},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(c/64)},programUniforms:x}),getShaderSource:T}},X$=(e,t)=>{tC(e.inputs),e.compute(nC(e.inputs,t,e.outputCount))}}),rC,e2,mV=H(()=>{"use strict";pe(),rg(),ig(),rC=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},e2=e=>{rC(e.inputs);let t=vo.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(ng(e.inputs,{activation:""},t));else{let i=t[t.length-2],o=k.size(e.inputs[0].dims.slice(0,-2)),s=k.size(e.inputs[1].dims.slice(0,-2));if(o!==1&&i===1&&s===1){let a=e.inputs[0].reshape([1,o,r]),u=e.inputs[1].reshape([1,r,n]),c=[1,o,n],d=[a,u];e.compute(Yl(d,{activation:""},t,c),{inputs:d})}else e.compute(Yl(e.inputs,{activation:""},t))}}}),iC,oC,sC,t2,n2,gV=H(()=>{"use strict";se(),pe(),Qe(),_e(),iC=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let i=Math.floor((t.k+t.blockSize-1)/t.blockSize),o=t.blockSize/8*t.bits,s=e[1];if(!k.areEqual(s.dims,[t.n,i,o]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let a=e[2].dims;if(k.size(a)!==t.n*i)throw new Error("scales input size error.");if(e.length===4){let u=e[3].dims,c=t.bits>4?t.n*i:t.n*Math.floor((i+1)/2);if(k.size(u)!==c)throw new Error("zeroPoints input size error.")}},oC=(e,t)=>{let n=e[0].dims,r=n.length,i=n[r-2],o=t.k,s=t.n,a=n.slice(0,r-2),u=k.size(a),c=e[1].dims[2]/4,d=e[0].dataType,p=We(t.k),h=We(c),g=We(s),y=a.concat([i,s]),w=i>1&&s/g%2===0?2:1,x=k.size(y)/g/w,I=64,b=[],T=[u,i,o/p],C=k.convertShape(e[1].dims).slice();C.splice(-1,1,c/h),b.push(...J(T)),b.push(...J(C)),b.push(...J(e[2].dims)),e.length===4&&b.push(...J(k.convertShape(e[3].dims)));let S=[u,i,s/g];b.push(...J(S));let $=M=>{let L=T.length,V=O("a",e[0].dataType,L,p),G=O("b",12,C.length,h),X=O("scales",e[2].dataType,e[2].dims.length),oe=[V,G,X],B=e.length===4?O("zero_points",12,e[3].dims.length):void 0;B&&oe.push(B);let ye=S.length,xe=Z("output",e[0].dataType,ye,g),K=rt(e[0].dataType),we=(()=>{switch(p){case 1:return`array<${K}, 8>`;case 2:return`mat4x2<${K}>`;case 4:return`mat2x4<${K}>`;default:throw new Error(`${p}-component is not supported.`)}})(),Ee=()=>{let z=`
          // reuse a data
            var input_offset = ${V.indicesToOffset(`${V.type.indices}(batch, row, word_offset)`)};
            var a_data: ${we};
            for (var j: u32 = 0; j < ${8/p}; j++) {
              a_data[j] = ${V.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let W=0;W<g*w;W++)z+=`
            b_value = ${h===1?`b${W}_data`:`b${W}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${we}(${Array.from({length:4},(R,te)=>`${K}(b_value_lower[${te}]), ${K}(b_value_upper[${te}])`).join(", ")});
            b_dequantized_values = ${p===1?`${we}(${Array.from({length:8},(R,te)=>`(b_quantized_values[${te}] - ${B?`zero_point${W}`:"zero_point"}) * scale${W}`).join(", ")});`:`(b_quantized_values - ${we}(${Array(8).fill(`${B?`zero_point${W}`:"zero_point"}`).join(",")})) * scale${W};`};
            workgroup_shared[local_id.x * ${w} + ${Math.floor(W/g)}]${g>1?`[${W%g}]`:""} += ${Array.from({length:8/p},(R,te)=>`${p===1?`a_data[${te}] * b_dequantized_values[${te}]`:`dot(a_data[${te}], b_dequantized_values[${te}])`}`).join(" + ")};
          `;return z},Q=()=>{let z=`
            var col_index = col * ${g};
            ${B?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${K}(8);`}
            `;for(let W=0;W<g*w;W++)z+=`
            let scale${W} = ${X.getByOffset("col_index * nBlocksPerCol + block")};
            ${B?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${B.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${W} = ${K}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return z},Te=()=>{let z=`col_index = col * ${g};`;for(let W=0;W<g*w;W++)z+=`
            let b${W}_data = ${G.getByIndices(`${G.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return z+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${we};
            var b_dequantized_values: ${we};`,z};return`
        var<workgroup> workgroup_shared: array<${xe.type.value}, ${w*I}>;
        ${M.declareVariables(...oe,xe)}
        ${M.mainStart([I,1,1])}
          let output_indices = ${xe.offsetToIndices(`(global_idx / ${I}) * ${w}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${I}) {
            //process one block
            var word_offset: u32 = block * ${t.blockSize/p};
            ${Q()}
            for (var word: u32 = 0; word < ${c}; word += ${h}) {
              ${Te()}
              for (var i: u32 = 0; i < ${h}; i++) {
                ${Ee()}
                word_offset += ${8/p};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${w}) {
            var output_value: ${xe.type.value} = ${xe.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${I}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${w};
            }
            ${xe.setByIndices(`${xe.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${p};${h};${g};${w};${I}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:y,dataType:d}],dispatchGroup:{x},programUniforms:b}),getShaderSource:$}},sC=(e,t)=>{let n=e[0].dims,r=n.length,i=n[r-2],o=t.k,s=t.n,a=n.slice(0,r-2),u=k.size(a),c=e[1].dims[2]/4,d=e[0].dataType,p=We(t.k),h=We(c),g=a.concat([i,s]),y=128,w=s%8===0?8:s%4===0?4:1,x=y/w,I=x*h*8,b=I/p,T=I/t.blockSize,C=k.size(g)/w,S=[],$=[u,i,o/p],M=k.convertShape(e[1].dims).slice();M.splice(-1,1,c/h),S.push(...J($)),S.push(...J(M)),S.push(...J(e[2].dims)),e.length===4&&S.push(...J(k.convertShape(e[3].dims)));let L=[u,i,s];S.push(...J(L));let V=G=>{let X=$.length,oe=O("a",e[0].dataType,X,p),B=O("b",12,M.length,h),ye=O("scales",e[2].dataType,e[2].dims.length),xe=[oe,B,ye],K=e.length===4?O("zero_points",12,e[3].dims.length):void 0;K&&xe.push(K);let we=L.length,Ee=Z("output",e[0].dataType,we),Q=rt(e[0].dataType),Te=()=>{switch(p){case 1:return`
          let a_data0 = vec4<${Q}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${Q}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${Q}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${Q}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${p}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${oe.type.value}, ${b}>;
        var<workgroup> inter_results: array<array<${Ee.type.value}, ${x}>, ${w}>;
        ${G.declareVariables(...xe,Ee)}
        ${G.mainStart([x,w,1])}
          let output_indices = ${Ee.offsetToIndices(`workgroup_index * ${w}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${b};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${b}; a_offset += ${y})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${oe.getByIndices(`${oe.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${oe.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${T} + local_id.x;
            ${K?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${K.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${Q}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Q}(8);`}
            let scale = ${ye.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${B.getByIndices(`${B.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${t.blockSize/p};
            for (var i: u32 = 0; i < ${h}; i++) {
              ${Te()}
              let b_value = ${h===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${Q}>(${Array.from({length:4},(z,W)=>`${Q}(b_value_lower[${W}]), ${Q}(b_value_upper[${W}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${Q}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(z,W)=>`${`dot(a_data${W}, b_dequantized_values[${W}])`}`).join(" + ")};
              word_offset += ${8/p};
            }
            workgroupBarrier();
          }

          if (local_idx < ${w}) {
            var output_value: ${Ee.type.value} = ${Ee.type.value}(0);
            for (var b = 0u; b < ${x}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${Ee.setByIndices(`${Ee.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${p};${h};${x};${w}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:g,dataType:d}],dispatchGroup:{x:C},programUniforms:S}),getShaderSource:V}},t2=(e,t)=>{iC(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(sC(e.inputs,t)):e.compute(oC(e.inputs,t))},n2=e=>ke(e)}),aC,uC,lC,cC,dC,fC,pC,hC,r2,yV=H(()=>{"use strict";se(),pe(),_e(),aC=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},uC=(e,t,n)=>{let r="";for(let i=t-1;i>=0;--i)r+=`
            k = i32(${e.indicesGet("indices",i)}) - ${Y("uniforms.pads",i,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Y("uniforms.x_shape",i,t)})) {
              break;
            }
            offset += k * i32(${Y("uniforms.x_strides",i,t)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${r}
            value = x[offset];
          }
      `},lC=(e,t,n)=>{let r="";for(let i=t-1;i>=0;--i)r+=`
                k = i32(${e.indicesGet("indices",i)}) - ${Y("uniforms.pads",i,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Y("uniforms.x_shape",i,t)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Y("uniforms.x_shape",i,t)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Y("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},cC=(e,t,n)=>{let r="";for(let i=t-1;i>=0;--i)r+=`
                k = i32(${e.indicesGet("indices",i)}) - ${Y("uniforms.pads",i,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Y("uniforms.x_shape",i,t)})) {
                  k = i32(${Y("uniforms.x_shape",i,t)}) - 1;
                }
                offset += k * i32(${Y("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},dC=(e,t,n)=>{let r="";for(let i=t-1;i>=0;--i)r+=`
                k = i32(${e.indicesGet("indices",i)}) - ${Y("uniforms.pads",i,n)};
                if (k < 0)  {
                  k += i32(${Y("uniforms.x_shape",i,t)}]);
                }
                if (k >= i32(${Y("uniforms.x_shape",i,t)})) {
                  k -= i32(${Y("uniforms.x_shape",i,t)});
                }
                offset += k * i32(${Y("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},fC=(e,t,n)=>{switch(n.mode){case 0:return uC(e,t,n.pads.length);case 1:return lC(e,t,n.pads.length);case 2:return cC(e,t,n.pads.length);case 3:return dC(e,t,n.pads.length);default:throw new Error("Invalid mode")}},pC=(e,t)=>{let n=k.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,i=k.size(n),o=[{type:12,data:i},{type:6,data:t.pads}],s=e.length>=3&&e[2].data;t.mode===0&&o.push({type:s?e[2].dataType:1,data:t.value}),o.push(...J(e[0].dims,n));let a=["rank"],u=c=>{let d=Z("output",e[0].dataType,n.length),p=O("x",e[0].dataType,r.length),h=p.type.value,g=fC(d,r.length,t),y=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&y.push({name:"constant_value",type:s?h:"f32"}),`
            ${c.registerUniforms(y).declareVariables(p,d)}
            ${c.mainStart()}
            ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${d.offsetToIndices("global_idx")};

            var value = ${h}(0);
            ${g}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}${s}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(n)/64)},programUniforms:o}),getShaderSource:u}},hC=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,i=e[0].dims.length,o=new Int32Array(2*i).fill(0);if(e.length>=4){let a=e[3].getBigInt64Array();for(let u=0;u<a.length;u++)o[Number(a[u])]=Number(n[u]),o[Number(a[u])+i]=Number(n[u+a.length])}else n.forEach((a,u)=>o[Number(u)]=Number(a));let s=[];return o.forEach(a=>s.push(a)),{mode:t.mode,value:r,pads:s}}else return t},r2=(e,t)=>{aC(e.inputs);let n=hC(e.inputs,t);e.compute(pC(e.inputs,n),{inputs:[0]})}}),Hs,im,om,sm,am,mC,gC,um,lm,i2,o2,cm,s2,a2,dm,u2,l2,c2,d2,vV=H(()=>{"use strict";hn(),se(),pe(),_e(),Hs=e=>{if(Le.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},im=(e,t,n)=>{let r=t.format==="NHWC",i=e.dims.slice();r&&i.splice(1,0,i.pop());let o=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),a=t.strides.slice(),u=o?t.dilations.slice():[],c=t.pads.slice();Ql.adjustPoolAttributes(n,i,s,a,u,c);let d=Ql.computePoolOutputShape(n,i,a,u,s,c,t.autoPad),p=Object.assign({},t);o?Object.assign(p,{kernelShape:s,strides:a,pads:c,dilations:u,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:s,strides:a,pads:c,cacheKey:t.cacheKey});let h=d.slice();return h.push(h.splice(1,1)[0]),[p,r?h:d]},om=(e,t)=>{let n=t.format==="NHWC",r=k.size(e),i=k.size(t.kernelShape),o=[{type:12,data:r},{type:12,data:i}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let a=t.kernelShape[t.kernelShape.length-1],u=t.strides[t.strides.length-1],c=t.pads[t.pads.length/2-1],d=t.pads[t.pads.length-1],p=!!(c+d);o.push({type:12,data:a},{type:12,data:u},{type:12,data:c},{type:12,data:d}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let h=!1;if(t.kernelShape.length===2){let g=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],w=t.pads[t.pads.length/2-2],x=t.pads[t.pads.length-2];h=!!(w+x),o.push({type:12,data:g},{type:12,data:y},{type:12,data:w},{type:12,data:x}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[o,s,!0,p,h]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let a=k.computeStrides(t.kernelShape);o.push({type:12,data:a},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:"kernelStrides",type:"u32",length:a.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let u=t.pads.reduce((c,d)=>c+d);return[o,s,!!u,!1,!1]}},sm=(e,t,n,r,i,o,s,a,u,c,d,p)=>{let h=i.format==="NHWC",g=t.type.value,y=Z("output",t.type.tensor,r);if(i.kernelShape.length<=2){let w="",x="",I="",b=n-(h?2:1);if(d?w=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${b}] = indices[${b}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${b}] < 0 || xIndices[${b}]
                      >= uniforms.x_shape[${b}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${o}
                }`:w=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${b}] = indices[${b}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${o}
                }`,i.kernelShape.length===2){let T=n-(h?3:2);p?x=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:x=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                `,I=`
              }
            `}return`
            ${e.registerUniforms(u).declareVariables(t,y)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var value = ${g}(${a});
              var pad = 0;
              ${x}
              ${w}
              ${I}
              ${s}

              output[global_idx] = value;
            }`}else{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let w=i.kernelShape.length,x=i.pads.length,I="";return c?I=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${o}
              }`:I=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${o}
            `,`
            ${e.registerUniforms(u).declareVariables(t,y)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var offsets: array<u32, ${w}>;

              var value = ${g}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${w-1}u; j++) {
                  offsets[j] = offset / ${Y("uniforms.kernelStrides","j",w)};
                  offset -= offsets[j] * ${Y("uniforms.kernelStrides","j",w)};
                }
                offsets[${w-1}] = offset;

                isPad = false;
                for (var j = ${n-w}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${Y("uniforms.strides",`j - ${n-w}u`,w)}
                    + offsets[j - ${n-w}u] - ${Y("uniforms.pads","j - 2u",x)};
                  ${I}
              }
              ${s}

              output[global_idx] = value;
            }`}},am=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,mC=e=>`${am(e)};${e.countIncludePad}`,gC=e=>`${am(e)};${e.storageOrder};${e.dilations}`,um=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),lm=(e,t,n,r)=>{let[i,o]=im(t,r,n),s=O("x",t.dataType,t.dims.length),a=s.type.value,u="value += x_val;",c="";i.countIncludePad?c+=`value /= ${a}(uniforms.kernelSize);`:c+=`value /= ${a}(i32(uniforms.kernelSize) - pad);`;let[d,p,h,g,y]=om(o,i);d.push(...J(t.dims,o));let w=["rank"];return{name:e,shaderCache:{hint:`${r.cacheKey};${h};${g};${y}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(o)/64)},programUniforms:d}),getShaderSource:x=>sm(x,s,t.dims.length,o.length,i,u,c,0,p,h,g,y)}},i2=e=>{let t=e.count_include_pad!==0,n=um(e);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:mC(r)}},o2=(e,t)=>{Hs(e.inputs),e.compute(lm("AveragePool",e.inputs[0],!1,t))},cm={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},s2=e=>{let t=e.format;return{format:t,...cm,cacheKey:t}},a2=(e,t)=>{Hs(e.inputs),e.compute(lm("GlobalAveragePool",e.inputs[0],!0,t))},dm=(e,t,n,r)=>{let[i,o]=im(t,r,n),s=`
      value = max(x_val, value);
    `,a="",u=O("x",t.dataType,t.dims.length),c=["rank"],[d,p,h,g,y]=om(o,i);return d.push(...J(t.dims,o)),{name:e,shaderCache:{hint:`${r.cacheKey};${h};${g};${y}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(o)/64)},programUniforms:d}),getShaderSource:w=>sm(w,u,t.dims.length,o.length,i,s,a,t.dataType===10?-65504:-1e5,p,h,g,y)}},u2=(e,t)=>{Hs(e.inputs),e.compute(dm("MaxPool",e.inputs[0],!1,t))},l2=e=>{let t=e.storage_order,n=e.dilations,r=um(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:n,...r,cacheKey:""};return{...i,cacheKey:gC(i)}},c2=e=>{let t=e.format;return{format:t,...cm,cacheKey:t}},d2=(e,t)=>{Hs(e.inputs),e.compute(dm("GlobalMaxPool",e.inputs[0],!0,t))}}),yC,vC,f2,p2,_V=H(()=>{"use strict";se(),pe(),Qe(),_e(),yC=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((n,r)=>n===e[2].dims[r]).reduce((n,r)=>n&&r,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((i,o)=>o===t.axis||i===e[0].dims[o]).reduce((i,o)=>i&&o,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},vC=(e,t)=>{let n=k.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,i=r===3,o=e[0].dims,s=e[1].dataType,a=k.size(o),u=r===3||r===2,c=u?[Math.ceil(k.size(e[0].dims)/4)]:e[0].dims,d=e[1].dims,p=e.length>2?e[2]:void 0,h=p?u?[Math.ceil(k.size(p.dims)/4)]:p.dims:void 0,g=d.length===0||d.length===1&&d[0]===1,y=g===!1&&d.length===1,w=We(a),x=g&&(!u||w===4),I=x?w:1,b=x&&!u?w:1,T=O("input",u?12:r,c.length,b),C=O("scale",s,d.length),S=p?O("zero_point",u?12:r,h.length):void 0,$=Z("output",s,o.length,I),M=[T,C];S&&M.push(S);let L=[c,d];p&&L.push(h);let V=[{type:12,data:a/I},{type:12,data:n},{type:12,data:t.blockSize},...J(...L,o)],G=X=>{let oe=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${X.registerUniforms(oe).declareVariables(...M,$)}
      ${X.mainStart()}
          ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${$.offsetToIndices("global_idx")};

          // Set input x
          ${u?`
            let input = ${T.getByOffset("global_idx / 4")};
            let x_vec = ${i?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${I===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${T.getByOffset("global_idx")};`};

          // Set scale input
          ${g?`let scale_value= ${C.getByOffset("0")}`:y?`
            let scale_index = ${$.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${C.getByOffset("scale_index")};`:`
            var scale_indices: ${C.type.indices} = output_indices;
            let index = ${C.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${C.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${C.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${S?g?u?`
                let zero_point_input = ${S.getByOffset("0")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${S.getByOffset("0")}`:y?u?`
                let zero_point_index = ${$.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${S.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${$.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${S.getByOffset("zero_point_index")};`:u?`
                let zero_point_offset = ${C.indicesToOffset("scale_indices")};
                let zero_point_input = ${S.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${S.getByIndices("scale_indices")};`:`let zero_point_value = ${u?i?"i32":"u32":T.type.value}(0);`};
      // Compute and write output
      ${$.setByOffset("global_idx",`${$.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:S?["rank","rank","rank"]:["rank","rank"]},getShaderSource:G,getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(a/I/64),y:1,z:1},programUniforms:V})}},f2=(e,t)=>{yC(e.inputs,t),e.compute(vC(e.inputs,t))},p2=e=>ke({axis:e.axis,blockSize:e.blockSize})}),_C,wC,h2,wV=H(()=>{"use strict";hn(),se(),_e(),_C=(e,t,n)=>{let r=e===t,i=e<t&&n<0,o=e>t&&n>0;if(r||i||o)throw new Error("Range these inputs' contents are invalid.")},wC=(e,t,n,r)=>{let i=Math.abs(Math.ceil((t-e)/n)),o=[i],s=i,a=[{type:12,data:s},{type:r,data:e},{type:r,data:n},...J(o)],u=c=>{let d=Z("output",r,o.length),p=d.type.value,h=[{name:"outputSize",type:"u32"},{name:"start",type:p},{name:"delta",type:p}];return`
        ${c.registerUniforms(h).declareVariables(d)}
        ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${p}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:u,getRunData:()=>({outputs:[{dims:o,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:a})}},h2=e=>{let t=0,n=0,r=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),Le.webgpu.validateInputContent&&_C(t,n,r),e.compute(wC(t,n,r,e.inputs[0].dataType),{inputs:[]})}}),bC,IC,m2,g2,bV=H(()=>{"use strict";se(),pe(),Qe(),_e(),bC=(e,t,n,r)=>{if(e!=="none"&&r!=="i32"&&r!=="u32"&&r!=="f32")throw new Error(`Input ${r} is not supported with reduction ${e}.`);let i=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,o=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(e){case"none":return`${t}=${n};`;case"add":return r==="i32"||r==="u32"?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`
              ${i}bitcast<${r}>(oldValue) + (${n})${o}`;case"max":return r==="i32"||r==="u32"?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`
                ${i}max(bitcast<f32>(oldValue), (${n}))${o}`;case"min":return r==="i32"||r==="u32"?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${i}min(bitcast<${r}>(oldValue), (${n}))${o}`;case"mul":return`${i}(bitcast<${r}>(oldValue) * (${n}))${o}`;default:throw new Error(`Reduction ${e} is not supported.`)}},IC=(e,t)=>{let n=e[0].dims,r=e[1].dims,i=n,o=1,s=Math.ceil(k.size(r)/o),a=r[r.length-1],u=k.sizeFromDimension(n,a),c=[{type:12,data:s},{type:12,data:a},{type:12,data:u},...J(e[1].dims,e[2].dims,i)],d=p=>{let h=O("indices",e[1].dataType,e[1].dims.length),g=O("updates",e[2].dataType,e[2].dims.length,o),y=t.reduction!=="none"&&t.reduction!==""?qD("output",e[0].dataType,i.length):Z("output",e[0].dataType,i.length,o);return`
      ${p.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(h,g,y)}
      ${p.mainStart()}
        ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${t.reduction==="none"}) {
    let n = ${k.size(r)};
    for (var i = 0; i < n; i = i + 1) {
      for (var j = i + 1; j < n; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  if (${t.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    indices_start = 0u;
  }
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${e[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${bC(t.reduction,"output[data_offset + i]","value",y.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}),getShaderSource:d}},m2=e=>ke({reduction:e.reduction}),g2=(e,t)=>{e.compute(IC(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),xC,EC,TC,fm,CC,DC,SC,$C,MC,NC,kC,AC,pm,RC,OC,PC,LC,FC,y2,v2,IV=H(()=>{"use strict";se(),pe(),Qe(),_e(),xC=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},EC=(e,t,n)=>{t.every(i=>i>=0&&i<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let r=new Array(n).fill(1);return t.forEach((i,o)=>r[i]=e[o]),r},TC=(e,t,n,r,i,o)=>{let[s,a,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],c=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(d=>o.push(d));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&e.length>a&&e[a].dims.length===1&&e[a].dims[0]>0){if(e[a].getFloat32Array().forEach(d=>r.push(d)),r.length!==0&&r.length!==c&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");xC(r,t),t.axes.length>0&&EC(r,t.axes,c).forEach((d,p)=>r[p]=d)}if(u>0&&e.length>u&&e[u].dims.length===1&&e[u].dims[0]>0&&(e[u].getBigInt64Array().forEach(d=>i.push(Number(d))),i.length!==0&&i.length!==c&&n>=18&&i.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(i.length!==0&&i.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof i<"u"&&r.length>0&&i.length>c)throw new Error("Resize requires only of scales or sizes to be specified")},fm=(e,t,n,r)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${e}) * (${t});
  let whole = ${r}(big / (${n}));
  let fract = ${r}(big % (${n})) / ${r}(${n});
  return whole + fract;
`,CC=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${t}(xResized) / ${t}(xScale);
          } else {
            ${fm("xResized","lengthOriginal","lengthResized",t)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${fm("xResized","lengthOriginal - 1","lengthResized - 1",t)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +
                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /
                        ${t}(lengthResized - 1);
                  } else {
                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);
                  const adjustment = ${t}(lengthResized) / outputWidth;
                  const center = ${t}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",DC=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",SC=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),i=e.length===0?r:e.slice();return t.length>0?(t.forEach((o,s)=>{r[o]=i[s],r[s+n]=i[t.length+s]}),r):i},$C=(e,t,n,r)=>{let i=[];if(n.length>0)if(r.length>0){if(e.forEach(o=>i.push(o)),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach((o,s)=>i[o]=n[s])}else n.forEach(o=>i.push(o));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((o,s)=>Math.round(o*t[s]))}return i},MC=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(o=>t[o]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(o=>t[o]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=e.slice();return n.axes.length>0?(n.axes.forEach(o=>t[o]=r),n.axes.forEach(o=>i[o]=Math.round(e[o]*t[o]))):(t.fill(r,0,t.length),i.forEach((o,s)=>i[s]=Math.round(o*t[s]))),i},NC=(e,t,n,r,i)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {
      var original_indices: array<${e.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${Y("uniforms.scales","i",r)};
        var roi_low = ${Y("uniforms.roi","i",i)};
        var roi_hi = ${Y("uniforms.roi",`i + ${t.length}`,i)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${Y("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${Y("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,kC=(e,t,n,r,i,o,s)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Y("uniforms.scales","i",i)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Y("uniforms.roi","i",o)};
          var roi_hi = ${Y("uniforms.roi",`i + ${n.length}`,o)};
          var input_shape_i = ${Y("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${Y("uniforms.output_shape","i",r.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,AC=(e,t)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Y("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,pm=(e,t,n,r)=>e.rank>r?`
    ${e.indicesSet("input_indices",t,"channel")};
    ${e.indicesSet("input_indices",n,"batch")};
`:"",RC=(e,t,n,r,i)=>{let[o,s,a,u]=n.length===2?[-1,0,1,-1]:[0,2,3,1],c=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${c} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",s,`max(0, min(row, ${n[s]} - 1))`)};
      ${e.indicesSet("input_indices",a,`max(0, min(col, ${n[a]} - 1))`)};
      ${pm(e,u,o,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${c} = originalIndices[${s}];
      var col:${c} = originalIndices[${a}];
      ${r?`if (row < 0 || row > (${n[s]} - 1) || col < 0 || col > (${n[a]} - 1)) {
        return ${i};
      }`:""};
      row = max(0, min(row, ${n[s]} - 1));
      col = max(0, min(col, ${n[a]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${o}])`:"0"};
      var x11: ${c} = getInputValue(batch, channel, row1, col1);
      var x12: ${c} = getInputValue(batch, channel, row1, col2);
      var x21: ${c} = getInputValue(batch, channel, row2, col1);
      var x22: ${c} = getInputValue(batch, channel, row2, col2);
      var dx1: ${c} = abs(row - ${c}(row1));
      var dx2: ${c} = abs(${c}(row2) - row);
      var dy1: ${c} = abs(col - ${c}(col1));
      var dy2: ${c} = abs(${c}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},OC=(e,t,n,r,i,o,s,a,u,c)=>{let d=n.length===2,p=!0,[h,g]=d?[0,1]:p?[2,3]:[1,2],y=e.type.value,w=x=>{let I=x===h?"row":"col";return`
      fn ${I}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${y} {
        var output_index = ${t.indicesGet("output_indices",x)};
        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[x]},
        ${r[x]}, ${n[x]}, ${o[x]}, ${o[x]} + ${n.length});
        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${n[x]} - 1))) {
          return ${u};
        }
        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${I}: ${y} = originalIdx + ${y}(i);
          if (${I} < 0 || ${I} >= ${n[x]}) {
            ${c?`coefs[i + 1] = 0.0;
                        continue;`:a?`return ${u};`:`${I} = max(0, min(${I}, ${n[x]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",x,`u32(${I})`)};
          data[i + 1] = ${x===h?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${w(h)};
    ${w(g)};
  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {
    var absS = abs(s);
    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${y} = 1.0 - absS;
    var twoMinusAbsS: ${y} = 2.0 - absS;
    var onePlusAbsS: ${y} = 1.0 + absS;
    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};
    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;
    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {
    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},PC=(e,t,n,r,i)=>{let[o,s,a,u,c]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",s,`max(0, min(depth, ${n[s]} - 1))`)};
      ${e.indicesSet("input_indices",a,`max(0, min(height, ${n[a]} - 1))`)};
      ${e.indicesSet("input_indices",u,`max(0, min(width, ${n[u]} - 1))`)};
      ${pm(e,c,o,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${d} = originalIndices[${s}];
      var height:${d} = originalIndices[${a}];
      var width:${d} = originalIndices[${u}];
      ${r?`if (depth < 0 || depth > (${n[s]} - 1) || height < 0 || height > (${n[a]} - 1) || width < 0 || (width > ${n[u]} - 1)) {
      return ${i};
        }`:""};

    depth = max(0, min(depth, ${n[s]} - 1));
      height = max(0, min(height, ${n[a]} - 1));
      width = max(0, min(width, ${n[u]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${c}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${o}])`:"0"};

      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${d} = abs(depth - ${d}(depth1));
      var dx2: ${d} = abs(${d}(depth2) - depth);
      var dy1: ${d} = abs(height - ${d}(height1));
      var dy2: ${d} = abs(${d}(height2) - height);
      var dz1: ${d} = abs(width - ${d}(width1));
      var dz2: ${d} = abs(${d}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},LC=(e,t,n,r,i,o)=>{let s=e.dims,a=SC(o,t.axes,s.length),u=$C(s,r,i,t.axes),c=r.slice();r.length===0&&(c=s.map((b,T)=>b===0?1:u[T]/b),t.keepAspectRatioPolicy!=="stretch"&&(u=MC(s,c,t)));let d=Z("output",e.dataType,u.length),p=O("input",e.dataType,s.length),h=k.size(u),g=s.length===u.length&&s.every((b,T)=>b===u[T]),y=t.coordinateTransformMode==="tf_crop_and_resize",w=t.extrapolationValue,x=p.type.value,I=b=>`
      ${g?"":`
      ${CC(t.coordinateTransformMode,x)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${AC(p,s)};
              ${DC(t.nearestMode,n,x)};
              ${kC(p,d,s,u,c.length,a.length,y)};
              `;case"linear":return`
              ${NC(d,s,u,c.length,a.length)};
              ${(()=>{if(s.length===2||s.length===4)return`${RC(p,d,s,y,w)}`;if(s.length===3||s.length===5)return`${PC(p,d,s,y,w)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(s.length===2||s.length===4)return`${OC(p,d,s,u,c,a,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${b.registerUniform("output_size","u32").registerUniform("scales","f32",c.length).registerUniform("roi","f32",a.length).declareVariables(p,d)}
      ${b.mainStart()}
        ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${g?"output[global_idx] = input[global_idx];":`
        let output_indices = ${d.offsetToIndices("global_idx")};
        var input_indices: ${p.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${p.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${s.length===2||s.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${c.length>0?t.mode==="cubic"?c:c.length:""}|${i.length>0?i:""}|${a.length>0?a:""}|${g}|${t.mode==="nearest"?s.length:s}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:c},{type:1,data:a},...J(s,u)]})}},FC=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},y2=(e,t)=>{let n=[],r=[],i=[],o=FC(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");TC(e.inputs,t,o,n,r,i),e.compute(LC(e.inputs[0],t,o,n,r,i),{inputs:[0]})},v2=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,i=e.cubicCoeffA,o=e.excludeOutside!==0,s=e.extrapolationValue,a=e.keepAspectRatioPolicy,u=e.mode,c=e.nearestMode===""?"simple":e.nearestMode;return ke({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:i,excludeOutside:o,extrapolationValue:s,keepAspectRatioPolicy:a,mode:u,nearestMode:c})}}),zC,BC,_2,xV=H(()=>{"use strict";se(),pe(),Qe(),_e(),zC=(e,t)=>{let[n,r,i,o]=e,{numHeads:s,rotaryEmbeddingDim:a}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!k.areEqual(r.dims,[])&&!k.areEqual(r.dims,[1])&&r.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(!k.areEqual(i.dims,o.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(a>0&&s===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let u=n.dims[0],c=n.dims[n.dims.length-2],d=i.dims[0],p=k.sizeFromDimension(n.dims,1)/c,h=a===0?i.dims[1]*2:p/s;if(a>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(r.dims.length===2){if(u!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(c!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(h/2!==i.dims[1]&&a/2!==i.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(c>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},BC=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:i,scale:o}=t,s=e[0].dims[0],a=k.sizeFromDimension(e[0].dims,1),u=e[0].dims[e[0].dims.length-2],c=a/u,d=e[2].dims[1],p=i===0?d*2:c/r,h=new Array(s,u,c/p,p-d),g=k.computeStrides(h),y=[{type:1,data:o},{type:12,data:h},{type:12,data:g},...e[0].dims.length===3?new Array({type:12,data:[a,c,p,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[a,p,u*p,1]}):[],...J(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],w=x=>{let I=O("input",e[0].dataType,e[0].dims.length),b=O("position_ids",e[1].dataType,e[1].dims.length),T=O("cos_cache",e[2].dataType,e[2].dims.length),C=O("sin_cache",e[3].dataType,e[3].dims.length),S=Z("output",e[0].dataType,e[0].dims.length);return x.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:g.length},{name:"input_output_strides",type:"u32",length:g.length}]),`
        ${x.declareVariables(I,b,T,C,S)}

        ${x.mainStart(_o)}
          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${b.broadcastedIndicesToOffset("bsnh.xy",Z("",b.type.tensor,2))};
            let position_id =
                u32(${b.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${I.getByOffset("i")} * ${T.get("position_id","bsnh[3]")} -
                ${I.getByOffset("j")} * ${C.get("position_id","bsnh[3]")};
            ${S.setByOffset("i","re")}
            let im = ${I.getByOffset("i")} * ${C.get("position_id","bsnh[3]")} +
                ${I.getByOffset("j")} * ${T.get("position_id","bsnh[3]")};
            ${S.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${S.setByOffset("k",I.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:ke({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:w,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(h)/_o)},programUniforms:y})}},_2=(e,t)=>{zC(e.inputs,t),e.compute(BC(e.inputs,t))}}),jC,VC,w2,EV=H(()=>{"use strict";se(),pe(),_e(),jC=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],o=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==o)throw new Error("Skip must have the same sequence length as input");if(r.dims.length!==1)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let s=e[3];if(s.dims.length!==1)throw new Error("Beta must be 1D");if(s.dims[s.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let s=e[4];if(s.dims.length!==1)throw new Error("Bias must be 1D");if(s.dims[s.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},VC=(e,t,n,r)=>{let i=t.simplified,o=e[0].dims,s=k.size(o),a=o,u=s,c=o.slice(-1)[0],d=r?o.slice(0,-1).concat(1):[],p=!i&&e.length>3,h=e.length>4,g=r&&n>1,y=r&&n>2,w=n>3,x=64,I=We(c),b=[{type:12,data:u},{type:12,data:I},{type:12,data:c},{type:1,data:t.epsilon}],T=S=>{let $=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],M=[O("x",e[0].dataType,e[0].dims,I),O("skip",e[1].dataType,e[1].dims,I),O("gamma",e[2].dataType,e[2].dims,I)];p&&M.push(O("beta",e[3].dataType,e[3].dims,I)),h&&M.push(O("bias",e[4].dataType,e[4].dims,I)),M.push(Z("output",e[0].dataType,a,I)),g&&M.push(Z("mean_output",1,d)),y&&M.push(Z("inv_std_output",1,d)),w&&M.push(Z("input_skip_bias_sum",e[0].dataType,a,I));let L=rt(e[0].dataType),V=rt(1,I);return`

      ${S.registerUniforms($).declareVariables(...M)}
      var<workgroup> sum_shared : array<${V}, ${x}>;
      var<workgroup> sum_squared_shared : array<${V}, ${x}>;

      ${S.mainStart([x,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${x};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${x};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${x-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${h?"bias[offset1d + i]":L+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${w?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${yo(L,I,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${x};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Ir("sum",I)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Ir("square_sum",I)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);
        ${g?"mean_output[global_idx] = mean;":""}
        ${y?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${i?"":`- ${L}(mean)`}) *
            ${L}(inv_std_dev) * gamma[offset1d + i]
            ${p?"+ beta[offset1d + i]":""};
        }
      }`},C=[{dims:a,dataType:e[0].dataType}];return n>1&&C.push({dims:d,dataType:1}),n>2&&C.push({dims:d,dataType:1}),n>3&&C.push({dims:o,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${I};${g};${y};${w}`,inputDependencies:e.map((S,$)=>"type")},getShaderSource:T,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(u/c)},programUniforms:b})}},w2=(e,t)=>{jC(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(VC(e.inputs,t,e.outputCount,!1),{outputs:n})}}),HC,Us,UC,hm,WC,qC,b2,I2,TV=H(()=>{"use strict";se(),pe(),Qe(),_e(),HC=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((n,r)=>{if(e[r+1].dataType!==6&&e[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},Us=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},UC=(e,t)=>{if(e.length>1){let n=Us(e,1),r=Us(e,2),i=Us(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),ke({starts:n,ends:r,axes:i})}else return t},hm=(e,t,n,r,i)=>{let o=e;return e<0&&(o+=n[r[t]]),i[t]<0?Math.max(0,Math.min(o,n[r[t]]-1)):Math.max(0,Math.min(o,n[r[t]]))},WC=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${Y("uniforms.input_shape","i",n.length)};
            let steps_i = ${Y("uniforms.steps","i",n.length)};
            let signs_i = ${Y("uniforms.signs","i",n.length)};
            let starts_i = ${Y("uniforms.starts","i",n.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,qC=(e,t)=>{let n=e[0].dims,r=k.size(n),i=t.axes.length>0?k.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],o=Us(e,4);o.forEach(I=>I!==0||(()=>{throw new Error("step cannot be 0")})),o.length===0&&(o=Array(i.length).fill(1));let s=t.starts.map((I,b)=>hm(I,b,n,i,o)),a=t.ends.map((I,b)=>hm(I,b,n,i,o));if(i.length!==s.length||i.length!==a.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==n.length)for(let I=0;I<n.length;++I)i.includes(I)||(s.splice(I,0,0),a.splice(I,0,n[I]),o.splice(I,0,1));let u=o.map(I=>Math.sign(I));o.forEach((I,b,T)=>{if(I<0){let C=(a[b]-s[b])/I,S=s[b],$=S+C*o[b];s[b]=$,a[b]=S,T[b]=-I}});let c=n.slice(0);i.forEach((I,b)=>{c[I]=Math.ceil((a[I]-s[I])/o[I])});let d={dims:c,dataType:e[0].dataType},p=Z("output",e[0].dataType,c.length),h=O("input",e[0].dataType,e[0].dims.length),g=k.size(c),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:s.length},{name:"signs",type:"i32",length:u.length},{name:"steps",type:"u32",length:o.length}],w=[{type:12,data:g},{type:12,data:s},{type:6,data:u},{type:12,data:o},...J(e[0].dims,c)],x=I=>`
      ${I.registerUniforms(y).declareVariables(h,p)}
        ${WC(h,p,n)}
        ${I.mainStart()}
          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${p.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${p.setByOffset("global_idx",h.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${u.length}_${s.length}_${o.length}`,inputDependencies:["rank"]},getShaderSource:x,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:w})}},b2=(e,t)=>{HC(e.inputs,t);let n=UC(e.inputs,t);e.compute(qC(e.inputs,n),{inputs:[0]})},I2=e=>{let t=e.starts,n=e.ends,r=e.axes;return ke({starts:t,ends:n,axes:r})}}),GC,KC,x2,E2,CV=H(()=>{"use strict";se(),pe(),Qe(),xr(),_e(),GC=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},KC=(e,t)=>{let n=e.inputs[0],r=n.dims,i=k.size(r),o=r.length,s=k.normalizeAxis(t.axis,o),a=s<r.length-1,u,c=[];a?(c=Array.from({length:o},(M,L)=>L),c[s]=o-1,c[o-1]=s,u=e.compute(zt(n,c),{inputs:[n],outputs:[-1]})[0]):u=n;let d=u.dims,p=d[o-1],h=i/p,g=We(p),y=p/g,w=64;h===1&&(w=256);let x=(M,L)=>L===4?`max(max(${M}.x, ${M}.y), max(${M}.z, ${M}.w))`:L===2?`max(${M}.x, ${M}.y)`:L===3?`max(max(${M}.x, ${M}.y), ${M}.z)`:M,I=O("x",u.dataType,u.dims,g),b=Z("result",u.dataType,u.dims,g),T=I.type.value,C=rt(u.dataType)==="f32"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,S=M=>`
      var<workgroup> rowMaxShared : ${T};
      var<workgroup> rowSumShared : ${T};
      var<workgroup> threadShared : array<${T}, ${w}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${M.registerUniform("packedCols","i32").declareVariables(I,b)}
      ${M.mainStart(w)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${w};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${C}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${T}(${x("threadShared[0]",g)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${T}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${T}(${Ir("threadShared[0]",g)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,$=e.compute({name:"Softmax",shaderCache:{hint:`${g};${w}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:d,dataType:u.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:y}]}),getShaderSource:S},{inputs:[u],outputs:[a?-1:0]})[0];a&&e.compute(zt($,c),{inputs:[$]})},x2=(e,t)=>{GC(e.inputs),KC(e,t)},E2=e=>ke({axis:e.axis})}),mm,QC,ZC,YC,T2,DV=H(()=>{"use strict";se(),pe(),_e(),mm=e=>Array.from(e.getBigInt64Array(),Number),QC=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(mm(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ZC=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},YC=(e,t)=>{let n=e[0].dims,r=t??mm(e[1]),i=ZC(n,r),o=k.size(i),s=e[0].dataType,a=O("input",s,n.length),u=Z("output",s,i.length),c=d=>`
      const inputShape = ${a.indices(...n)};
      ${d.registerUniform("output_size","u32").declareVariables(a,u)}
      ${d.mainStart()}
      ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${u.offsetToIndices("global_idx")};
      var input_indices: ${a.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${u.indicesGet("output_indices","i")}  % input_dim_i;

        ${a.indicesSet("input_indices","i","input_dim_value")}
      }
      ${u.setByOffset("global_idx",a.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},...J(e[0].dims,i)]}),getShaderSource:c}},T2=e=>{QC(e.inputs),e.compute(YC(e.inputs),{inputs:[0]})}}),JC,XC,C2,SV=H(()=>{"use strict";se(),pe(),_e(),JC=(e,t,n,r,i)=>{let o=Z("output_data",i,n.length,4),s=O("a_data",t[1].dataType,t[1].dims.length,4),a=O("b_data",t[2].dataType,t[2].dims.length,4),u=O("c_data",t[0].dataType,t[0].dims.length,4),c,d=(p,h,g)=>`select(${h}, ${p}, ${g})`;if(!r)c=o.setByOffset("global_idx",d(s.getByOffset("global_idx"),a.getByOffset("global_idx"),u.getByOffset("global_idx")));else{let p=(h,g,y="")=>{let w=`a_data[index_a${g}][component_a${g}]`,x=`b_data[index_b${g}][component_b${g}]`,I=`bool(c_data[index_c${g}] & (0xffu << (component_c${g} * 8)))`;return`
            let output_indices${g} = ${o.offsetToIndices(`global_idx * 4u + ${g}u`)};
            let offset_a${g} = ${s.broadcastedIndicesToOffset(`output_indices${g}`,o)};
            let offset_b${g} = ${a.broadcastedIndicesToOffset(`output_indices${g}`,o)};
            let offset_c${g} = ${u.broadcastedIndicesToOffset(`output_indices${g}`,o)};
            let index_a${g} = offset_a${g} / 4u;
            let index_b${g} = offset_b${g} / 4u;
            let index_c${g} = offset_c${g} / 4u;
            let component_a${g} = offset_a${g} % 4u;
            let component_b${g} = offset_b${g} % 4u;
            let component_c${g} = offset_c${g} % 4u;
            ${h}[${g}] = ${y}(${d(w,x,I)});
          `};i===9?c=`
            var data = vec4<u32>(0);
            ${p("data",0,"u32")}
            ${p("data",1,"u32")}
            ${p("data",2,"u32")}
            ${p("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:c=`
            ${p("output_data[global_idx]",0)}
            ${p("output_data[global_idx]",1)}
            ${p("output_data[global_idx]",2)}
            ${p("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(u,s,a,o)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${c}
      }`},XC=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,i=e[1].dataType,o=!(k.areEqual(t,n)&&k.areEqual(n,r)),s=t,a=k.size(t);if(o){let c=vo.calcShape(vo.calcShape(t,n,!1),r,!1);if(!c)throw new Error("Can't perform where op on the given tensors");s=c,a=k.size(s)}let u=Math.ceil(a/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:c=>JC(c,e,s,o,i),getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:[{type:12,data:u},...J(r,t,n,s)]})}},C2=e=>{e.compute(XC(e.inputs))}}),D2,$V=H(()=>{"use strict";Vj(),Jm(),Hj(),Uj(),Wj(),qj(),Gj(),Jj(),eV(),tV(),nV(),rV(),iV(),oV(),sV(),aV(),uV(),lV(),cV(),dV(),fV(),pV(),hV(),mV(),gV(),G$(),yV(),vV(),_V(),wV(),bV(),Ym(),IV(),xV(),EV(),TV(),CV(),Z$(),DV(),xr(),Xm(),SV(),D2=new Map([["Abs",[bS]],["Acos",[IS]],["Acosh",[xS]],["Add",[r$]],["ArgMax",[yS,Dm]],["ArgMin",[gS,Dm]],["Asin",[ES]],["Asinh",[TS]],["Atan",[CS]],["Atanh",[DS]],["Attention",[vS]],["AveragePool",[o2,i2]],["BatchNormalization",[_S]],["BiasAdd",[wS]],["BiasSplitGelu",[n$]],["Cast",[$S,SS]],["Ceil",[NS]],["Clip",[MS]],["Concat",[p$,h$]],["Conv",[Am,km]],["ConvTranspose",[E$,x$]],["Cos",[kS]],["Cosh",[AS]],["CumSum",[T$,C$]],["DepthToSpace",[D$,S$]],["DequantizeLinear",[f2,p2]],["Div",[i$]],["Einsum",[$$,M$]],["Elu",[RS,Qs]],["Equal",[o$]],["Erf",[OS]],["Exp",[PS]],["Expand",[N$]],["FastGelu",[k$]],["Floor",[LS]],["FusedConv",[Am,km]],["Gather",[R$,A$]],["GatherElements",[B$,z$]],["GatherBlockQuantized",[L$,F$]],["GatherND",[O$,P$]],["Gelu",[FS]],["Gemm",[V$,j$]],["GlobalAveragePool",[a2,s2]],["GlobalMaxPool",[d2,c2]],["Greater",[l$]],["GreaterOrEqual",[d$]],["GridSample",[H$,U$]],["GroupQueryAttention",[Y$]],["HardSigmoid",[qS,WS]],["InstanceNormalization",[J$]],["LayerNormalization",[X$]],["LeakyRelu",[zS,Qs]],["Less",[c$]],["LessOrEqual",[f$]],["Log",[e$]],["MatMul",[e2]],["MatMulNBits",[t2,n2]],["MaxPool",[u2,l2]],["Mul",[s$]],["MultiHeadAttention",[q$,W$]],["Neg",[jS]],["Not",[BS]],["Pad",[r2]],["Pow",[a$]],["QuickGelu",[t$,Qs]],["Range",[h2]],["Reciprocal",[VS]],["ReduceMin",[dS]],["ReduceMean",[sS]],["ReduceMax",[cS]],["ReduceSum",[pS]],["ReduceProd",[fS]],["ReduceL1",[aS]],["ReduceL2",[uS]],["ReduceLogSum",[mS]],["ReduceLogSumExp",[lS]],["ReduceSumSquare",[hS]],["Relu",[HS]],["Resize",[y2,v2]],["RotaryEmbedding",[_2]],["ScatterND",[g2,m2]],["Sigmoid",[US]],["Sin",[GS]],["Sinh",[KS]],["Slice",[b2,I2]],["SkipLayerNormalization",[w2]],["Split",[K$,Q$]],["Sqrt",[QS]],["Softmax",[x2,E2]],["Sub",[u$]],["Tan",[ZS]],["Tanh",[YS]],["ThresholdedRelu",[XS,Qs]],["Tile",[T2]],["Transpose",[KD,QD]],["Where",[C2]]])}),S2,MV=H(()=>{"use strict";hn(),Zn(),_e(),S2=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,i){On(e.programInfo.name);let o=this.backend.device,s=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let a=[];for(let c of t)a.push({binding:a.length,resource:{buffer:c.buffer}});for(let c of n)a.push({binding:a.length,resource:{buffer:c.buffer}});i&&a.push({binding:a.length,resource:i});let u=o.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:a,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let c={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:u,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(c)}s.setPipeline(e.computePipeline),s.setBindGroup(0,u),s.dispatchWorkgroups(...r),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),pn(e.programInfo.name)}dispose(){}build(e,t){On(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"},{feature:"subgroups-f16",extension:"subgroups_f16"}].forEach(c=>{n.features.has(c.feature)&&r.push(`enable ${c.extension};`)});let i=GD(t,this.backend.device.limits),o=e.getShaderSource(i),s=`${r.join(`
`)}
${i.additionalImplementations}
${o}`,a=n.createShaderModule({code:s,label:e.name});Ce("verbose",()=>`[WebGPU] ${e.name} shader code: ${s}`);let u=n.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:e.name});return pn(e.name),{programInfo:e,computePipeline:u,uniformVariablesInfo:i.variablesInfo}}normalizeDispatchGroupSize(e){let t=typeof e=="number"?e:e.x,n=typeof e=="number"?1:e.y||1,r=typeof e=="number"?1:e.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=i&&n<=i&&r<=i)return[t,n,r];let o=t*n*r,s=Math.ceil(Math.sqrt(o));if(s>i){if(s=Math.ceil(Math.cbrt(o)),s>i)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[s,s,s]}else return[s,s,1]}}}),eD,tD,nD,rD,$2,NV=H(()=>{"use strict";hn(),se(),Zn(),jD(),Bj(),$V(),MV(),eD=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let i=e[r].dataType;switch(t[r]){case"none":{n.push("");break}case"type":{n.push(`${i}`);break}case"rank":{let o=e[r].dims.length;n.push(`${i};${o}`);break}case"dims":{let o=e[r].dims.join(",");n.push(`${i};${o}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},tD=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${eD(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},nD=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},rD=class{constructor(e){this.subgroupsSupported=e.features.has("subgroups"),this.subgroupsF16Supported=e.features.has("subgroups");let t=e.limits;!this.subgroupsSupported||!t.minSubgroupSize||!t.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[t.minSubgroupSize,t.maxSubgroupSize]}},$2=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},i=o=>t.features.has(o)&&n.push(o)&&!0;i("chromium-experimental-timestamp-query-inside-passes")||i("timestamp-query"),i("shader-f16"),i("subgroups")&&i("subgroups-f16"),this.device=await t.requestDevice(r),this.deviceInfo=new rD(this.device),this.adapterInfo=new nD(t.info||await t.requestAdapterInfo()),this.gpuDataManager=VD(this),this.programManager=new S2(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Gm(e.logLevel,!!e.debug),this.device.onuncapturederror=o=>{o.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${o.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;On(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let r=0;r<t.length/2;r++){let i=n[r],o=i.kernelId,s=this.kernels.get(o),a=s.kernelType,u=s.kernelName,c=i.programName,d=i.inputTensorViews,p=i.outputTensorViews,h=t[r*2],g=t[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=h);let y=Number(h-this.queryTimeBase),w=Number(g-this.queryTimeBase);if(!Number.isSafeInteger(y)||!Number.isSafeInteger(w))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:d.map(x=>({dims:x.dims,dataType:oi(x.dataType)})),outputsMetadata:p.map(x=>({dims:x.dims,dataType:oi(x.dataType)})),kernelId:o,kernelType:a,kernelName:u,programName:c,startTime:y,endTime:w});else{let x="";d.forEach((b,T)=>{x+=`input[${T}]: [${b.dims}] | ${oi(b.dataType)}, `});let I="";p.forEach((b,T)=>{I+=`output[${T}]: [${b.dims}] | ${oi(b.dataType)}, `}),console.log(`[profiling] kernel "${o}|${a}|${u}|${c}" ${x}${I}execution time: ${w-y} ns`)}ql("GPU",`${c}::${h}::${g}`)}e.unmap(),this.pendingQueries.delete(e)}),pn()}run(e,t,n,r,i,o){On(e.name);let s=[];for(let b=0;b<t.length;++b){let T=t[b].data;if(T===0)continue;let C=this.gpuDataManager.get(T);if(!C)throw new Error(`no GPU data for input: ${T}`);s.push(C)}let{outputs:a,dispatchGroup:u,programUniforms:c}=e.getRunData(t),d=n.length===0?a.map((b,T)=>T):n;if(d.length!==a.length)throw new Error(`Output size ${d.length} must be equal to ${a.length}.`);let p=[],h=[];for(let b=0;b<a.length;++b){if(!Number.isInteger(d[b])||d[b]<-3||d[b]>=o)throw new Error(`Invalid output index: ${d[b]}`);if(d[b]===-3)continue;let T=d[b]===-1,C=d[b]===-2,S=T||C?i(a[b].dataType,a[b].dims):r(d[b],a[b].dataType,a[b].dims);if(p.push(S),S.data===0)continue;let $=this.gpuDataManager.get(S.data);if(!$)throw new Error(`no GPU data for output: ${S.data}`);if(T&&this.temporaryData.push($),C){let M=this.kernelPersistentData.get(this.currentKernelId);M||(M=[],this.kernelPersistentData.set(this.currentKernelId,M)),M.push($)}h.push($)}if(s.length!==t.length||h.length!==p.length){if(h.length===0)return pn(e.name),p;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let g;if(c){let b=0,T=[];c.forEach(M=>{let L=typeof M.data=="number"?[M.data]:M.data;if(L.length===0)return;let V=M.type===10?2:4,G,X;M.type===10?(X=L.length>4?16:L.length>2?8:L.length*V,G=L.length>4?16:V*L.length):(X=L.length<=2?L.length*V:16,G=16),b=Math.ceil(b/X)*X,T.push(b);let oe=M.type===10?8:4;b+=L.length>4?Math.ceil(L.length/oe)*G:L.length*V});let C=16;b=Math.ceil(b/C)*C;let S=new ArrayBuffer(b);c.forEach((M,L)=>{let V=T[L],G=typeof M.data=="number"?[M.data]:M.data;if(M.type===6)new Int32Array(S,V,G.length).set(G);else if(M.type===12)new Uint32Array(S,V,G.length).set(G);else if(M.type===10)new Uint16Array(S,V,G.length).set(G);else if(M.type===1)new Float32Array(S,V,G.length).set(G);else throw new Error(`Unsupported uniform type: ${oi(M.type)}`)});let $=this.gpuDataManager.create(b,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer($.buffer,0,S,0,b),this.gpuDataManager.release($.id),g={offset:0,size:b,buffer:$.buffer}}let y=this.programManager.normalizeDispatchGroupSize(u),w=y[1]===1&&y[2]===1,x=tD(e,t,w),I=this.programManager.getArtifact(x);if(I||(I=this.programManager.build(e,y),this.programManager.setArtifact(x,I),Ce("info",()=>`[artifact] key: ${x}, programName: ${e.name}`)),c&&I.uniformVariablesInfo){if(c.length!==I.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${I.uniformVariablesInfo.length}, got ${c.length} in program "${I.programInfo.name}".`);for(let b=0;b<c.length;b++){let T=c[b],C=T.type,S=typeof T.data=="number"?1:T.data.length,[$,M]=I.uniformVariablesInfo[b];if(C!==$||S!==M)throw new Error(`Uniform variable ${b} mismatch: expect type ${$} with size ${M}, got type ${C} with size ${S} in program "${I.programInfo.name}".`)}}if(Ce("info",()=>`[ProgramManager] run "${e.name}" (key=${x}) with ${y[0]}x${y[1]}x${y[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let b={kernelId:this.currentKernelId,programName:I.programInfo.name,inputTensorViews:t,outputTensorViews:p};this.pendingKernels.push(b),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(b)}return this.programManager.run(I,s,h,y,g),pn(e.name),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let i=D2.get(e);if(!i)throw new Error(`kernel not implemented: ${e}`);let o={kernelType:e,kernelName:r,kernelEntry:i[0],attributes:[i[1],n]};this.kernels.set(t,o)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let n of t)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let i=r.kernelType,o=r.kernelName,s=r.kernelEntry,a=r.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${i}] ${o}" is not allowed to be called recursively`);this.currentKernelId=e,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Ce("info",()=>`[WebGPU] Start to run kernel "[${i}] ${o}"...`);let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),s(t,a[1]),0}catch(c){return n.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${o}" failed. ${c}`)),1}finally{u&&n.push(this.device.popErrorScope().then(c=>c?`GPU validation error for kernel "[${i}] ${o}": ${c.message}`:null));for(let c of this.temporaryData)this.gpuDataManager.release(c.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let i=this.sessionExternalDataMapping.get(e);i||(i=new Map,this.sessionExternalDataMapping.set(e,i));let o=i.get(t),s=this.gpuDataManager.registerExternalBuffer(n,r,o);return i.set(t,[s,n]),s}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Em(this,e,t);return Km(r.buffer,n)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ce("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ce("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ce("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let i=this.getComputePassEncoder(),o=e[r];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(o.computePipeline),i.setBindGroup(0,o.bindGroup),i.dispatchWorkgroups(...o.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),iD,gm,oD,ym,vm,_m,sD,M2,kV=H(()=>{"use strict";Zn(),iD=1,gm=()=>iD++,oD=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),ym=(e,t)=>{let n=oD.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce((r,i)=>r*i)*n/8):0},vm=class{constructor(e){this.sessionId=e.sessionId,this.mlContext=e.context,this.mlTensor=e.tensor,this.dataType=e.dataType,this.tensorShape=e.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return ym(this.dataType,this.tensorShape)}destroy(){Ce("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((r,i)=>r===n[i])}},_m=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,r){let i=this.tensorManager.getMLContext(e);if(this.wrapper){if(this.wrapper.canReuseTensor(i,t,n))return this.wrapper.tensor;if(r){if(this.wrapper.byteLength!==ym(t,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let o=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,n,o,!0,!0),r&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){if(this.wrapper)if(e.byteLength===this.wrapper.byteLength){this.wrapper.write(e);return}else Ce("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(e){if(this.activeUpload)if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},sD=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=gm();return this.tensorTrackersById.set(e,new _m(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r,i){Ce("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${r}, copyOld: ${i}}`);let o=this.tensorTrackersById.get(t);if(!o)throw new Error("Tensor not found.");return o.ensureTensor(e,n,r,i)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Ce("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,r){let i=this.getMLContext(e),o=gm(),s=new vm({sessionId:e,context:i,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(o,new _m(this,s)),this.externalTensors.add(s),o}async getCachedTensor(e,t,n,r,i,o){let s=this.getMLContext(e);for(let[u,c]of this.freeTensors.entries())if(c.canReuseTensor(s,t,n)){Ce("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${n}}`);let d=this.freeTensors.splice(u,1)[0];return d.sessionId=e,d}Ce("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${n}}`);let a=await s.createTensor({dataType:t,shape:n,dimensions:n,usage:r,writable:i,readable:o});return new vm({sessionId:e,context:s,tensor:a,dataType:t,shape:n})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},M2=(...e)=>new sD(...e)}),zl,aD,N2,AV=H(()=>{"use strict";se(),ci(),jD(),kV(),Zn(),zl=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),aD=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every((i,o)=>i===r[o]&&e[i]===t[i])},N2=class{constructor(e){this.tensorManager=M2(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Gm(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){Ce("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){Ce("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let n of t)Ce("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let n=this.mlContextCache.findIndex(r=>r.gpuDevice===e);if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:r}),r}}else if(e===void 0){let n=this.mlContextCache.findIndex(r=>r.options===void 0&&r.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:r}),r}}let t=this.mlContextCache.findIndex(n=>aD(n.options,e));if(t!==-1)return this.mlContextCache[t].mlContext;{let n=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:n}),n}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),n.size===0){this.sessionIdsByMLContext.delete(t);let r=this.mlContextCache.findIndex(i=>i.mlContext===t);r!==-1&&this.mlContextCache.splice(r,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Ce("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r,i){let o=zl.get(n);if(!o)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,o,r,i)}async createTemporaryTensor(e,t,n){Ce("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let r=zl.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let i=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,i,r,n,!1);let o=this.temporarySessionTensorIds.get(e);return o?o.push(i):this.temporarySessionTensorIds.set(e,[i]),i}uploadTensor(e,t){if(!nt().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Ce("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return Km(n,t)}}registerMLTensor(e,t,n,r){let i=zl.get(n);if(!i)throw new Error(`Unsupported ONNX data type: ${n}`);let o=this.tensorManager.registerTensor(e,t,i,r);return Ce("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${i}, dimensions: ${r}} -> {tensorId: ${o}}`),o}registerMLConstant(e,t,n,r,i,o){if(!o)throw new Error("External mounted files are not available.");let s=e;e.startsWith("./")&&(s=e.substring(2));let a=o.get(s);if(!a)throw new Error(`File with name ${s} not found in preloaded files.`);if(t+n>a.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u=a.slice(t,t+n).buffer,c;switch(i.dataType){case"float32":c=new Float32Array(u);break;case"float16":c=new Uint16Array(u);break;case"int32":c=new Int32Array(u);break;case"uint32":c=new Uint32Array(u);break;case"int64":c=new BigInt64Array(u);break;case"uint64":c=new BigUint64Array(u);break;case"int8":c=new Int8Array(u);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return Ce("verbose",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`),r.constant(i,c)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return n?n.includes(t):!1}flush(){}}}),k2={};Xs(k2,{init:()=>A2});var Bl,uD,A2,RV=H(()=>{"use strict";se(),NV(),Zn(),pe(),AV(),Bl=class R2{constructor(t,n,r,i){this.module=t,this.dataType=n,this.data=r,this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error("Invalid new shape");return new R2(this.module,this.dataType,this.data,t)}},uD=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo,this.deviceInfo=t.deviceInfo;let r=e.PTR_SIZE,i=n/e.PTR_SIZE,o=r===4?"i32":"i64";this.opKernelContext=Number(e.getValue(r*i++,o));let s=Number(e.getValue(r*i++,o));this.outputCount=Number(e.getValue(r*i++,o)),this.customDataOffset=Number(e.getValue(r*i++,"*")),this.customDataSize=Number(e.getValue(r*i++,o));let a=[];for(let u=0;u<s;u++){let c=Number(e.getValue(r*i++,o)),d=Number(e.getValue(r*i++,"*")),p=Number(e.getValue(r*i++,o)),h=[];for(let g=0;g<p;g++)h.push(Number(e.getValue(r*i++,o)));a.push(new Bl(e,c,d,h))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map(s=>typeof s=="number"?this.inputs[s]:s)??this.inputs,r=t?.outputs??[],i=(s,a,u)=>new Bl(this.module,a,this.output(s,u),u),o=(s,a)=>{let u=si(s,a);if(!u)throw new Error(`Unsupported data type: ${s}`);let c=u>0?this.backend.gpuDataManager.create(u).id:0;return new Bl(this.module,s,c,a)};return this.backend.run(e,n,r,i,o,this.outputCount)}output(e,t){let n=this.module.stackSave();try{let r=this.module.PTR_SIZE,i=r===4?"i32":"i64",o=this.module.stackAlloc((1+t.length)*r);this.module.setValue(o,t.length,i);for(let s=0;s<t.length;s++)this.module.setValue(o+r*(s+1),t[s],i);return this.module._JsepOutput(this.opKernelContext,e,o)}catch(r){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${r}`)}finally{this.module.stackRestore(n)}}},A2=async(e,t,n,r)=>{let i=t.jsepInit;if(!i)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let o=new $2;await o.initialize(n,r),i("webgpu",[o,s=>o.alloc(Number(s)),s=>o.free(s),(s,a,u,c=!1)=>{if(c)Ce("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(s)}, dst=${Number(a)}, size=${Number(u)}`),o.memcpy(Number(s),Number(a));else{Ce("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(s)}, gpuDataId=${Number(a)}, size=${Number(u)}`);let d=t.HEAPU8.subarray(Number(s>>>0),Number(s>>>0)+Number(u));o.upload(Number(a),d)}},async(s,a,u)=>{Ce("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${a}, size=${u}`),await o.download(Number(s),()=>t.HEAPU8.subarray(Number(a)>>>0,Number(a+u)>>>0))},(s,a,u)=>o.createKernel(s,Number(a),u,t.UTF8ToString(t._JsepGetNodeName(Number(a)))),s=>o.releaseKernel(s),(s,a,u,c)=>{Ce("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${s}, contextDataOffset=${a}`);let d=new uD(t,o,Number(a));return o.computeKernel(Number(s),d,c)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let o=new N2(n);i("webnn",[o,()=>o.reserveTensorId(),s=>o.releaseTensorId(s),async(s,a,u,c,d)=>o.ensureTensor(s,a,u,c,d),(s,a)=>{o.uploadTensor(s,a)},async(s,a)=>o.downloadTensor(s,a)])}}}),lD,og,sg,wr,cD,Jl,ag,ug,wm,lg,cg,dg,O2=H(()=>{"use strict";Fj(),zj(),se(),ci(),Vm(),BD(),lD=(e,t)=>{nt()._OrtInit(e,t)!==0&&$e("Can't initialize onnxruntime.")},og=async e=>{lD(e.wasm.numThreads,Kl(e.logLevel))},sg=async(e,t)=>{{let n=(RV(),Wl(k2)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let r=e.webgpu.adapter;if(r){if(typeof r.limits!="object"||typeof r.features!="object"||typeof r.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let i=e.webgpu.powerPreference;if(i!==void 0&&i!=="low-power"&&i!=="high-performance")throw new Error(`Invalid powerPreference setting: "${i}"`);let o=e.webgpu.forceFallbackAdapter;if(o!==void 0&&typeof o!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${o}"`);if(r=await navigator.gpu.requestAdapter({powerPreference:i,forceFallbackAdapter:o}),!r)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await n("webgpu",nt(),e,r)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",nt(),e)}}},wr=new Map,cD=e=>{let t=nt(),n=t.stackSave();try{let r=t.PTR_SIZE,i=t.stackAlloc(2*r);t._OrtGetInputOutputCount(e,i,i+r)!==0&&$e("Can't get session input/output count.");let o=r===4?"i32":"i64";return[Number(t.getValue(i,o)),Number(t.getValue(i+r,o))]}finally{t.stackRestore(n)}},Jl=e=>{let t=nt(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},ag=async(e,t)=>{let n,r,i=nt();Array.isArray(e)?[n,r]=e:e.buffer===i.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Jl(e);let o=0,s=0,a=0,u=[],c=[],d=[];try{if([s,u]=zD(t),t?.externalData&&i.mountExternalData){let b=[];for(let T of t.externalData){let C=typeof T=="string"?T:T.path;b.push(qm(typeof T=="string"?T:T.data).then(S=>{i.mountExternalData(C,S)}))}await Promise.all(b)}for(let b of t?.executionProviders??[])if((typeof b=="string"?b:b.name)==="webnn"){if(i.shouldTransferToMLTensor=!1,typeof b!="string"){let T=b,C=T?.context,S=T?.gpuDevice,$=T?.deviceType,M=T?.powerPreference;C?i.currentContext=C:S?i.currentContext=await i.jsepCreateMLContext(S):i.currentContext=await i.jsepCreateMLContext({deviceType:$,powerPreference:M})}else i.currentContext=await i.jsepCreateMLContext();break}o=await i._OrtCreateSession(n,r,s),o===0&&$e("Can't create a session."),i.jsepOnCreateSession?.(),i.currentContext&&(i.jsepRegisterMLContext(o,i.currentContext),i.currentContext=void 0,i.shouldTransferToMLTensor=!0);let[p,h]=cD(o),g=!!t?.enableGraphCapture,y=[],w=[],x=[];for(let b=0;b<p;b++){let T=i._OrtGetInputName(o,b);T===0&&$e("Can't get an input name."),c.push(T),y.push(i.UTF8ToString(T))}for(let b=0;b<h;b++){let T=i._OrtGetOutputName(o,b);T===0&&$e("Can't get an output name."),d.push(T);let C=i.UTF8ToString(T);w.push(C);{if(g&&t?.preferredOutputLocation===void 0){x.push("gpu-buffer");continue}let S=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[C]??"cpu";if(S!=="cpu"&&S!=="cpu-pinned"&&S!=="gpu-buffer"&&S!=="ml-tensor")throw new Error(`Not supported preferred output location: ${S}.`);if(g&&S!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${S}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);x.push(S)}}let I=null;return x.some(b=>b==="gpu-buffer"||b==="ml-tensor")&&(a=i._OrtCreateBinding(o),a===0&&$e("Can't create IO binding."),I={handle:a,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(b=>xm(b))}),wr.set(o,[o,c,d,I,g,!1]),[o,y,w]}catch(p){throw c.forEach(h=>i._OrtFree(h)),d.forEach(h=>i._OrtFree(h)),a!==0&&i._OrtReleaseBinding(a)!==0&&$e("Can't release IO binding."),o!==0&&i._OrtReleaseSession(o)!==0&&$e("Can't release session."),p}finally{i._free(n),s!==0&&i._OrtReleaseSessionOptions(s)!==0&&$e("Can't release session options."),u.forEach(p=>i._free(p)),i.unmountExternalData?.()}},ug=e=>{let t=nt(),n=wr.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,i,o,s,a]=n;s&&(a&&t._OrtClearBoundOutputs(s.handle)!==0&&$e("Can't clear bound outputs."),t._OrtReleaseBinding(s.handle)!==0&&$e("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),i.forEach(u=>t._OrtFree(u)),o.forEach(u=>t._OrtFree(u)),t._OrtReleaseSession(r)!==0&&$e("Can't release session."),wr.delete(e)},wm=async(e,t,n,r,i,o=!1)=>{if(!e){t.push(0);return}let s=nt(),a=s.PTR_SIZE,u=e[0],c=e[1],d=e[3],p=d,h,g;if(u==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let x=e[2].gpuBuffer;g=si(mo(u),c);let I=s.jsepRegisterBuffer;if(!I)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');h=I(r,i,x,g)}else if(d==="ml-tensor"){let x=e[2].mlTensor;g=si(mo(u),c);let I=s.jsepRegisterMLTensor;if(!I)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');h=I(r,x,mo(u),c)}else{let x=e[2];if(Array.isArray(x)){g=a*x.length,h=s._malloc(g),n.push(h);for(let I=0;I<x.length;I++){if(typeof x[I]!="string")throw new TypeError(`tensor data at index ${I} is not a string`);s.setValue(h+I*a,pt(x[I],n),"*")}}else{let I=s.jsepIsGraphInput;if(u!=="string"&&I){let b=s._OrtGetInputName(r,i),T=s.UTF8ToString(b);if(I(r,T)){let C=mo(u);g=si(C,c),p="ml-tensor";let S=s.jsepCreateTemporaryTensor,$=s.jsepUploadTensor;if(!S||!$)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let M=await S(r,C,c);$(M,new Uint8Array(x.buffer,x.byteOffset,x.byteLength)),h=M}else g=x.byteLength,h=s._malloc(g),n.push(h),s.HEAPU8.set(new Uint8Array(x.buffer,x.byteOffset,g),h)}else g=x.byteLength,h=s._malloc(g),n.push(h),s.HEAPU8.set(new Uint8Array(x.buffer,x.byteOffset,g),h)}}let y=s.stackSave(),w=s.stackAlloc(4*c.length);try{c.forEach((I,b)=>s.setValue(w+b*a,I,a===4?"i32":"i64"));let x=s._OrtCreateTensor(mo(u),h,g,w,c.length,xm(p));x===0&&$e(`Can't create tensor for input/output. session=${r}, index=${i}.`),t.push(x)}finally{s.stackRestore(y)}},lg=async(e,t,n,r,i,o)=>{let s=nt(),a=s.PTR_SIZE,u=wr.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let c=u[0],d=u[1],p=u[2],h=u[3],g=u[4],y=u[5],w=t.length,x=r.length,I=0,b=[],T=[],C=[],S=[],$=s.stackSave(),M=s.stackAlloc(w*a),L=s.stackAlloc(w*a),V=s.stackAlloc(x*a),G=s.stackAlloc(x*a);try{[I,b]=FD(o);for(let B=0;B<w;B++)await wm(n[B],T,S,e,t[B],g);for(let B=0;B<x;B++)await wm(i[B],C,S,e,w+r[B],g);for(let B=0;B<w;B++)s.setValue(M+B*a,T[B],"*"),s.setValue(L+B*a,d[t[B]],"*");for(let B=0;B<x;B++)s.setValue(V+B*a,C[B],"*"),s.setValue(G+B*a,p[r[B]],"*");if(h&&!y){let{handle:B,outputPreferredLocations:ye,outputPreferredLocationsEncoded:xe}=h;if(d.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${d.length}).`);for(let K=0;K<w;K++){let we=t[K];await s._OrtBindInput(B,d[we],T[K])!==0&&$e(`Can't bind input[${K}] for session=${e}.`)}for(let K=0;K<x;K++){let we=r[K];i[K]?.[3]?s._OrtBindOutput(B,p[we],C[K],0)!==0&&$e(`Can't bind pre-allocated output[${K}] for session=${e}.`):s._OrtBindOutput(B,p[we],0,xe[we])!==0&&$e(`Can't bind output[${K}] to ${ye[K]} for session=${e}.`)}wr.set(e,[c,d,p,h,g,!0])}s.jsepOnRunStart?.(c);let X;h?X=await s._OrtRunWithBinding(c,h.handle,x,V,I):X=await s._OrtRun(c,L,M,w,G,x,V,I),X!==0&&$e("failed to call OrtRun().");let oe=[];for(let B=0;B<x;B++){let ye=Number(s.getValue(V+B*a,"*"));if(ye===C[B]){oe.push(i[B]);continue}let xe=s.stackSave(),K=s.stackAlloc(4*a),we=!1,Ee,Q=0;try{s._OrtGetTensorData(ye,K,K+a,K+2*a,K+3*a)!==0&&$e(`Can't access output tensor data on index ${B}.`);let Te=a===4?"i32":"i64",z=Number(s.getValue(K,Te));Q=s.getValue(K+a,"*");let W=s.getValue(K+a*2,"*"),R=Number(s.getValue(K+a*3,Te)),te=[];for(let at=0;at<R;at++)te.push(Number(s.getValue(W+at*a,Te)));s._OrtFree(W)!==0&&$e("Can't free memory for tensor dims.");let Ze=te.reduce((at,Je)=>at*Je,1);Ee=oi(z);let kt=h?.outputPreferredLocations[r[B]];if(Ee==="string"){if(kt==="gpu-buffer"||kt==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let at=[];for(let Je=0;Je<Ze;Je++){let Pn=s.getValue(Q+Je*a,"*"),Tt=s.getValue(Q+(Je+1)*a,"*"),ea=Je===Ze-1?void 0:Tt-Pn;at.push(s.UTF8ToString(Pn,ea))}oe.push([Ee,te,at,"cpu"])}else if(kt==="gpu-buffer"&&Ze>0){let at=s.jsepGetBuffer;if(!at)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Je=at(Q),Pn=si(z,Ze);if(Pn===void 0||!Um(Ee))throw new Error(`Unsupported data type: ${Ee}`);we=!0,oe.push([Ee,te,{gpuBuffer:Je,download:s.jsepCreateDownloader(Je,Pn,Ee),dispose:()=>{s._OrtReleaseTensor(ye)!==0&&$e("Can't release tensor.")}},"gpu-buffer"])}else if(kt==="ml-tensor"&&Ze>0){let at=s.jsepEnsureTensor;if(!at)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(si(z,Ze)===void 0||!Wm(Ee))throw new Error(`Unsupported data type: ${Ee}`);let Je=await at(e,Q,z,te,!1);we=!0,oe.push([Ee,te,{mlTensor:Je,download:s.jsepCreateMLTensorDownloader(Q,Ee),dispose:()=>{s.jsepReleaseTensorId(Q),s._OrtReleaseTensor(ye)}},"ml-tensor"])}else{let at=Hm(Ee),Je=new at(Ze);new Uint8Array(Je.buffer,Je.byteOffset,Je.byteLength).set(s.HEAPU8.subarray(Q,Q+Je.byteLength)),oe.push([Ee,te,Je,"cpu"])}}finally{s.stackRestore(xe),Ee==="string"&&Q&&s._free(Q),we||s._OrtReleaseTensor(ye),s.jsepOnRunEnd?.(c)}}return h&&!g&&(s._OrtClearBoundOutputs(h.handle)!==0&&$e("Can't clear bound outputs."),wr.set(e,[c,d,p,h,g,!1])),oe}finally{s.stackRestore($),T.forEach(X=>s._OrtReleaseTensor(X)),C.forEach(X=>s._OrtReleaseTensor(X)),S.forEach(X=>s._free(X)),I!==0&&s._OrtReleaseRunOptions(I),b.forEach(X=>s._free(X))}},cg=e=>{let t=nt(),n=wr.get(e);if(!n)throw new Error("invalid session id");let r=n[0],i=t._OrtEndProfiling(r);i===0&&$e("Can't get an profile file name."),t._OrtFree(i)},dg=e=>{let t=[];for(let n of e){let r=n[2];!Array.isArray(r)&&"buffer"in r&&t.push(r.buffer)}return t}}),br,Gt,ho,Ws,qs,jl,bm,Vl,ni,ri,dD,P2,L2,F2,z2,B2,j2,V2,H2=H(()=>{"use strict";hn(),O2(),ci(),Bm(),br=()=>!!Le.wasm.proxy&&typeof document<"u",ho=!1,Ws=!1,qs=!1,Vl=new Map,ni=(e,t)=>{let n=Vl.get(e);n?n.push(t):Vl.set(e,[t])},ri=()=>{if(ho||!Ws||qs||!Gt)throw new Error("worker not ready")},dD=e=>{switch(e.data.type){case"init-wasm":ho=!1,e.data.err?(qs=!0,bm[1](e.data.err)):(Ws=!0,bm[0]()),jl&&(URL.revokeObjectURL(jl),jl=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Vl.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},P2=async()=>{if(!Ws){if(ho)throw new Error("multiple calls to 'initWasm()' detected.");if(qs)throw new Error("previous call to 'initWasm()' failed.");if(ho=!0,br())return new Promise((e,t)=>{Gt?.terminate(),PD().then(([n,r])=>{try{Gt=r,Gt.onerror=o=>t(o),Gt.onmessage=dD,bm=[e,t];let i={type:"init-wasm",in:Le};!i.in.wasm.wasmPaths&&(n||import.meta.url?.startsWith("file:"))&&(i.in.wasm.wasmPaths={wasm:new URL("ort-wasm-simd-threaded.jsep.wasm",import.meta.url).href}),Gt.postMessage(i),jl=n}catch(i){t(i)}},t)});try{await jm(Le.wasm),await og(Le),Ws=!0}catch(e){throw qs=!0,e}finally{ho=!1}}},L2=async e=>{if(br())return ri(),new Promise((t,n)=>{ni("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:Le}};Gt.postMessage(r)});await sg(Le,e)},F2=async e=>br()?(ri(),new Promise((t,n)=>{ni("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};Gt.postMessage(r,[e.buffer])})):Jl(e),z2=async(e,t)=>{if(br()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ri(),new Promise((n,r)=>{ni("create",[n,r]);let i={type:"create",in:{model:e,options:{...t}}},o=[];e instanceof Uint8Array&&o.push(e.buffer),Gt.postMessage(i,o)})}else return ag(e,t)},B2=async e=>{if(br())return ri(),new Promise((t,n)=>{ni("release",[t,n]);let r={type:"release",in:e};Gt.postMessage(r)});ug(e)},j2=async(e,t,n,r,i,o)=>{if(br()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(i.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return ri(),new Promise((s,a)=>{ni("run",[s,a]);let u=n,c={type:"run",in:{sessionId:e,inputIndices:t,inputs:u,outputIndices:r,options:o}};Gt.postMessage(c,dg(u))})}else return lg(e,t,n,r,i,o)},V2=async e=>{if(br())return ri(),new Promise((t,n)=>{ni("end-profiling",[t,n]);let r={type:"end-profiling",in:e};Gt.postMessage(r)});cg(e)}}),Im,fD,U2,OV=H(()=>{"use strict";hn(),H2(),se(),zm(),BD(),Im=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},fD=e=>{switch(e[3]){case"cpu":return new Qt(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Um(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:i}=e[2];return Qt.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:i})}case"ml-tensor":{let t=e[0];if(!Wm(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:i}=e[2];return Qt.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:i})}default:throw new Error(`invalid data location: ${e[3]}`)}},U2=class{async fetchModelAndCopyToWasmMemory(e){return F2(await qm(e))}async loadModel(e,t){On();let n;typeof e=="string"?n=await this.fetchModelAndCopyToWasmMemory(e):n=e,[this.sessionId,this.inputNames,this.outputNames]=await z2(n,t),pn()}async dispose(){return B2(this.sessionId)}async run(e,t,n){On();let r=[],i=[];Object.entries(e).forEach(p=>{let h=p[0],g=p[1],y=this.inputNames.indexOf(h);if(y===-1)throw new Error(`invalid input '${h}'`);r.push(g),i.push(y)});let o=[],s=[];Object.entries(t).forEach(p=>{let h=p[0],g=p[1],y=this.outputNames.indexOf(h);if(y===-1)throw new Error(`invalid output '${h}'`);o.push(g),s.push(y)});let a=r.map((p,h)=>Im(p,()=>`input "${this.inputNames[i[h]]}"`)),u=o.map((p,h)=>p?Im(p,()=>`output "${this.outputNames[s[h]]}"`):null),c=await j2(this.sessionId,i,a,s,u,n),d={};for(let p=0;p<c.length;p++)d[this.outputNames[s[p]]]=o[p]??fD(c[p]);return pn(),d}startProfiling(){}endProfiling(){V2(this.sessionId)}}}),W2={};Xs(W2,{OnnxruntimeWebAssemblyBackend:()=>Pm,initializeFlags:()=>Om,wasmBackend:()=>q2});var Om,Pm,q2,PV=H(()=>{"use strict";hn(),H2(),OV(),Om=()=>{if((typeof Le.wasm.initTimeout!="number"||Le.wasm.initTimeout<0)&&(Le.wasm.initTimeout=0),Le.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof Le.wasm.proxy!="boolean"&&(Le.wasm.proxy=!1),typeof Le.wasm.trace!="boolean"&&(Le.wasm.trace=!1),typeof Le.wasm.numThreads!="number"||!Number.isInteger(Le.wasm.numThreads)||Le.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Le.wasm.numThreads=1;else{let e=typeof navigator>"u"?wj("node:os").cpus().length:navigator.hardwareConcurrency;Le.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Pm=class{async init(e){Om(),await P2(),await L2(e)}async createInferenceSessionHandler(e,t){let n=new U2;return await n.loadModel(e,t),Promise.resolve(n)}},q2=new Pm});hn();hn();hn();var LV="1.21.0";{let e=(PV(),Wl(W2)).wasmBackend;go("webgpu",e,5),go("webnn",e,5),go("cpu",e,10),go("wasm",e,10)}Object.defineProperty(Le.versions,"web",{value:LV,enumerable:!0});var G2="https://kherrick.github.io/signature-detection",K2="signature-detection/models/yolov8s/1/model.onnx";var He=640,ec=null,fg=.5,pg=.5;async function zV(e){if(ec)return ec;try{postMessage({type:"progress",key:"Loading model...",current:0,total:100}),Le.wasm.wasmPaths=e,Le.wasm.numThreads=1;let t=["wasm"];return ec=await Xl.create(`${G2}/${K2}`,{executionProviders:t,graphOptimizationLevel:"disabled",enableCpuMemArena:!1,enableMemPattern:!1,executionMode:"sequential"}),postMessage({type:"progress",key:"Model loaded",current:100,total:100}),postMessage({type:"modelLoaded"}),ec}catch(t){throw new Error(`Failed to load model: ${t}`)}}function BV(e){let{width:t,height:n,data:r}=e,i=new Float32Array(3*He*He),o=Math.min(He/t,He/n),s=Math.round(t*o),a=Math.round(n*o),u=(He-s)/2,c=(He-a)/2,p=new OffscreenCanvas(He,He).getContext("2d");if(!p)throw new Error("Failed to get canvas context");p.fillStyle="#808080",p.fillRect(0,0,He,He);let h=new OffscreenCanvas(t,n),g=h.getContext("2d");if(!g)throw new Error("Failed to get temp canvas context");g.putImageData(e,0,0),p.drawImage(h,0,0,t,n,u,c,s,a);let w=p.getImageData(0,0,He,He).data,x=0;for(let I=0;I<He;I++)for(let b=0;b<He;b++){let T=(I*He+b)*4;i[x]=w[T]/255,i[x+He*He]=w[T+1]/255,i[x+2*He*He]=w[T+2]/255,x++}return i}function jV(e,t){let n=Math.max(e.x,t.x),r=Math.max(e.y,t.y),i=Math.min(e.x+e.width,t.x+t.width),o=Math.min(e.y+e.height,t.y+t.height);if(i<=n||o<=r)return 0;let s=(i-n)*(o-r),a=e.width*e.height,u=t.width*t.height,c=a+u-s;return s/c}function VV(e){e.sort((n,r)=>r.confidence-n.confidence);let t=[];for(let n=0;n<e.length;n++){let r=e[n],i=!0;for(let o=0;o<t.length;o++)if(jV(r,t[o])>pg){i=!1;break}i&&t.push(r)}return t}function HV(e,t,n){let r=[],i=e.data,o=e.dims[2],s=e.dims[1]-4,a=Math.min(He/t,He/n),u=Math.round(t*a),c=Math.round(n*a),d=(He-u)/2,p=(He-c)/2;for(let h=0;h<o;h++){let g=i[h],y=i[o+h],w=i[2*o+h],x=i[3*o+h],I=0,b=0;for(let T=0;T<s;T++){let C=i[(4+T)*o+h];C>I&&(I=C,b=T)}if(I>fg){let T=g-w/2,C=y-x/2,S=Math.max(0,(T-d)/a),$=Math.max(0,(C-p)/a),M=Math.min(t-S,w/a),L=Math.min(n-$,x/a);M>0&&L>0&&r.push({x:S,y:$,width:M,height:L,confidence:I,class:"signature"})}}return VV(r)}async function UV(e){try{let t=await createImageBitmap(e),r=new OffscreenCanvas(t.width,t.height).getContext("2d");if(!r)throw new Error("Failed to get canvas context");r.drawImage(t,0,0);let i=r.getImageData(0,0,t.width,t.height);return t.close(),i}catch(t){throw new Error(`Failed to load image: ${t}`)}}async function WV(e,t,n){try{postMessage({type:"progress",key:"Loading image...",current:10,total:100});let r=await UV(e);postMessage({type:"progress",key:"Processing image...",current:30,total:100});let i=await zV(n);postMessage({type:"progress",key:"Running inference...",current:50,total:100});let o=new Qt("float32",BV(r),[1,3,He,He]),a=(await i.run({images:o})).output0;postMessage({type:"progress",key:"Processing results...",current:80,total:100});let u=HV(a,r.width,r.height);RE()&&console.info("detections",u),postMessage({type:"progress",key:"Complete",current:100,total:100}),postMessage({type:"result",id:t,result:{detections:u,imageData:r}})}catch(r){postMessage({type:"error",id:t,error:r.message})}}addEventListener("message",async e=>{let{type:t,id:n,file:r,wasmPath:i,confThreshold:o,iouThreshold:s}=e.data;switch(t){case"detect":o!==void 0&&(fg=o),s!==void 0&&(pg=s),await WV(r,n,i);break;case"updateThresholds":o!==void 0&&(fg=o),s!==void 0&&(pg=s);break;default:console.warn("Unknown message type:",t)}});
