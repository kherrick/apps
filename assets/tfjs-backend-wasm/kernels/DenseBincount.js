/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { DenseBincount } from '@tensorflow/tfjs-core';
import { CppDType } from './types';
let wasmDenseBincount;
function setup(backend) {
    wasmDenseBincount = backend.wasm.cwrap('DenseBincount', null /*void*/, [
        'number',
        'array',
        'number',
        'number',
        'boolean',
        'number',
        'number',
        'boolean',
        'number', // outId
    ]);
}
function denseBincount(args) {
    const { backend, inputs, attrs } = args;
    const { x, weights } = inputs;
    const { size, binaryOutput } = attrs;
    const hasWeights = weights.shape.reduce((p, v) => p * v, 1) !== 0;
    const outShape = x.shape.length === 1 ? [size] : [x.shape[0], size];
    const out = backend.makeOutput(outShape, weights.dtype);
    function tensorId(x) {
        return backend.dataIdMap.get(x.dataId).id;
    }
    wasmDenseBincount(tensorId(x), new Uint8Array(new Int32Array(x.shape).buffer), x.shape.length, size, hasWeights, tensorId(weights), CppDType[weights.dtype], binaryOutput, tensorId(out));
    return out;
}
export const denseBincountConfig = {
    kernelName: DenseBincount,
    backendName: 'wasm',
    setupFunc: setup,
    kernelFunc: denseBincount
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVuc2VCaW5jb3VudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13YXNtL3NyYy9rZXJuZWxzL0RlbnNlQmluY291bnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsT0FBTyxFQUFDLGFBQWEsRUFBZ0YsTUFBTSx1QkFBdUIsQ0FBQztBQUluSSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRWpDLElBQUksaUJBRzZDLENBQUM7QUFFbEQsU0FBUyxLQUFLLENBQUMsT0FBb0I7SUFDakMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDckUsUUFBUTtRQUNSLE9BQU87UUFDUCxRQUFRO1FBQ1IsUUFBUTtRQUNSLFNBQVM7UUFDVCxRQUFRO1FBQ1IsUUFBUTtRQUNSLFNBQVM7UUFDVCxRQUFRLEVBQUksUUFBUTtLQUNyQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsU0FBUyxhQUFhLENBQUMsSUFJdEI7SUFDQyxNQUFNLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEMsTUFBTSxFQUFDLENBQUMsRUFBRSxPQUFPLEVBQUMsR0FBRyxNQUFNLENBQUM7SUFDNUIsTUFBTSxFQUFDLElBQUksRUFBRSxZQUFZLEVBQUMsR0FBRyxLQUFLLENBQUM7SUFFbkMsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRSxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNwRSxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFeEQsU0FBUyxRQUFRLENBQUMsQ0FBYTtRQUM3QixPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDNUMsQ0FBQztJQUNELGlCQUFpQixDQUNiLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQzNELENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUNuRCxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLFlBQVksRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUUxRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBaUI7SUFDL0MsVUFBVSxFQUFFLGFBQWE7SUFDekIsV0FBVyxFQUFFLE1BQU07SUFDbkIsU0FBUyxFQUFFLEtBQUs7SUFDaEIsVUFBVSxFQUFFLGFBQXNDO0NBQ25ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge0RlbnNlQmluY291bnQsIERlbnNlQmluY291bnRBdHRycywgRGVuc2VCaW5jb3VudElucHV0cywgS2VybmVsQ29uZmlnLCBLZXJuZWxGdW5jLCBUZW5zb3JJbmZvfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge0JhY2tlbmRXYXNtfSBmcm9tICcuLi9iYWNrZW5kX3dhc20nO1xuXG5pbXBvcnQge0NwcERUeXBlfSBmcm9tICcuL3R5cGVzJztcblxubGV0IHdhc21EZW5zZUJpbmNvdW50OiAoXG4gICAgeElkOiBudW1iZXIsIHhTaGFwZTogVWludDhBcnJheSwgeFNoYXBlTGVuOiBudW1iZXIsIHNpemU6IG51bWJlcixcbiAgICBoYXNXZWlnaHRzOiBib29sZWFuLCB3ZWlnaHRzSWQ6IG51bWJlciwgd2VpZ2h0c0RUeXBlOiBDcHBEVHlwZSxcbiAgICBiaW5hcnlPdXRwdXQ6IGJvb2xlYW4sIG91dElkOiBudW1iZXIpID0+IHZvaWQ7XG5cbmZ1bmN0aW9uIHNldHVwKGJhY2tlbmQ6IEJhY2tlbmRXYXNtKTogdm9pZCB7XG4gIHdhc21EZW5zZUJpbmNvdW50ID0gYmFja2VuZC53YXNtLmN3cmFwKCdEZW5zZUJpbmNvdW50JywgbnVsbCAvKnZvaWQqLywgW1xuICAgICdudW1iZXInLCAgIC8vIHhJZFxuICAgICdhcnJheScsICAgIC8vIHhTaGFwZVxuICAgICdudW1iZXInLCAgIC8vIHhTaGFwZUxlblxuICAgICdudW1iZXInLCAgIC8vIHNpemVcbiAgICAnYm9vbGVhbicsICAvLyBoYXNXZWlnaHRzXG4gICAgJ251bWJlcicsICAgLy8gd2VpZ2h0c0lkXG4gICAgJ251bWJlcicsICAgLy8gd2VpZ2h0c0RUeXBlXG4gICAgJ2Jvb2xlYW4nLCAgLy8gYmluYXJ5T3V0cHV0XG4gICAgJ251bWJlcicsICAgLy8gb3V0SWRcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIGRlbnNlQmluY291bnQoYXJnczoge1xuICBiYWNrZW5kOiBCYWNrZW5kV2FzbSxcbiAgaW5wdXRzOiBEZW5zZUJpbmNvdW50SW5wdXRzLFxuICBhdHRyczogRGVuc2VCaW5jb3VudEF0dHJzXG59KTogVGVuc29ySW5mbyB7XG4gIGNvbnN0IHtiYWNrZW5kLCBpbnB1dHMsIGF0dHJzfSA9IGFyZ3M7XG4gIGNvbnN0IHt4LCB3ZWlnaHRzfSA9IGlucHV0cztcbiAgY29uc3Qge3NpemUsIGJpbmFyeU91dHB1dH0gPSBhdHRycztcblxuICBjb25zdCBoYXNXZWlnaHRzID0gd2VpZ2h0cy5zaGFwZS5yZWR1Y2UoKHAsIHYpID0+IHAgKiB2LCAxKSAhPT0gMDtcbiAgY29uc3Qgb3V0U2hhcGUgPSB4LnNoYXBlLmxlbmd0aCA9PT0gMSA/IFtzaXplXSA6IFt4LnNoYXBlWzBdLCBzaXplXTtcbiAgY29uc3Qgb3V0ID0gYmFja2VuZC5tYWtlT3V0cHV0KG91dFNoYXBlLCB3ZWlnaHRzLmR0eXBlKTtcblxuICBmdW5jdGlvbiB0ZW5zb3JJZCh4OiBUZW5zb3JJbmZvKSB7XG4gICAgcmV0dXJuIGJhY2tlbmQuZGF0YUlkTWFwLmdldCh4LmRhdGFJZCkuaWQ7XG4gIH1cbiAgd2FzbURlbnNlQmluY291bnQoXG4gICAgICB0ZW5zb3JJZCh4KSwgbmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoeC5zaGFwZSkuYnVmZmVyKSxcbiAgICAgIHguc2hhcGUubGVuZ3RoLCBzaXplLCBoYXNXZWlnaHRzLCB0ZW5zb3JJZCh3ZWlnaHRzKSxcbiAgICAgIENwcERUeXBlW3dlaWdodHMuZHR5cGVdLCBiaW5hcnlPdXRwdXQsIHRlbnNvcklkKG91dCkpO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBjb25zdCBkZW5zZUJpbmNvdW50Q29uZmlnOiBLZXJuZWxDb25maWcgPSB7XG4gIGtlcm5lbE5hbWU6IERlbnNlQmluY291bnQsXG4gIGJhY2tlbmROYW1lOiAnd2FzbScsXG4gIHNldHVwRnVuYzogc2V0dXAsXG4gIGtlcm5lbEZ1bmM6IGRlbnNlQmluY291bnQgYXMgdW5rbm93biBhcyBLZXJuZWxGdW5jXG59O1xuIl19